{"version":3,"sources":["pathetic/core.cljs"],"mappings":"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","names":["pathetic.core/separator","pathetic.core/separator-pattern","cljs.core/re-pattern","pathetic.core/common-prefix","coll1","coll2","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core/first","p1__36894#","cljs.core.take_while.cljs$core$IFn$_invoke$arity$2","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/second","p1__36895#","p2__36896#","cljs.core.map.cljs$core$IFn$_invoke$arity$3","cljs.core/PersistentVector","pathetic.core/unique-suffix","uninteresting-coll","interesting-coll","common-parts","cljs.core.drop.cljs$core$IFn$_invoke$arity$2","cljs.core/count","pathetic.core/split","path","clojure.string.split.cljs$core$IFn$_invoke$arity$2","pathetic.core/parse-path","cljs.core/empty?","path-pieces","G__36897","cljs.core.apply.cljs$core$IFn$_invoke$arity$3","cljs.core/vector","cljs.core/rest","pathetic.core/render-path","G__36898","cljs.core/Keyword","clojure.string.join.cljs$core$IFn$_invoke$arity$2","cljs.core/next","pathetic.core/starts-with","s","prefix","js/goog.string.startsWith","pathetic.core/absolute-path?","pathetic.core/up-dir","G__36899","cljs.core/last","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","cljs.core/pop","pathetic.core/normalize*","result","remaining-path","vec__36906","seq__36907","cljs.core/seq","first__36908","curr","remainder","pred__36909","expr__36910","cljs.core/=","pathetic.core/normalize","pathetic.core/relativize*","base-path","dest-path","common-path","base-suffix","dest-suffix","cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2","cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic","cljs.core.repeat.cljs$core$IFn$_invoke$arity$2","suffix","pred__36915","expr__36916","pathetic.core/relativize","pathetic.core/resolve*","other-path","base-components","other-components","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","pathetic.core/resolve","pathetic.core/ends-with","js/goog.string.endsWith","pathetic.core/ensure-trailing-separator","pathetic.core/as-url","url-or-string","js/goog.Uri","pathetic.core/split-url-on-path","url","url-string","path-idx","pre-path","post-path","pathetic.core/url-normalize","vec__36918","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","pathetic.core/url-ensure-trailing-separator","vec__36921"],"sourcesContent":["                       \n                                           \n                                            \n\n       (ns pathetic.core\n         (:refer-clojure :exclude [resolve])\n         (:require [clojure.string :as str]\n                   [goog.Uri :as uri]\n                   [goog.string :as string]))\n\n(def ^{:private true} separator \"/\")\n(def ^{:private true} separator-pattern (re-pattern separator))\n\n;; A note about the internal representation we work with for paths in this code.\n;; ---\n;; We work with vectors of path components, basically (that is, strings of the\n;; pieces between File/separator). If the path is an absolute path, the first\n;; component will be :root, so that if during processing everything else is\n;; removed, we know to render \"/\" and not \".\". Similarly, if the path is a\n;; relative path, the first component will be :cwd. The rest of the vector is\n;; the path components as strings. In this file, I'll call this data structure\n;; a \"path vector.\"\n\n;;\n;; Utility Functions\n;;\n\n(defn- common-prefix\n  \"Given two collections, returns a sequence containing the prefix they\n   share. Example: (common-prefix [\\\\a \\\\b] [\\\\a \\\\b \\\\c \\\\d]) -> (\\\\a \\\\b)\"\n  [coll1 coll2]\n  (map first (take-while #(= (first %) (second %))\n                         (map #(vector %1 %2) coll1 coll2))))\n\n(defn- unique-suffix\n  \"Returns the elements of interesting-coll that are not part of the common\n   prefix with uninteresting-coll.\"\n  [uninteresting-coll interesting-coll]\n  (let [common-parts (common-prefix uninteresting-coll interesting-coll)]\n    (drop (count common-parts) interesting-coll)))\n\n     \n           \n        \n                                           \n\n      \n(defn split\n  [path]\n  (if (= path separator)\n    []\n    (str/split (str path) separator-pattern)))\n\n(defn parse-path\n  \"Given a j.io.File or string containing a relative or absolute path,\n   returns the corresponding path vector data structure described at\n   the top of the file.\n\n   This function does not do any normalization or simplification. However,\n   because there is more than one way to write some paths, some simplification\n   might happen anyways, such as if the path starts with a (redundant) \\\".\\\".\"\n  [path]\n  ;; We have to check first if path is empty because when we try to parse\n  ;; say the root path, it will be separated into an empty list, making it\n  ;; indistinguishable. This avoids having an empty path parsed into [:root].\n  (if (empty? (str path))\n    nil\n    (let [path-pieces (split path)]\n      ;; (str/split \"/\" #\"/\") => [], so we check for this case first.\n      (if (= 0 (count path-pieces))\n        [:root]\n        (case (first path-pieces)\n          ;; If first item is \"\", we split a path that started with \"/\".\n          ;; Then we need to skip the \"\" at the start of path-pieces.\n          \"\" (apply vector :root (rest path-pieces))\n          ;; If the first item is \".\", note that we start with\n          ;; :cwd and then discard the \".\".\n          \".\" (apply vector :cwd (rest path-pieces))\n          (apply vector :cwd path-pieces))))))\n\n(defn render-path\n  \"Given a seq of path elements as created by parse-path, returns a string\n   containing the path represented. This function will only\n   ever use unix-style path rules, so an absolute path will always start with\n   the \\\"/\\\" separator.\n\n   NOTE: It is NOT the goal of this function to perform normalization, it just\n   renders what it is given. HOWEVER, that does NOT mean that it is always true\n   that (= (render-path (parse-path some-path)) some-path). That is, you may not\n   render the exact same string you parsed. This is because the path syntax does\n   not have exactly one way to write every path.\"\n  [path-pieces]\n  (case (first path-pieces)\n    :root (str separator (str/join separator (rest path-pieces)))\n    :cwd (if (next path-pieces)\n           (str/join separator (rest path-pieces))\n           \".\")\n    (str/join separator path-pieces)))\n\n;;\n;; Core Functions\n;;\n\n     \n                       \n                            \n                         \n\n      \n(defn starts-with\n  [s prefix]\n  (goog.string.startsWith s prefix))\n\n(defn absolute-path?\n  \"Returns true if the given argument is an absolute path.\"\n  [path]\n  (starts-with path separator))\n\n(defn up-dir\n  \"Given a seq of path elements as created by parse-path, returns a new\n   seq of path elements, but having gone \\\"up\\\" one directory. That is,\n   applies a \\\"..\\\" component to the path.\"\n  [path-pieces]\n  (case (last path-pieces)\n        ;; If the only thing in the path is :cwd, we reached the end of a\n        ;; relative path, and need to add the \"..\" to keep track of the\n        ;; intention for the relative path. Similarly, if the previous\n        ;; part is a \"..\", then we should add another, instead of removing the\n        ;; previous one.\n        (:cwd \"..\") (conj path-pieces \"..\")\n        ;; Going \"up\" from root just gives you root (it's its own parent).\n        :root path-pieces\n        (pop path-pieces)))\n\n(defn normalize*\n  \"Cleans up a path so that it has no leading/trailing whitespace, and\n   removes any removable same-/parent-dir references. path-pieces\n   should be a path vector in the format returned by parse-path;\n   return value is a vector in the same format.\"\n  [path-pieces]\n  (loop [result [(first path-pieces)]\n         remaining-path (rest path-pieces)]\n    (let [[curr & remainder] remaining-path]\n      (condp = curr\n        nil result\n        ;; Ignore a repeated separator (empty path component) or\n        ;; a same-dir component.\n        \"\" (recur result remainder)\n        \".\" (recur result remainder)\n        \"..\" (recur (up-dir result) remainder)\n        (recur (conj result curr) remainder)))))\n\n(defn normalize\n  \"Cleans up a path so that it has no leading/trailing whitespace, and\n   removes any unremovable same-/parent-dir references. Takes the path\n   argument as a string and returns its result as a string.\"\n  [path]\n  (render-path (normalize* (parse-path path))))\n\n(defn relativize*\n  \"Takes two absolute paths or two relative paths, and returns a relative path\n   that indicates the same file system location as dest-path, but\n   relative to base-path. Paths should be path vectors, and the return\n   value is also a path vector.\"\n  [base-path dest-path]\n  (let [common-path (common-prefix base-path dest-path)\n        base-suffix (drop (count common-path) base-path)\n        dest-suffix (drop (count common-path) dest-path)]\n    (if (nil? common-path)\n      (throw (ex-info \"Paths contain no common components.\" {})))\n    (concat [:cwd]\n            (repeat (count base-suffix) \"..\")\n            (loop [suffix []\n                   remainder dest-suffix]\n              (let [curr (first remainder)]\n                (condp = curr\n                  nil suffix\n                  \"\" (recur suffix (rest remainder))\n                  \".\" (recur suffix (rest remainder))\n                  \"..\" (recur (conj suffix \"..\")\n                              (rest remainder))\n                  (recur (conj suffix curr)\n                         (rest remainder))))))))\n\n(defn relativize\n  \"Takes two absolute paths or two relative paths, and returns a relative path\n   that indicates the same file system location as destination-path, but\n   relative to base-path.\"\n  [base-path dest-path]\n  (let [base-path (normalize* (parse-path base-path))\n        dest-path (normalize* (parse-path dest-path))]\n    (render-path (relativize* base-path dest-path))))\n\n(defn resolve*\n  \"Resolve the other-path against the base-path. If other-path is absolute,\n   the result is other-path. If other-path is nil, the result is base-path.\n   Otherwise, the result is other-path concatenated onto base-path. Does not\n   normalize its output. All inputs and outputs are path vectors.\"\n  [base-path other-path]\n  (cond (nil? other-path)\n        base-path\n        (= :root (first other-path)) ;; Is it absolute?\n        other-path\n        :else\n        (let [base-components (normalize* base-path)\n              ;; Skip the first element to get rid of the :cwd\n              other-components (rest (normalize* other-path))]\n          (concat base-components other-components))))\n\n(defn resolve\n  \"Resolve the other-path against the base-path. If other-path is absolute,\n   the result is other-path. If other-path is nil, the result is base-path.\n   Otherwise, the result is other-path concatenated onto base-path. Does not\n   normalize its output. Accepts an optional third argument containing a string\n   with the path separator to use.\"\n  [base-path other-path]\n  (render-path (resolve* (parse-path base-path)\n                         (parse-path other-path))))\n\n     \n               \n                            \n                       \n\n      \n(defn ends-with\n  [s suffix]\n  (goog.string.endsWith s suffix))\n\n(defn ensure-trailing-separator\n  \"If the path given does not have a trailing separator, returns a new path\n   that has one.\"\n  [path]\n  (if (ends-with path separator)\n    path\n    (str path separator)))\n\n;;\n;; URL Utilities\n;;\n\n     \n            \n                 \n                                            \n                 \n                                   \n\n      \n(defn as-url\n  [url-or-string]\n  (if (instance? goog.Uri url-or-string)\n    url-or-string\n    (goog.Uri. url-or-string)))\n\n(defn split-url-on-path\n  \"Given a URL or string containing a URL, returns a vector of the three\n   component strings: the stuff before the path, the path, and the stuff\n   after the path. Useful for destructuring.\"\n  [url-or-string]\n  ;; We borrow j.n.URL's or goog.Uri's parser just to make sure we get the right path.\n  (let [url (as-url url-or-string)\n        url-string (str url)\n        path (.getPath url)\n        path-idx (.lastIndexOf url-string path)\n        pre-path (.substring url-string 0 path-idx)\n        post-path (.substring url-string (+ path-idx (count path)))]\n    [pre-path path post-path]))\n\n(defn url-normalize\n  \"Behaves like normalize on the path part of a URL, but takes a j.n.URL or\n   string containing a URL, and returns a string containing the same URL\n   instead of just a path. Everything but the path part of the URL is unchanged\n   (query, anchor, protocol, etc).\"\n  [url-or-string]\n  (let [[pre-path path post-path] (split-url-on-path url-or-string)]\n    (str pre-path (normalize path) post-path)))\n\n(defn url-ensure-trailing-separator\n  \"Behaves like ensure-trailing-separator on the path part of a URL, but takes\n   a j.n.URL or string containing a URL, and returns a string containing the\n   same URL instead of just a path. Everything but the path part of the URL is\n   unchanged (query, anchor, protocol, etc).\"\n  [url-or-string]\n  (let [[pre-path path post-path] (split-url-on-path url-or-string)]\n    (str pre-path (ensure-trailing-separator path) post-path)))\n\n;;;;;;;;;;;; This file autogenerated from src/pathetic/core.cljx\n"]}