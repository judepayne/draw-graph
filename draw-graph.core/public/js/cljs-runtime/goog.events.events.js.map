{
"version":3,
"file":"goog.events.events.js",
"lineCount":537,
"mappings":"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",
"sources":["goog/events/events.js"],
"sourcesContent":["// Copyright 2005 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview An event manager for both native browser event\n * targets and custom JavaScript event targets\n * (`goog.events.Listenable`). This provides an abstraction\n * over browsers' event systems.\n *\n * It also provides a simulation of W3C event model's capture phase in\n * Internet Explorer (IE 8 and below). Caveat: the simulation does not\n * interact well with listeners registered directly on the elements\n * (bypassing goog.events) or even with listeners registered via\n * goog.events in a separate JS binary. In these cases, we provide\n * no ordering guarantees.\n *\n * The listeners will receive a \"patched\" event object. Such event object\n * contains normalized values for certain event properties that differs in\n * different browsers.\n *\n * Example usage:\n * <pre>\n * goog.events.listen(myNode, 'click', function(e) { alert('woo') });\n * goog.events.listen(myNode, 'mouseover', mouseHandler, true);\n * goog.events.unlisten(myNode, 'mouseover', mouseHandler, true);\n * goog.events.removeAll(myNode);\n * </pre>\n *\n *                                            in IE and event object patching]\n * @author arv@google.com (Erik Arvidsson)\n *\n * @see ../demos/events.html\n * @see ../demos/event-propagation.html\n * @see ../demos/stopevent.html\n */\n\n// IMPLEMENTATION NOTES:\n// goog.events stores an auxiliary data structure on each EventTarget\n// source being listened on. This allows us to take advantage of GC,\n// having the data structure GC'd when the EventTarget is GC'd. This\n// GC behavior is equivalent to using W3C DOM Events directly.\n\ngoog.provide('goog.events');\ngoog.provide('goog.events.CaptureSimulationMode');\ngoog.provide('goog.events.Key');\ngoog.provide('goog.events.ListenableType');\n\ngoog.require('goog.asserts');\ngoog.require('goog.debug.entryPointRegistry');\ngoog.require('goog.events.BrowserEvent');\ngoog.require('goog.events.BrowserFeature');\ngoog.require('goog.events.Listenable');\ngoog.require('goog.events.ListenerMap');\n\ngoog.forwardDeclare('goog.debug.ErrorHandler');\ngoog.forwardDeclare('goog.events.EventWrapper');\n\n\n/**\n * @typedef {number|goog.events.ListenableKey}\n */\ngoog.events.Key;\n\n\n/**\n * @typedef {EventTarget|goog.events.Listenable}\n */\ngoog.events.ListenableType;\n\n\n/**\n * Property name on a native event target for the listener map\n * associated with the event target.\n * @private @const {string}\n */\ngoog.events.LISTENER_MAP_PROP_ = 'closure_lm_' + ((Math.random() * 1e6) | 0);\n\n\n/**\n * String used to prepend to IE event types.\n * @const\n * @private\n */\ngoog.events.onString_ = 'on';\n\n\n/**\n * Map of computed \"on<eventname>\" strings for IE event types. Caching\n * this removes an extra object allocation in goog.events.listen which\n * improves IE6 performance.\n * @const\n * @dict\n * @private\n */\ngoog.events.onStringMap_ = {};\n\n\n/**\n * @enum {number} Different capture simulation mode for IE8-.\n */\ngoog.events.CaptureSimulationMode = {\n  /**\n   * Does not perform capture simulation. Will asserts in IE8- when you\n   * add capture listeners.\n   */\n  OFF_AND_FAIL: 0,\n\n  /**\n   * Does not perform capture simulation, silently ignore capture\n   * listeners.\n   */\n  OFF_AND_SILENT: 1,\n\n  /**\n   * Performs capture simulation.\n   */\n  ON: 2\n};\n\n\n/**\n * @define {number} The capture simulation mode for IE8-. By default,\n *     this is ON.\n */\ngoog.define('goog.events.CAPTURE_SIMULATION_MODE', 2);\n\n\n/**\n * Estimated count of total native listeners.\n * @private {number}\n */\ngoog.events.listenerCountEstimate_ = 0;\n\n\n/**\n * Adds an event listener for a specific event on a native event\n * target (such as a DOM element) or an object that has implemented\n * {@link goog.events.Listenable}. A listener can only be added once\n * to an object and if it is added again the key for the listener is\n * returned. Note that if the existing listener is a one-off listener\n * (registered via listenOnce), it will no longer be a one-off\n * listener after a call to listen().\n *\n * @param {EventTarget|goog.events.Listenable} src The node to listen\n *     to events on.\n * @param {string|Array<string>|\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\n *     type Event type or array of event types.\n * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(?):?}|null}\n *     listener Callback method, or an object with a handleEvent function.\n *     WARNING: passing an Object is now softly deprecated.\n * @param {(boolean|!AddEventListenerOptions)=} opt_options\n * @param {T=} opt_handler Element in whose scope to call the listener.\n * @return {goog.events.Key} Unique key for the listener.\n * @template T,EVENTOBJ\n */\ngoog.events.listen = function(src, type, listener, opt_options, opt_handler) {\n  if (opt_options && opt_options.once) {\n    return goog.events.listenOnce(\n        src, type, listener, opt_options, opt_handler);\n  }\n  if (goog.isArray(type)) {\n    for (var i = 0; i < type.length; i++) {\n      goog.events.listen(src, type[i], listener, opt_options, opt_handler);\n    }\n    return null;\n  }\n\n  listener = goog.events.wrapListener(listener);\n  if (goog.events.Listenable.isImplementedBy(src)) {\n    var capture =\n        goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;\n    return src.listen(\n        /** @type {string|!goog.events.EventId} */ (type), listener, capture,\n        opt_handler);\n  } else {\n    return goog.events.listen_(\n        /** @type {!EventTarget} */ (src), type, listener,\n        /* callOnce */ false, opt_options, opt_handler);\n  }\n};\n\n\n/**\n * Adds an event listener for a specific event on a native event\n * target. A listener can only be added once to an object and if it\n * is added again the key for the listener is returned.\n *\n * Note that a one-off listener will not change an existing listener,\n * if any. On the other hand a normal listener will change existing\n * one-off listener to become a normal listener.\n *\n * @param {EventTarget} src The node to listen to events on.\n * @param {string|?goog.events.EventId<EVENTOBJ>} type Event type.\n * @param {!Function} listener Callback function.\n * @param {boolean} callOnce Whether the listener is a one-off\n *     listener or otherwise.\n * @param {(boolean|!AddEventListenerOptions)=} opt_options\n * @param {Object=} opt_handler Element in whose scope to call the listener.\n * @return {goog.events.ListenableKey} Unique key for the listener.\n * @template EVENTOBJ\n * @private\n */\ngoog.events.listen_ = function(\n    src, type, listener, callOnce, opt_options, opt_handler) {\n  if (!type) {\n    throw new Error('Invalid event type');\n  }\n\n  var capture =\n      goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;\n  if (capture && !goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {\n    if (goog.events.CAPTURE_SIMULATION_MODE ==\n        goog.events.CaptureSimulationMode.OFF_AND_FAIL) {\n      goog.asserts.fail('Can not register capture listener in IE8-.');\n      return null;\n    } else if (\n        goog.events.CAPTURE_SIMULATION_MODE ==\n        goog.events.CaptureSimulationMode.OFF_AND_SILENT) {\n      return null;\n    }\n  }\n\n  var listenerMap = goog.events.getListenerMap_(src);\n  if (!listenerMap) {\n    src[goog.events.LISTENER_MAP_PROP_] = listenerMap =\n        new goog.events.ListenerMap(src);\n  }\n\n  var listenerObj = /** @type {goog.events.Listener} */ (\n      listenerMap.add(type, listener, callOnce, capture, opt_handler));\n\n  // If the listenerObj already has a proxy, it has been set up\n  // previously. We simply return.\n  if (listenerObj.proxy) {\n    return listenerObj;\n  }\n\n  var proxy = goog.events.getProxy();\n  listenerObj.proxy = proxy;\n\n  proxy.src = src;\n  proxy.listener = listenerObj;\n\n  // Attach the proxy through the browser's API\n  if (src.addEventListener) {\n    // Don't pass an object as `capture` if the browser doesn't support that.\n    if (!goog.events.BrowserFeature.PASSIVE_EVENTS) {\n      opt_options = capture;\n    }\n    // Don't break tests that expect a boolean.\n    if (opt_options === undefined) opt_options = false;\n    src.addEventListener(type.toString(), proxy, opt_options);\n  } else if (src.attachEvent) {\n    // The else if above used to be an unconditional else. It would call\n    // exception on IE11, spoiling the day of some callers. The previous\n    // incarnation of this code, from 2007, indicates that it replaced an\n    // earlier still version that caused excess allocations on IE6.\n    src.attachEvent(goog.events.getOnString_(type.toString()), proxy);\n  } else if (src.addListener && src.removeListener) {\n    // In IE, MediaQueryList uses addListener() insteadd of addEventListener. In\n    // Safari, there is no global for the MediaQueryList constructor, so we just\n    // check whether the object \"looks like\" MediaQueryList.\n    goog.asserts.assert(\n        type === 'change', 'MediaQueryList only has a change event');\n    src.addListener(proxy);\n  } else {\n    throw new Error('addEventListener and attachEvent are unavailable.');\n  }\n\n  goog.events.listenerCountEstimate_++;\n  return listenerObj;\n};\n\n\n/**\n * Helper function for returning a proxy function.\n * @return {!Function} A new or reused function object.\n */\ngoog.events.getProxy = function() {\n  var proxyCallbackFunction = goog.events.handleBrowserEvent_;\n  // Use a local var f to prevent one allocation.\n  var f =\n      goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT ? function(eventObject) {\n        return proxyCallbackFunction.call(f.src, f.listener, eventObject);\n      } : function(eventObject) {\n        var v = proxyCallbackFunction.call(f.src, f.listener, eventObject);\n        // NOTE(chrishenry): In IE, we hack in a capture phase. However, if\n        // there is inline event handler which tries to prevent default (for\n        // example <a href=\"...\" onclick=\"return false\">...</a>) in a\n        // descendant element, the prevent default will be overridden\n        // by this listener if this listener were to return true. Hence, we\n        // return undefined.\n        if (!v) return v;\n      };\n  return f;\n};\n\n\n/**\n * Adds an event listener for a specific event on a native event\n * target (such as a DOM element) or an object that has implemented\n * {@link goog.events.Listenable}. After the event has fired the event\n * listener is removed from the target.\n *\n * If an existing listener already exists, listenOnce will do\n * nothing. In particular, if the listener was previously registered\n * via listen(), listenOnce() will not turn the listener into a\n * one-off listener. Similarly, if there is already an existing\n * one-off listener, listenOnce does not modify the listeners (it is\n * still a once listener).\n *\n * @param {EventTarget|goog.events.Listenable} src The node to listen\n *     to events on.\n * @param {string|Array<string>|\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\n *     type Event type or array of event types.\n * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(?):?}|null}\n *     listener Callback method.\n * @param {(boolean|!AddEventListenerOptions)=} opt_options\n * @param {T=} opt_handler Element in whose scope to call the listener.\n * @return {goog.events.Key} Unique key for the listener.\n * @template T,EVENTOBJ\n */\ngoog.events.listenOnce = function(\n    src, type, listener, opt_options, opt_handler) {\n  if (goog.isArray(type)) {\n    for (var i = 0; i < type.length; i++) {\n      goog.events.listenOnce(src, type[i], listener, opt_options, opt_handler);\n    }\n    return null;\n  }\n\n  listener = goog.events.wrapListener(listener);\n  if (goog.events.Listenable.isImplementedBy(src)) {\n    var capture =\n        goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;\n    return src.listenOnce(\n        /** @type {string|!goog.events.EventId} */ (type), listener, capture,\n        opt_handler);\n  } else {\n    return goog.events.listen_(\n        /** @type {!EventTarget} */ (src), type, listener,\n        /* callOnce */ true, opt_options, opt_handler);\n  }\n};\n\n\n/**\n * Adds an event listener with a specific event wrapper on a DOM Node or an\n * object that has implemented {@link goog.events.Listenable}. A listener can\n * only be added once to an object.\n *\n * @param {EventTarget|goog.events.Listenable} src The target to\n *     listen to events on.\n * @param {goog.events.EventWrapper} wrapper Event wrapper to use.\n * @param {function(this:T, ?):?|{handleEvent:function(?):?}|null} listener\n *     Callback method, or an object with a handleEvent function.\n * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to\n *     false).\n * @param {T=} opt_handler Element in whose scope to call the listener.\n * @template T\n */\ngoog.events.listenWithWrapper = function(\n    src, wrapper, listener, opt_capt, opt_handler) {\n  wrapper.listen(src, listener, opt_capt, opt_handler);\n};\n\n\n/**\n * Removes an event listener which was added with listen().\n *\n * @param {EventTarget|goog.events.Listenable} src The target to stop\n *     listening to events on.\n * @param {string|Array<string>|\n *     !goog.events.EventId<EVENTOBJ>|!Array<!goog.events.EventId<EVENTOBJ>>}\n *     type Event type or array of event types to unlisten to.\n * @param {function(?):?|{handleEvent:function(?):?}|null} listener The\n *     listener function to remove.\n * @param {(boolean|!EventListenerOptions)=} opt_options\n *     whether the listener is fired during the capture or bubble phase of the\n *     event.\n * @param {Object=} opt_handler Element in whose scope to call the listener.\n * @return {?boolean} indicating whether the listener was there to remove.\n * @template EVENTOBJ\n */\ngoog.events.unlisten = function(src, type, listener, opt_options, opt_handler) {\n  if (goog.isArray(type)) {\n    for (var i = 0; i < type.length; i++) {\n      goog.events.unlisten(src, type[i], listener, opt_options, opt_handler);\n    }\n    return null;\n  }\n  var capture =\n      goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;\n\n  listener = goog.events.wrapListener(listener);\n  if (goog.events.Listenable.isImplementedBy(src)) {\n    return src.unlisten(\n        /** @type {string|!goog.events.EventId} */ (type), listener, capture,\n        opt_handler);\n  }\n\n  if (!src) {\n    // TODO(chrishenry): We should tighten the API to only accept\n    // non-null objects, or add an assertion here.\n    return false;\n  }\n\n  var listenerMap = goog.events.getListenerMap_(\n      /** @type {!EventTarget} */ (src));\n  if (listenerMap) {\n    var listenerObj = listenerMap.getListener(\n        /** @type {string|!goog.events.EventId} */ (type), listener, capture,\n        opt_handler);\n    if (listenerObj) {\n      return goog.events.unlistenByKey(listenerObj);\n    }\n  }\n\n  return false;\n};\n\n\n/**\n * Removes an event listener which was added with listen() by the key\n * returned by listen().\n *\n * @param {goog.events.Key} key The key returned by listen() for this\n *     event listener.\n * @return {boolean} indicating whether the listener was there to remove.\n */\ngoog.events.unlistenByKey = function(key) {\n  // TODO(chrishenry): Remove this check when tests that rely on this\n  // are fixed.\n  if (goog.isNumber(key)) {\n    return false;\n  }\n\n  var listener = key;\n  if (!listener || listener.removed) {\n    return false;\n  }\n\n  var src = listener.src;\n  if (goog.events.Listenable.isImplementedBy(src)) {\n    return /** @type {!goog.events.Listenable} */ (src).unlistenByKey(listener);\n  }\n\n  var type = listener.type;\n  var proxy = listener.proxy;\n  if (src.removeEventListener) {\n    src.removeEventListener(type, proxy, listener.capture);\n  } else if (src.detachEvent) {\n    src.detachEvent(goog.events.getOnString_(type), proxy);\n  } else if (src.addListener && src.removeListener) {\n    src.removeListener(proxy);\n  }\n  goog.events.listenerCountEstimate_--;\n\n  var listenerMap = goog.events.getListenerMap_(\n      /** @type {!EventTarget} */ (src));\n  // TODO(chrishenry): Try to remove this conditional and execute the\n  // first branch always. This should be safe.\n  if (listenerMap) {\n    listenerMap.removeByKey(listener);\n    if (listenerMap.getTypeCount() == 0) {\n      // Null the src, just because this is simple to do (and useful\n      // for IE <= 7).\n      listenerMap.src = null;\n      // We don't use delete here because IE does not allow delete\n      // on a window object.\n      src[goog.events.LISTENER_MAP_PROP_] = null;\n    }\n  } else {\n    /** @type {!goog.events.Listener} */ (listener).markAsRemoved();\n  }\n\n  return true;\n};\n\n\n/**\n * Removes an event listener which was added with listenWithWrapper().\n *\n * @param {EventTarget|goog.events.Listenable} src The target to stop\n *     listening to events on.\n * @param {goog.events.EventWrapper} wrapper Event wrapper to use.\n * @param {function(?):?|{handleEvent:function(?):?}|null} listener The\n *     listener function to remove.\n * @param {boolean=} opt_capt In DOM-compliant browsers, this determines\n *     whether the listener is fired during the capture or bubble phase of the\n *     event.\n * @param {Object=} opt_handler Element in whose scope to call the listener.\n */\ngoog.events.unlistenWithWrapper = function(\n    src, wrapper, listener, opt_capt, opt_handler) {\n  wrapper.unlisten(src, listener, opt_capt, opt_handler);\n};\n\n\n/**\n * Removes all listeners from an object. You can also optionally\n * remove listeners of a particular type.\n *\n * @param {Object|undefined} obj Object to remove listeners from. Must be an\n *     EventTarget or a goog.events.Listenable.\n * @param {string|!goog.events.EventId=} opt_type Type of event to remove.\n *     Default is all types.\n * @return {number} Number of listeners removed.\n */\ngoog.events.removeAll = function(obj, opt_type) {\n  // TODO(chrishenry): Change the type of obj to\n  // (!EventTarget|!goog.events.Listenable).\n\n  if (!obj) {\n    return 0;\n  }\n\n  if (goog.events.Listenable.isImplementedBy(obj)) {\n    return /** @type {?} */ (obj).removeAllListeners(opt_type);\n  }\n\n  var listenerMap = goog.events.getListenerMap_(\n      /** @type {!EventTarget} */ (obj));\n  if (!listenerMap) {\n    return 0;\n  }\n\n  var count = 0;\n  var typeStr = opt_type && opt_type.toString();\n  for (var type in listenerMap.listeners) {\n    if (!typeStr || type == typeStr) {\n      // Clone so that we don't need to worry about unlistenByKey\n      // changing the content of the ListenerMap.\n      var listeners = listenerMap.listeners[type].concat();\n      for (var i = 0; i < listeners.length; ++i) {\n        if (goog.events.unlistenByKey(listeners[i])) {\n          ++count;\n        }\n      }\n    }\n  }\n  return count;\n};\n\n\n/**\n * Gets the listeners for a given object, type and capture phase.\n *\n * @param {Object} obj Object to get listeners for.\n * @param {string|!goog.events.EventId} type Event type.\n * @param {boolean} capture Capture phase?.\n * @return {Array<!goog.events.Listener>} Array of listener objects.\n */\ngoog.events.getListeners = function(obj, type, capture) {\n  if (goog.events.Listenable.isImplementedBy(obj)) {\n    return /** @type {!goog.events.Listenable} */ (obj).getListeners(\n        type, capture);\n  } else {\n    if (!obj) {\n      // TODO(chrishenry): We should tighten the API to accept\n      // !EventTarget|goog.events.Listenable, and add an assertion here.\n      return [];\n    }\n\n    var listenerMap = goog.events.getListenerMap_(\n        /** @type {!EventTarget} */ (obj));\n    return listenerMap ? listenerMap.getListeners(type, capture) : [];\n  }\n};\n\n\n/**\n * Gets the goog.events.Listener for the event or null if no such listener is\n * in use.\n *\n * @param {EventTarget|goog.events.Listenable} src The target from\n *     which to get listeners.\n * @param {?string|!goog.events.EventId<EVENTOBJ>} type The type of the event.\n * @param {function(EVENTOBJ):?|{handleEvent:function(?):?}|null} listener The\n *     listener function to get.\n * @param {boolean=} opt_capt In DOM-compliant browsers, this determines\n *                            whether the listener is fired during the\n *                            capture or bubble phase of the event.\n * @param {Object=} opt_handler Element in whose scope to call the listener.\n * @return {goog.events.ListenableKey} the found listener or null if not found.\n * @template EVENTOBJ\n */\ngoog.events.getListener = function(src, type, listener, opt_capt, opt_handler) {\n  // TODO(chrishenry): Change type from ?string to string, or add assertion.\n  type = /** @type {string} */ (type);\n  listener = goog.events.wrapListener(listener);\n  var capture = !!opt_capt;\n  if (goog.events.Listenable.isImplementedBy(src)) {\n    return src.getListener(type, listener, capture, opt_handler);\n  }\n\n  if (!src) {\n    // TODO(chrishenry): We should tighten the API to only accept\n    // non-null objects, or add an assertion here.\n    return null;\n  }\n\n  var listenerMap = goog.events.getListenerMap_(\n      /** @type {!EventTarget} */ (src));\n  if (listenerMap) {\n    return listenerMap.getListener(type, listener, capture, opt_handler);\n  }\n  return null;\n};\n\n\n/**\n * Returns whether an event target has any active listeners matching the\n * specified signature. If either the type or capture parameters are\n * unspecified, the function will match on the remaining criteria.\n *\n * @param {EventTarget|goog.events.Listenable} obj Target to get\n *     listeners for.\n * @param {string|!goog.events.EventId=} opt_type Event type.\n * @param {boolean=} opt_capture Whether to check for capture or bubble-phase\n *     listeners.\n * @return {boolean} Whether an event target has one or more listeners matching\n *     the requested type and/or capture phase.\n */\ngoog.events.hasListener = function(obj, opt_type, opt_capture) {\n  if (goog.events.Listenable.isImplementedBy(obj)) {\n    return obj.hasListener(opt_type, opt_capture);\n  }\n\n  var listenerMap = goog.events.getListenerMap_(\n      /** @type {!EventTarget} */ (obj));\n  return !!listenerMap && listenerMap.hasListener(opt_type, opt_capture);\n};\n\n\n/**\n * Provides a nice string showing the normalized event objects public members\n * @param {Object} e Event Object.\n * @return {string} String of the public members of the normalized event object.\n */\ngoog.events.expose = function(e) {\n  var str = [];\n  for (var key in e) {\n    if (e[key] && e[key].id) {\n      str.push(key + ' = ' + e[key] + ' (' + e[key].id + ')');\n    } else {\n      str.push(key + ' = ' + e[key]);\n    }\n  }\n  return str.join('\\n');\n};\n\n\n/**\n * Returns a string with on prepended to the specified type. This is used for IE\n * which expects \"on\" to be prepended. This function caches the string in order\n * to avoid extra allocations in steady state.\n * @param {string} type Event type.\n * @return {string} The type string with 'on' prepended.\n * @private\n */\ngoog.events.getOnString_ = function(type) {\n  if (type in goog.events.onStringMap_) {\n    return goog.events.onStringMap_[type];\n  }\n  return goog.events.onStringMap_[type] = goog.events.onString_ + type;\n};\n\n\n/**\n * Fires an object's listeners of a particular type and phase\n *\n * @param {Object} obj Object whose listeners to call.\n * @param {string|!goog.events.EventId} type Event type.\n * @param {boolean} capture Which event phase.\n * @param {Object} eventObject Event object to be passed to listener.\n * @return {boolean} True if all listeners returned true else false.\n */\ngoog.events.fireListeners = function(obj, type, capture, eventObject) {\n  if (goog.events.Listenable.isImplementedBy(obj)) {\n    return /** @type {!goog.events.Listenable} */ (obj).fireListeners(\n        type, capture, eventObject);\n  }\n\n  return goog.events.fireListeners_(obj, type, capture, eventObject);\n};\n\n\n/**\n * Fires an object's listeners of a particular type and phase.\n * @param {Object} obj Object whose listeners to call.\n * @param {string|!goog.events.EventId} type Event type.\n * @param {boolean} capture Which event phase.\n * @param {Object} eventObject Event object to be passed to listener.\n * @return {boolean} True if all listeners returned true else false.\n * @private\n */\ngoog.events.fireListeners_ = function(obj, type, capture, eventObject) {\n  /** @type {boolean} */\n  var retval = true;\n\n  var listenerMap = goog.events.getListenerMap_(\n      /** @type {EventTarget} */ (obj));\n  if (listenerMap) {\n    // TODO(chrishenry): Original code avoids array creation when there\n    // is no listener, so we do the same. If this optimization turns\n    // out to be not required, we can replace this with\n    // listenerMap.getListeners(type, capture) instead, which is simpler.\n    var listenerArray = listenerMap.listeners[type.toString()];\n    if (listenerArray) {\n      listenerArray = listenerArray.concat();\n      for (var i = 0; i < listenerArray.length; i++) {\n        var listener = listenerArray[i];\n        // We might not have a listener if the listener was removed.\n        if (listener && listener.capture == capture && !listener.removed) {\n          var result = goog.events.fireListener(listener, eventObject);\n          retval = retval && (result !== false);\n        }\n      }\n    }\n  }\n  return retval;\n};\n\n\n/**\n * Fires a listener with a set of arguments\n *\n * @param {goog.events.Listener} listener The listener object to call.\n * @param {Object} eventObject The event object to pass to the listener.\n * @return {*} Result of listener.\n */\ngoog.events.fireListener = function(listener, eventObject) {\n  var listenerFn = listener.listener;\n  var listenerHandler = listener.handler || listener.src;\n\n  if (listener.callOnce) {\n    goog.events.unlistenByKey(listener);\n  }\n  return listenerFn.call(listenerHandler, eventObject);\n};\n\n\n/**\n * Gets the total number of listeners currently in the system.\n * @return {number} Number of listeners.\n * @deprecated This returns estimated count, now that Closure no longer\n * stores a central listener registry. We still return an estimation\n * to keep existing listener-related tests passing. In the near future,\n * this function will be removed.\n */\ngoog.events.getTotalListenerCount = function() {\n  return goog.events.listenerCountEstimate_;\n};\n\n\n/**\n * Dispatches an event (or event like object) and calls all listeners\n * listening for events of this type. The type of the event is decided by the\n * type property on the event object.\n *\n * If any of the listeners returns false OR calls preventDefault then this\n * function will return false.  If one of the capture listeners calls\n * stopPropagation, then the bubble listeners won't fire.\n *\n * @param {goog.events.Listenable} src The event target.\n * @param {goog.events.EventLike} e Event object.\n * @return {boolean} If anyone called preventDefault on the event object (or\n *     if any of the handlers returns false) this will also return false.\n *     If there are no handlers, or if all handlers return true, this returns\n *     true.\n */\ngoog.events.dispatchEvent = function(src, e) {\n  goog.asserts.assert(\n      goog.events.Listenable.isImplementedBy(src),\n      'Can not use goog.events.dispatchEvent with ' +\n          'non-goog.events.Listenable instance.');\n  return src.dispatchEvent(e);\n};\n\n\n/**\n * Installs exception protection for the browser event entry point using the\n * given error handler.\n *\n * @param {goog.debug.ErrorHandler} errorHandler Error handler with which to\n *     protect the entry point.\n */\ngoog.events.protectBrowserEventEntryPoint = function(errorHandler) {\n  goog.events.handleBrowserEvent_ =\n      errorHandler.protectEntryPoint(goog.events.handleBrowserEvent_);\n};\n\n\n/**\n * Handles an event and dispatches it to the correct listeners. This\n * function is a proxy for the real listener the user specified.\n *\n * @param {goog.events.Listener} listener The listener object.\n * @param {Event=} opt_evt Optional event object that gets passed in via the\n *     native event handlers.\n * @return {*} Result of the event handler.\n * @this {EventTarget} The object or Element that fired the event.\n * @private\n */\ngoog.events.handleBrowserEvent_ = function(listener, opt_evt) {\n  if (listener.removed) {\n    return true;\n  }\n\n  // Synthesize event propagation if the browser does not support W3C\n  // event model.\n  if (!goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {\n    var ieEvent = opt_evt ||\n        /** @type {Event} */ (goog.getObjectByName('window.event'));\n    var evt = new goog.events.BrowserEvent(ieEvent, this);\n    /** @type {*} */\n    var retval = true;\n\n    if (goog.events.CAPTURE_SIMULATION_MODE ==\n        goog.events.CaptureSimulationMode.ON) {\n      // If we have not marked this event yet, we should perform capture\n      // simulation.\n      if (!goog.events.isMarkedIeEvent_(ieEvent)) {\n        goog.events.markIeEvent_(ieEvent);\n\n        var ancestors = [];\n        for (var parent = evt.currentTarget; parent;\n             parent = parent.parentNode) {\n          ancestors.push(parent);\n        }\n\n        // Fire capture listeners.\n        var type = listener.type;\n        for (var i = ancestors.length - 1; !evt.propagationStopped_ && i >= 0;\n             i--) {\n          evt.currentTarget = ancestors[i];\n          var result =\n              goog.events.fireListeners_(ancestors[i], type, true, evt);\n          retval = retval && result;\n        }\n\n        // Fire bubble listeners.\n        //\n        // We can technically rely on IE to perform bubble event\n        // propagation. However, it turns out that IE fires events in\n        // opposite order of attachEvent registration, which broke\n        // some code and tests that rely on the order. (While W3C DOM\n        // Level 2 Events TR leaves the event ordering unspecified,\n        // modern browsers and W3C DOM Level 3 Events Working Draft\n        // actually specify the order as the registration order.)\n        for (var i = 0; !evt.propagationStopped_ && i < ancestors.length; i++) {\n          evt.currentTarget = ancestors[i];\n          var result =\n              goog.events.fireListeners_(ancestors[i], type, false, evt);\n          retval = retval && result;\n        }\n      }\n    } else {\n      retval = goog.events.fireListener(listener, evt);\n    }\n    return retval;\n  }\n\n  // Otherwise, simply fire the listener.\n  return goog.events.fireListener(\n      listener, new goog.events.BrowserEvent(opt_evt, this));\n};\n\n\n/**\n * This is used to mark the IE event object so we do not do the Closure pass\n * twice for a bubbling event.\n * @param {Event} e The IE browser event.\n * @private\n */\ngoog.events.markIeEvent_ = function(e) {\n  // Only the keyCode and the returnValue can be changed. We use keyCode for\n  // non keyboard events.\n  // event.returnValue is a bit more tricky. It is undefined by default. A\n  // boolean false prevents the default action. In a window.onbeforeunload and\n  // the returnValue is non undefined it will be alerted. However, we will only\n  // modify the returnValue for keyboard events. We can get a problem if non\n  // closure events sets the keyCode or the returnValue\n\n  var useReturnValue = false;\n\n  if (e.keyCode == 0) {\n    // We cannot change the keyCode in case that srcElement is input[type=file].\n    // We could test that that is the case but that would allocate 3 objects.\n    // If we use try/catch we will only allocate extra objects in the case of a\n    // failure.\n\n    try {\n      e.keyCode = -1;\n      return;\n    } catch (ex) {\n      useReturnValue = true;\n    }\n  }\n\n  if (useReturnValue ||\n      /** @type {boolean|undefined} */ (e.returnValue) == undefined) {\n    e.returnValue = true;\n  }\n};\n\n\n/**\n * This is used to check if an IE event has already been handled by the Closure\n * system so we do not do the Closure pass twice for a bubbling event.\n * @param {Event} e  The IE browser event.\n * @return {boolean} True if the event object has been marked.\n * @private\n */\ngoog.events.isMarkedIeEvent_ = function(e) {\n  return e.keyCode < 0 || e.returnValue != undefined;\n};\n\n\n/**\n * Counter to create unique event ids.\n * @private {number}\n */\ngoog.events.uniqueIdCounter_ = 0;\n\n\n/**\n * Creates a unique event id.\n *\n * @param {string} identifier The identifier.\n * @return {string} A unique identifier.\n * @idGenerator {unique}\n */\ngoog.events.getUniqueId = function(identifier) {\n  return identifier + '_' + goog.events.uniqueIdCounter_++;\n};\n\n\n/**\n * @param {EventTarget} src The source object.\n * @return {goog.events.ListenerMap} A listener map for the given\n *     source object, or null if none exists.\n * @private\n */\ngoog.events.getListenerMap_ = function(src) {\n  var listenerMap = src[goog.events.LISTENER_MAP_PROP_];\n  // IE serializes the property as well (e.g. when serializing outer\n  // HTML). So we must check that the value is of the correct type.\n  return listenerMap instanceof goog.events.ListenerMap ? listenerMap : null;\n};\n\n\n/**\n * Expando property for listener function wrapper for Object with\n * handleEvent.\n * @private @const {string}\n */\ngoog.events.LISTENER_WRAPPER_PROP_ =\n    '__closure_events_fn_' + ((Math.random() * 1e9) >>> 0);\n\n\n/**\n * @param {Object|Function} listener The listener function or an\n *     object that contains handleEvent method.\n * @return {!Function} Either the original function or a function that\n *     calls obj.handleEvent. If the same listener is passed to this\n *     function more than once, the same function is guaranteed to be\n *     returned.\n */\ngoog.events.wrapListener = function(listener) {\n  goog.asserts.assert(listener, 'Listener can not be null.');\n\n  if (goog.isFunction(listener)) {\n    return listener;\n  }\n\n  goog.asserts.assert(\n      listener.handleEvent, 'An object listener must have handleEvent method.');\n  if (!listener[goog.events.LISTENER_WRAPPER_PROP_]) {\n    listener[goog.events.LISTENER_WRAPPER_PROP_] = function(e) {\n      return /** @type {?} */ (listener).handleEvent(e);\n    };\n  }\n  return listener[goog.events.LISTENER_WRAPPER_PROP_];\n};\n\n\n// Register the browser event handler as an entry point, so that\n// it can be monitored for exception handling, etc.\ngoog.debug.entryPointRegistry.register(\n    /**\n     * @param {function(!Function): !Function} transformer The transforming\n     *     function.\n     */\n    function(transformer) {\n      goog.events.handleBrowserEvent_ =\n          transformer(goog.events.handleBrowserEvent_);\n    });\n"],
"names":["goog","provide","require","forwardDeclare","events","Key","ListenableType","LISTENER_MAP_PROP_","Math","random","onString_","onStringMap_","CaptureSimulationMode","OFF_AND_FAIL","OFF_AND_SILENT","ON","define","listenerCountEstimate_","listen","goog.events.listen","src","type","listener","opt_options","opt_handler","once","listenOnce","isArray","i","length","wrapListener","Listenable","isImplementedBy","capture","isObject","listen_","goog.events.listen_","callOnce","Error","BrowserFeature","HAS_W3C_EVENT_SUPPORT","CAPTURE_SIMULATION_MODE","asserts","fail","listenerMap","getListenerMap_","ListenerMap","listenerObj","add","proxy","getProxy","addEventListener","PASSIVE_EVENTS","undefined","toString","attachEvent","getOnString_","addListener","removeListener","assert","goog.events.getProxy","proxyCallbackFunction","handleBrowserEvent_","f","eventObject","call","v","goog.events.listenOnce","listenWithWrapper","goog.events.listenWithWrapper","wrapper","opt_capt","unlisten","goog.events.unlisten","getListener","unlistenByKey","goog.events.unlistenByKey","key","isNumber","removed","removeEventListener","detachEvent","removeByKey","getTypeCount","markAsRemoved","unlistenWithWrapper","goog.events.unlistenWithWrapper","removeAll","goog.events.removeAll","obj","opt_type","removeAllListeners","count","typeStr","listeners","concat","getListeners","goog.events.getListeners","goog.events.getListener","hasListener","goog.events.hasListener","opt_capture","expose","goog.events.expose","e","str","id","push","join","goog.events.getOnString_","fireListeners","goog.events.fireListeners","fireListeners_","goog.events.fireListeners_","retval","listenerArray","result","fireListener","goog.events.fireListener","listenerFn","listenerHandler","handler","getTotalListenerCount","goog.events.getTotalListenerCount","dispatchEvent","goog.events.dispatchEvent","protectBrowserEventEntryPoint","goog.events.protectBrowserEventEntryPoint","errorHandler","protectEntryPoint","goog.events.handleBrowserEvent_","opt_evt","ieEvent","getObjectByName","evt","BrowserEvent","isMarkedIeEvent_","markIeEvent_","ancestors","parent","currentTarget","parentNode","propagationStopped_","goog.events.markIeEvent_","useReturnValue","keyCode","ex","returnValue","goog.events.isMarkedIeEvent_","uniqueIdCounter_","getUniqueId","goog.events.getUniqueId","identifier","goog.events.getListenerMap_","LISTENER_WRAPPER_PROP_","goog.events.wrapListener","isFunction","handleEvent","debug","entryPointRegistry","register","transformer"]
}
