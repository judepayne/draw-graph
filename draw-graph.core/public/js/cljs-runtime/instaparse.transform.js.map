{"version":3,"sources":["instaparse/transform.cljc"],"mappings":";;;;AAKA,AAAA,AAAMA,AAAqBC,AAAEC;AAA7B,AACE,AAACC,AAAU,AAACC,AAAIH,AAAEC,AAAG,AAACG,AAAKH;;AAE7B;;;;AAAA,AAAMI,AAGHC,AAAIC;AAHP,AAIE,AACa,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAC,AAAA,AAAA,AAAAA,AAAYC,AAAAA,AAAUJ,AAAAA,AAAAA,AAAAA,AAAAA,AAAAA;AACjC,AAACK,AAA0BL,AAAIC;;AAC/BD;;;AAEJ,AAAA,AAAOM,AACJC,AAAcC;AADjB,AAEE,AAAMC,AAAU,AAAAC,AAAe,AAAA,AAAMF;AAArB,AAAA,AAAAE,AAAAA,AAACH,AAAAA,AAAAA;;AAAjB,AACE,AACEE;AACA,AAACV,AACC,AAACY,AAAMF,AAAU,AAACZ,AAAI,AAACe,AAAQN,AAAiBC,AAC1B,AAAA,AAAUC,AAChC,AAACV,AAAKU;;AALV,AAME,AAAA,AAAMA;AACN,AAAA,AAACK,AAAML,AAAoB,AAACX,AAAI,AAACe,AAAQN,AAAiBC,AAC1B,AAAA,AAAUC;;AAR5C,AAUEA;;;;;AAEN,AAAA,AAAOM,AACJP,AAAcC;AADjB,AAEE,AAAI,AAAK,AAACO,AAAYP,AAAY,AAACQ,AAAIR;AACrC,AAAAS,AAAmB,AAAAC,AAAe,AAACC,AAAMX;AAAtB,AAAA,AAAAU,AAAAA,AAACX,AAAAA,AAAAA;;AAApB,AAAA,AAAAU;AAAA,AAAAA,AAASR;AAAT,AACE,AAACV,AACC,AAACY,AAAMF,AAAU,AAACZ,AAAI,AAACe,AAAQE,AAAiBP,AAC1B,AAACa,AAAKZ,AAC5B,AAACV,AAAKU;;AACR,AAACZ,AACC,AAAA,AAACyB,AAAM,AAACF,AAAMX,AACR,AAACX,AAAI,AAACe,AAAQE,AAAiBP,AAC1B,AAACa,AAAKZ,AACjB,AAACV,AAAKU;;;AACVA;;;AAEJ;;;;;;;;AAAA,AAAMc,AAOHf,AAAcC;AAPjB,AASE,AACE,AAASA;AAETA;;AAHF,AAKE,AAAAe,AAAK,AAACC,AAAKhB;AAAX,AAAA,AAAAe;AAAuB,AAAA,AAAMf;;AAA7Be;;;AAEA,AAACjB,AAAiBC,AAAcC;;AAPlC,AASE,AAAK,AAACiB,AAAQjB,AAAY,AAAAkB,AAAU,AAACP,AAAMX;AAE3C,AAACM,AAAiBP,AAAcC;;AAXlC,AAaE,AAACO,AAAYP;AAGb,AAACf,AAAoB,AAACmB,AAAQU,AAAUf,AAAeC;;AAhBzD,AAkBE,AAAWmB,AAAuBnB;AAElCA;;AApBF,AAuBE,AAAA,AAACoB","names":["instaparse.transform/map-preserving-meta","f","l","cljs.core/with-meta","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core/meta","instaparse.transform/merge-meta","obj","metamap","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","cljs.core/IWithMeta","instaparse.gll/merge-meta","instaparse.transform/enlive-transform","transform-map","parse-tree","transform","G__49561","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","instaparse.transform/hiccup-transform","cljs.core/sequential?","cljs.core/seq","temp__5718__auto__","G__49567","cljs.core/first","cljs.core/next","cljs.core.into.cljs$core$IFn$_invoke$arity$2","instaparse.transform/transform","and__4120__auto__","cljs.core/map?","cljs.core/vector?","cljs.core/Keyword","instaparse.gll/Failure","instaparse.util.throw_illegal_argument_exception.cljs$core$IFn$_invoke$arity$variadic"],"sourcesContent":["(ns instaparse.transform\r\n  \"Functions to transform parse trees\"\r\n  (:require [instaparse.gll]\r\n            [instaparse.util :refer [throw-illegal-argument-exception]]))\r\n\r\n(defn map-preserving-meta [f l]\r\n  (with-meta (map f l) (meta l)))\r\n\r\n(defn merge-meta\r\n  \"This variation of the merge-meta in gll does nothing if obj is not\r\nsomething that can have a metamap attached.\"\r\n  [obj metamap]\r\n  (if #?(:clj (instance? clojure.lang.IObj obj)\r\n         :cljs (satisfies? IWithMeta obj))\r\n    (instaparse.gll/merge-meta obj metamap)\r\n    obj))\r\n\r\n(defn- enlive-transform\r\n  [transform-map parse-tree]\r\n  (let [transform (transform-map (:tag parse-tree))]\r\n    (cond\r\n      transform\r\n      (merge-meta \r\n        (apply transform (map (partial enlive-transform transform-map)\r\n                              (:content parse-tree)))\r\n        (meta parse-tree))\r\n      (:tag parse-tree)\r\n      (assoc parse-tree :content (map (partial enlive-transform transform-map)\r\n                                      (:content parse-tree)))\r\n      :else\r\n      parse-tree)))\r\n\r\n(defn- hiccup-transform\r\n  [transform-map parse-tree]\r\n  (if (and (sequential? parse-tree) (seq parse-tree))\r\n    (if-let [transform (transform-map (first parse-tree))]\r\n      (merge-meta\r\n        (apply transform (map (partial hiccup-transform transform-map)\r\n                              (next parse-tree)))\r\n        (meta parse-tree))\r\n      (with-meta \r\n        (into [(first parse-tree)]\r\n              (map (partial hiccup-transform transform-map) \r\n                   (next parse-tree)))\r\n        (meta parse-tree)))\r\n    parse-tree))\r\n\r\n(defn transform\r\n  \"Takes a transform map and a parse tree (or seq of parse-trees).\r\n   A transform map is a mapping from tags to \r\n   functions that take a node's contents and return\r\n   a replacement for the node, i.e.,\r\n   {:node-tag (fn [child1 child2 ...] node-replacement),\r\n    :another-node-tag (fn [child1 child2 ...] node-replacement)}\"\r\n  [transform-map parse-tree]\r\n  ; Detect what kind of tree this is\r\n  (cond\r\n    (string? parse-tree)\r\n    ; This is a leaf of the tree that should pass through unchanged\r\n    parse-tree\r\n\r\n    (and (map? parse-tree) (:tag parse-tree))\r\n    ; This is an enlive tree-seq\r\n    (enlive-transform transform-map parse-tree)\r\n    \r\n    (and (vector? parse-tree) (keyword? (first parse-tree)))\r\n    ; This is a hiccup tree-seq\r\n    (hiccup-transform transform-map parse-tree)\r\n    \r\n    (sequential? parse-tree)\r\n    ; This is either a sequence of parse results, or a tree\r\n    ; with a hidden root tag.\r\n    (map-preserving-meta (partial transform transform-map) parse-tree)\r\n    \r\n    (instance? instaparse.gll.Failure parse-tree)\r\n    ; pass failures through unchanged\r\n    parse-tree\r\n    \r\n    :else\r\n    (throw-illegal-argument-exception\r\n      \"Invalid parse-tree, not recognized as either enlive or hiccup format.\")))\r\n"]}