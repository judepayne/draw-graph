{"version":3,"sources":["lib_draw_graph/processor.cljc"],"mappings":"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","names":["lib-draw-graph.processor/*data*","lib-draw-graph.processor/*options*","lib-draw-graph.processor/*list-sep*","lib-draw-graph.processor/*definition-marker*","lib-draw-graph.processor/split-list","e","clojure.string.split.cljs$core$IFn$_invoke$arity$3","lib-draw-graph.processor/split-def","s","lib-draw-graph.processor/third","coll","e36586","cljs.core.nth.cljs$core$IFn$_invoke$arity$2","js/Object","lib-draw-graph.processor/some-dims?","m","cljs.core/empty?","cljs.core/select-keys","iter__4523__auto__","s__36588","cljs.core/LazySeq","temp__5720__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__4521__auto__","size__4522__auto__","cljs.core/count","b__36590","cljs.core/chunk-buffer","i__36589","vec__36591","cljs.core._nth.cljs$core$IFn$_invoke$arity$2","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__36587","cljs.core/chunk-rest","vec__36594","cljs.core/first","cljs.core/cons","cljs.core/rest","k","v","lib-draw-graph.processor/maybe-paths","g","opts","subs","clojure.string.split.cljs$core$IFn$_invoke$arity$2","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","start-sub","end-sub","cljs.core/second","lib-draw-graph.preprocessor/paths","lib-draw-graph.util/err","lib-draw-graph.processor/maybe-filter","g'","lib-draw-graph.preprocessor/filter-graph","lib-draw-graph.processor/maybe-fix-ranks","and__4120__auto__","lib-draw-graph.preprocessor/fix-ranks","cljs.core.keyword.cljs$core$IFn$_invoke$arity$1","lib-draw-graph.processor/maybe-elide","lib-draw-graph.preprocessor/remove-levels","js/parseInt","lib-draw-graph.processor/add-attr-map","node-or-edge","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","acc","cur","cljs.core.apply.cljs$core$IFn$_invoke$arity$4","loom.attr/add-attr","cljs.core/vec","lib-draw-graph.processor/add-meta-map-to-edge","src","dst","loom.attr/add-attr-to-edges","var_args","G__36599","lib-draw-graph.processor/loom-graph","js/Error","parsed","lib_draw_graph.processor.loom_graph.cljs$core$IFn$_invoke$arity$2","cluster-on","gr0","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","loom.graph/digraph","p1__36597#","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core/PersistentVector","gr1","g''","gr2","p__36600","vec__36601","nd","attrs","cljs.core/some","gr3","lib-draw-graph.clustered/add-attr-to-cluster","gr4","p__36604","vec__36605","c","p","lib-draw-graph.clustered/add-cluster-parent","gr5","p__36608","vec__36609","c1","c2","lib-draw-graph.clustered/add-cluster-edge","lib-draw-graph.clustered/add-cluster-key","lib-draw-graph.processor/apply-filtering-operations","lib-draw-graph.clustered/edge-graph","or__4131__auto__","lib-draw-graph.preprocessor/filter-edge-graph","lib-draw-graph.clustered/clusters","lib-draw-graph.preprocessor/add-invisible-cluster-edges","loom.graph/edges","lib-draw-graph.processor/check-graph","lib-draw-graph.processor/not-blank","lib-draw-graph.processor/detect-format","e36613","cljs.core.subs.cljs$core$IFn$_invoke$arity$3","lib-draw-graph.processor/preprocess-graph","graph","lib-draw-graph.processor/postprocess-svg","svg","svg'","lib-draw-graph.postprocessor/optimize-clusters","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","lib-draw-graph.graph/first-label","svg''","font","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","clojure.string/replace","lib-draw-graph.processor/process-to-dot","in","lib_draw_graph.processor.loom_graph.cljs$core$IFn$_invoke$arity$1","lib-draw-graph.graph/process-graph","lib-draw-graph.processor/in->g","lib-draw-graph.parser/parse-csv-or-json","lib-draw-graph.processor/g->dot","lib-draw-graph.processor/process-to-svg","dot->svg","G__36615","G__36616","preproc-g","dot","cljs.core/chunk-first"],"sourcesContent":["(ns ^{:doc \"Process csv format to dot.\"\n      :author \"Jude Payne\"}\n  lib-draw-graph.processor\n  (:require [lib-draw-graph.graph           :as g]\n            [lib-draw-graph.parser          :as parser]\n            [loom.graph                     :as loom.graph]\n            [loom.attr                      :as loom.attr]\n            [clojure.string                 :as str]\n            [lib-draw-graph.clustered       :as clstr]\n            [lib-draw-graph.preprocessor    :as preprocessor]\n            [lib-draw-graph.postprocessor   :as postprocessor]\n            [lib-draw-graph.util            :as util]))\n\n\n;; Keys used in all JSON messages\n\n(def ^:dynamic *data* :data)  ;; json key where graph data is kept\n(def ^:dynamic *options* :display-options)   ;; where options are kept\n\n\n(def ^:dynamic *list-sep* #\",\")   ;; separator to split a list (e.g. edge) into pieces\n(def ^:dynamic *definition-marker* #\"#\") ;; marker for node/ cluster info\n\n\n(defn split-list [e] (str/split e *list-sep* 3))\n(defn split-def [s] (str/split s *definition-marker* -1))\n\n\n(defn- third\n  \"Returns third element of coll, or nil.\"\n  [coll]\n  (try (nth coll 2)\n       #?(:clj (catch Exception e nil)\n          :cljs (catch js/Object e nil))))\n\n\n(defn some-dims?\n  \"Returns true if some of the map entries are true\"\n  [m]\n  (not (empty? (select-keys m (for [[k v] m :when v] k)))))\n\n\n;; ------------\n;; pre-processing functions\n\n(defn maybe-paths [g opts]\n  (if (and (some? (:paths opts)) (string? (:paths opts)))\n    (let [subs (str/split (:paths opts) #\"\\|\")]\n      (if (= 2 (count subs))\n        (let [start-sub (first subs)\n              end-sub (second subs)]\n          (preprocessor/paths g start-sub end-sub))\n        (throw (util/err \"Error: Paths input cannot be parsed.\"))))\n    g))\n\n\n(defn maybe-filter [g opts]\n  (if  (some? (:filter-graph opts))\n    (let [g' (preprocessor/filter-graph g (:filter-graph opts))]\n      g')\n    g))\n\n\n(defn maybe-fix-ranks [g opts]\n  (if (and (some? (:cluster-on opts))\n           (= (:layout opts) \"dot\")\n           (:fix-ranks? opts))\n    (preprocessor/fix-ranks g (keyword (:cluster-on opts)))\n    g))\n\n\n(defn maybe-elide [g opts]\n  (if (some? (:elide opts))\n    (preprocessor/remove-levels g\n                                #?(:clj (Integer/parseInt (:elide opts))\n                                   :cljs (js/parseInt (:elide opts))))\n    g))\n\n;; -----------\n;; Construction of the graph\n\n(defn- add-attr-map\n  [g node-or-edge m]\n  (reduce\n   (fn [acc cur] (apply loom.attr/add-attr acc node-or-edge cur))\n   g (vec m)))\n\n\n(defn- add-meta-map-to-edge\n  [g src dst m]\n  (loom.attr/add-attr-to-edges g :meta m [[src dst]]))\n\n\n\n(defn loom-graph\n  ([parsed] (loom-graph parsed nil))\n  ([parsed cluster-on]\n   (let [;; construct the initial graph\n         gr0 (apply loom.graph/digraph (map #(vector (:src %) (:dst %)) (:edges parsed)))\n         ;; add edge attrs: style and meta\n         gr1 (reduce (fn [acc cur]\n                       (let [g' (if (:style cur)\n                                  (add-attr-map acc [(:src cur) (:dst cur)] (:style cur))\n                                  acc)\n                             g'' (if (:meta cur)\n                                   (add-meta-map-to-edge g' (:src cur) (:dst cur) (:meta cur))\n                                   g')]\n                         g''))\n                     gr0\n                     (:edges parsed))\n         ;; add node attributes\n         gr2 (reduce (fn [acc [nd attrs]]\n                       (add-attr-map acc nd attrs))\n                     gr1 (:nodes parsed))]\n     (if (and cluster-on\n              (some #{(keyword cluster-on)} (:header parsed))) ;; check to prevent stack-overflow\n       (let [;; add cluster styles\n             gr3 (reduce (fn [acc cur]\n                           (clstr/add-attr-to-cluster acc (first cur) :style (second cur)))\n                         gr2\n                         (:cluster-styles parsed))\n             \n             ;; add cluster parents\n             gr4 (reduce (fn [acc [c p]]\n                           (clstr/add-cluster-parent acc c p))\n                         gr3 (:cluster-parents parsed))\n             ;; add cluster edges\n             gr5 (reduce (fn [acc [c1 c2]]\n                           (-> acc\n                               (clstr/add-cluster-edge c1 c2)\n                               ;(preprocessor/add-stack (keyword cluster-on) [c1 c2])\n                               ;we'll add te invisible edges later, post filtering\n                               ))\n                         gr4\n                         (:cluster-edges parsed))]\n\n         (clstr/add-cluster-key gr5 cluster-on))\n       gr2))))\n\n\n(defn apply-filtering-operations\n  ;; a single place to apply all filtering and filter to the correct\n  ;; edge graph and add cluster edges at the end.\n  [g opts]\n  (let [g' (-> g\n               (maybe-paths opts)\n               (maybe-filter opts))]\n    (if (clstr/edge-graph g')\n      (let [g'' (if (or (-> opts :filter-graph) (-> opts :path))\n                  ;; the graph has been filtered. Need to rebuild the edge-graph\n                  (preprocessor/filter-edge-graph g' (clstr/clusters g'))\n                  g')]\n        (if (clstr/edge-graph g'')\n          (preprocessor/add-invisible-cluster-edges\n           g''\n           opts\n           (loom.graph/edges (clstr/edge-graph g'')))\n          g'' ;; doesn't have an edge-graph - just return it\n          ))\n      ;; doesn't have an edge-graph - just return it\n      g')))\n\n\n\n;; -----------\n;; public interface functions\n\n(defn check-graph\n  \"Runs various tests over a clustered graph and outputs a warning message.\"\n  [g]\n  (reduce\n   (fn [acc cur]\n     (str acc (cur g)))\n   \"\"\n   []))\n\n\n(defn- not-blank [s]\n  (if (or (= \"\" s) nil)\n    nil\n    s))\n\n\n(defn detect-format\n  \"detects the format of the data string.\"\n  [s]\n  (try\n    (cond\n      (= (subs s 0 1) \"{\")       :json\n      (= (subs s 0 2) \"h,\")      :csv\n      (= (subs s 0 5) \"graph\")   :dot\n      (= (subs s 0 7) \"digraph\") :dot\n      :else                      nil)\n    #?(:clj (catch Exception e nil)\n       :cljs (catch js/Error e nil))))\n\n\n(defn preprocess-graph [graph opts]\n  (-> graph\n      (apply-filtering-operations opts)\n      (maybe-elide opts)\n      (maybe-fix-ranks opts)))\n\n\n(defn postprocess-svg [graph opts svg]\n  (if (-> opts :post-process?)\n    (let [svg' (if (and (not-blank (-> opts :cluster-on))\n                        (some-dims? (-> opts :pp-clusters))\n                        (or  (= \"dot\" (-> opts :layout))))\n                 ;; do cluster optimization\n                 (postprocessor/optimize-clusters\n                  svg\n                  graph\n                  (partial g/first-label (-> opts :label))\n                  opts)\n                 ;; not a clustered graph. just return the svg\n                 svg)\n          svg'' (let [font (-> opts :pp-font)]\n                  (if (and (not= font \"\") (not (nil? font)))\n                    (clojure.string/replace (if (nil? svg') svg svg') \"Monospace\" font)\n                    svg'))]\n      svg'')\n    ;; just return the svg as post processing not required\n    svg))\n\n\n(defn process-to-dot [in]\n  (let [cluster-on (not-blank (-> in :display-options :cluster-on))\n        g (if cluster-on\n            (loom-graph (:data in) cluster-on)\n            (loom-graph (:data in)))]\n    (-> g\n        (preprocess-graph (:display-options in))\n        (g/process-graph (:display-options in)))))\n\n\n(defn in->g [in]\n  (let [cluster-on (not-blank (-> in :display-options :cluster-on))\n        parsed (parser/parse-csv-or-json\n                (:data in)\n                (keyword (:format-in in)))]\n   ; (println parsed)\n    (if cluster-on\n      (loom-graph parsed cluster-on)\n      (loom-graph parsed))))\n\n\n(defn g->dot [in g]\n  (-> g\n      (g/process-graph (:display-options in))))\n\n\n(defn process-to-svg [in dot->svg]\n  (case (:format-in in)\n\n    \"dot\" (dot->svg (:data in)) ;; we can't do any post-processing\n\n    (\"csv\" \"json\") (let [g (in->g in)\n                         opts (:display-options in)\n                         preproc-g (preprocess-graph g opts)\n                         dot (g/process-graph preproc-g opts)\n                         svg (dot->svg dot)]\n                     (postprocess-svg preproc-g opts svg))\n\n    (throw (util/err \"Error: only 'csv' or 'dot' are allowed input formats.\"))))\n\n\n"]}