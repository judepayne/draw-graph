{"version":3,"sources":["lib_draw_graph/processor.cljc"],"mappings":"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","names":["lib-draw-graph.processor/*data*","lib-draw-graph.processor/*options*","lib-draw-graph.processor/*list-sep*","lib-draw-graph.processor/*definition-marker*","lib-draw-graph.processor/split-list","e","clojure.string.split.cljs$core$IFn$_invoke$arity$3","lib-draw-graph.processor/split-def","s","lib-draw-graph.processor/third","coll","e36535","cljs.core.nth.cljs$core$IFn$_invoke$arity$2","js/Object","lib-draw-graph.processor/some-dims?","m","cljs.core/empty?","cljs.core/select-keys","iter__4523__auto__","s__36540","cljs.core/LazySeq","temp__5720__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__4521__auto__","size__4522__auto__","cljs.core/count","b__36542","cljs.core/chunk-buffer","i__36541","vec__36543","cljs.core._nth.cljs$core$IFn$_invoke$arity$2","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__36539","cljs.core/chunk-rest","vec__36546","cljs.core/first","cljs.core/cons","cljs.core/rest","k","v","lib-draw-graph.processor/maybe-paths","g","opts","subs","clojure.string.split.cljs$core$IFn$_invoke$arity$2","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","start-sub","end-sub","cljs.core/second","lib-draw-graph.preprocessor/paths","lib-draw-graph.util/err","lib-draw-graph.processor/maybe-filter","g'","lib-draw-graph.preprocessor/filter-graph","lib-draw-graph.processor/maybe-fix-ranks","and__4120__auto__","lib-draw-graph.preprocessor/fix-ranks","cljs.core.keyword.cljs$core$IFn$_invoke$arity$1","lib-draw-graph.processor/maybe-elide","lib-draw-graph.preprocessor/remove-levels","js/parseInt","lib-draw-graph.processor/add-attr-map","node-or-edge","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","acc","cur","cljs.core.apply.cljs$core$IFn$_invoke$arity$4","loom.attr/add-attr","cljs.core/vec","lib-draw-graph.processor/add-meta-map-to-edge","src","dst","loom.attr/add-attr-to-edges","var_args","G__36551","lib-draw-graph.processor/loom-graph","js/Error","lib_draw_graph.processor.loom_graph.cljs$core$IFn$_invoke$arity$2","cluster-on","parsed","lib-draw-graph.parser/parse-lines","clojure.string/split-lines","gr0","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","loom.graph/digraph","p1__36549#","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core/PersistentVector","gr1","g''","gr2","p__36552","vec__36553","nd","attrs","cljs.core/some","gr3","lib-draw-graph.clustered/add-attr-to-cluster","gr4","p__36557","vec__36558","c","p","lib-draw-graph.clustered/add-cluster-parent","gr5","p__36561","vec__36562","c1","c2","lib-draw-graph.clustered/add-cluster-edge","lib-draw-graph.clustered/add-cluster-key","lib-draw-graph.processor/apply-filtering-operations","lib-draw-graph.clustered/edge-graph","or__4131__auto__","lib-draw-graph.preprocessor/filter-edge-graph","lib-draw-graph.clustered/clusters","lib-draw-graph.preprocessor/add-invisible-cluster-edges","loom.graph/edges","lib-draw-graph.processor/check-graph","lib-draw-graph.processor/not-blank","lib-draw-graph.processor/preprocess-graph","graph","lib-draw-graph.processor/postprocess-svg","svg","svg'","lib-draw-graph.postprocessor/optimize-clusters","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","lib-draw-graph.graph/first-label","svg''","font","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","clojure.string/replace","lib-draw-graph.processor/process-to-dot","in","lib_draw_graph.processor.loom_graph.cljs$core$IFn$_invoke$arity$1","lib-draw-graph.graph/process-graph","lib-draw-graph.processor/csv->g","lib-draw-graph.processor/g->dot","lib-draw-graph.processor/process-to-svg","dot->svg","G__36566","G__36567","preproc-g","dot","cljs.core/chunk-first"],"sourcesContent":["(ns ^{:doc \"Process csv format to dot.\"\n      :author \"Jude Payne\"}\n  lib-draw-graph.processor\n  (:require [lib-draw-graph.graph           :as g]\n            [lib-draw-graph.parser          :as parser]\n            [loom.graph                     :as loom.graph]\n            [loom.attr                      :as loom.attr]\n            [clojure.string                 :as str]\n            [lib-draw-graph.clustered       :as clstr]\n            [lib-draw-graph.preprocessor    :as preprocessor]\n            [lib-draw-graph.postprocessor   :as postprocessor]\n            [lib-draw-graph.util            :as util]))\n\n\n;; Keys used in all JSON messages\n\n(def ^:dynamic *data* :data)  ;; json key where graph data is kept\n(def ^:dynamic *options* :display-options)   ;; where options are kept\n\n\n(def ^:dynamic *list-sep* #\",\")   ;; separator to split a list (e.g. edge) into pieces\n(def ^:dynamic *definition-marker* #\"#\") ;; marker for node/ cluster info\n\n\n(defn split-list [e] (str/split e *list-sep* 3))\n(defn split-def [s] (str/split s *definition-marker* -1))\n\n\n(defn- third\n  \"Returns third element of coll, or nil.\"\n  [coll]\n  (try (nth coll 2)\n       #?(:clj (catch Exception e nil)\n          :cljs (catch js/Object e nil))))\n\n\n(defn some-dims?\n  \"Returns true if some of the map entries are true\"\n  [m]\n  (not (empty? (select-keys m (for [[k v] m :when v] k)))))\n\n\n;; ------------\n;; pre-processing functions\n\n(defn maybe-paths [g opts]\n  (if (and (some? (:paths opts)) (string? (:paths opts)))\n    (let [subs (str/split (:paths opts) #\"\\|\")]\n      (if (= 2 (count subs))\n        (let [start-sub (first subs)\n              end-sub (second subs)]\n          (preprocessor/paths g start-sub end-sub))\n        (throw (util/err \"Error: Paths input cannot be parsed.\"))))\n    g))\n\n\n(defn maybe-filter [g opts]\n  (if  (some? (:filter-graph opts))\n    (let [g' (preprocessor/filter-graph g (:filter-graph opts))]\n      g')\n    g))\n\n\n(defn maybe-fix-ranks [g opts]\n  (if (and (some? (:cluster-on opts))\n           (= (:layout opts) \"dot\")\n           (:fix-ranks? opts))\n    (preprocessor/fix-ranks g (keyword (:cluster-on opts)))\n    g))\n\n\n(defn maybe-elide [g opts]\n  (if (some? (:elide opts))\n    (preprocessor/remove-levels g\n                                #?(:clj (Integer/parseInt (:elide opts))\n                                   :cljs (js/parseInt (:elide opts))))\n    g))\n\n;; -----------\n;; Construction of the graph\n\n(defn- add-attr-map\n  [g node-or-edge m]\n  (reduce\n   (fn [acc cur] (apply loom.attr/add-attr acc node-or-edge cur))\n   g (vec m)))\n\n\n(defn- add-meta-map-to-edge\n  [g src dst m]\n  (loom.attr/add-attr-to-edges g :meta m [[src dst]]))\n\n\n(defn loom-graph\n  ([s] (loom-graph s nil))\n  ([s cluster-on]\n   (let [parsed (parser/parse-lines (str/split-lines s))\n         gr0 (apply loom.graph/digraph (map #(vector (:src %) (:dst %)) (:edges parsed)))\n         ;; add edge attrs: style and meta\n         gr1 (reduce (fn [acc cur]\n                       (let [g' (if (:style cur)\n                                  (add-attr-map acc [(:src cur) (:dst cur)] (:style cur))\n                                  acc)\n                             g'' (if (:meta cur)\n                                   (add-meta-map-to-edge g' (:src cur) (:dst cur) (:meta cur))\n                                   g')]\n                         g''))\n                     gr0\n                     (:edges parsed))\n         ;; add node attributes\n         gr2 (reduce (fn [acc [nd attrs]]\n                       (add-attr-map acc nd attrs))\n                     gr1 (:node-styles parsed))]\n     (if (and cluster-on\n              (some #{(keyword cluster-on)} (:header parsed))) ;; check to prevent stack-overflow\n       (let [;; add cluster styles\n             gr3 (reduce (fn [acc cur]\n                           (clstr/add-attr-to-cluster acc (first cur) :style (second cur)))\n                         gr2\n                         (:cluster-styles parsed))\n             \n             ;; add cluster parents\n             gr4 (reduce (fn [acc [c p]]\n                           (clstr/add-cluster-parent acc c p))\n                         gr3 (:cluster-parents parsed))\n             ;; add cluster edges\n             gr5 (reduce (fn [acc [c1 c2]]\n                           (-> acc\n                               (clstr/add-cluster-edge c1 c2)\n                               ;(preprocessor/add-stack (keyword cluster-on) [c1 c2])\n                               ;we'll add te invisible edges later, post filtering\n                               ))\n                         gr4\n                         (:cluster-edges parsed))]\n\n         (clstr/add-cluster-key gr5 cluster-on))\n       gr2))))\n\n\n(defn apply-filtering-operations\n  ;; a single place to apply all filtering and filter to the correct\n  ;; edge graph and add cluster edges at the end.\n  [g opts]\n  (let [g' (-> g\n               (maybe-paths opts)\n               (maybe-filter opts))]\n    (if (clstr/edge-graph g')\n      (let [g'' (if (or (-> opts :filter-graph) (-> opts :path))\n                  ;; the graph has been filtered. Need to rebuild the edge-graph\n                  (preprocessor/filter-edge-graph g' (clstr/clusters g'))\n                  g')]\n        (if (clstr/edge-graph g'')\n          (preprocessor/add-invisible-cluster-edges\n           g''\n           opts\n           (loom.graph/edges (clstr/edge-graph g'')))\n          g'' ;; doesn't have an edge-graph - just return it\n          ))\n      ;; doesn't have an edge-graph - just return it\n      g')))\n\n\n;; -----------\n;; Tests\n\n\n\n\n;; -----------\n;; public interface functions\n\n(defn check-graph\n  \"Runs various tests over a clustered graph and outputs a warning message.\"\n  [g]\n  (reduce\n   (fn [acc cur]\n     (str acc (cur g)))\n   \"\"\n   []))\n\n\n(defn- not-blank [s]\n  (if (or (= \"\" s) nil)\n    nil\n    s))\n\n\n(defn preprocess-graph [graph opts]\n  (-> graph\n      (apply-filtering-operations opts)\n      (maybe-elide opts)\n      (maybe-fix-ranks opts)))\n\n\n(defn postprocess-svg [graph opts svg]\n  (if (-> opts :post-process?)\n    (let [svg' (if (and (not-blank (-> opts :cluster-on))\n                        (some-dims? (-> opts :pp-clusters))\n                        (= \"dot\" (-> opts :layout)))\n                 ;; do cluster optimization\n                 (postprocessor/optimize-clusters\n                  svg\n                  graph\n                  (partial g/first-label (-> opts :label))\n                  opts)\n                 ;; not a clustered graph. just return the svg\n                 svg)\n          svg'' (let [font (-> opts :pp-font)]\n                  (if (and (not= font \"\") (not (nil? font)))\n                    (clojure.string/replace (if (nil? svg') svg svg') \"Monospace\" font)\n                    svg'))]\n      svg'')\n    ;; just return the svg as post processing not required\n    svg))\n\n\n(defn process-to-dot [in]\n  (let [cluster-on (not-blank (-> in :display-options :cluster-on))\n        g (if cluster-on\n            (loom-graph (:data in) cluster-on)\n            (loom-graph (:data in)))]\n    (-> g\n        (preprocess-graph (:display-options in))\n        (g/process-graph (:display-options in)))))\n\n\n(defn csv->g [in]\n  (let [cluster-on (not-blank (-> in :display-options :cluster-on))]\n    (if cluster-on\n      (loom-graph (:data in) cluster-on)\n      (loom-graph (:data in)))))\n\n\n(defn g->dot [in g]\n  (-> g\n      (g/process-graph (:display-options in))))\n\n\n(defn process-to-svg [in dot->svg]\n  (case (:format-in in)\n\n    \"dot\" (dot->svg (:data in)) ;; we can't do any post-processing\n\n    \"csv\" (let [g (csv->g in)\n                opts (:display-options in)\n                preproc-g (preprocess-graph g opts)\n                dot (g/process-graph preproc-g opts)\n                svg (dot->svg dot)]\n            (postprocess-svg preproc-g opts svg))\n\n    (throw (util/err \"Error: only 'csv' or 'dot' are allowed input formats.\"))))\n\n"]}