{"version":3,"sources":["lib_draw_graph/processor.cljc"],"mappings":"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","names":["lib-draw-graph.processor/*data*","lib-draw-graph.processor/*options*","lib-draw-graph.processor/*list-sep*","lib-draw-graph.processor/*definition-marker*","lib-draw-graph.processor/split-list","e","clojure.string.split","lib-draw-graph.processor/split-def","s","lib-draw-graph.processor/third","coll","e37621","cljs.core.nth","js/Object","lib-draw-graph.processor/some-dims?","m","cljs.core/empty?","cljs.core/select-keys","iter__4582__auto__","s__37624","cljs.core/LazySeq","temp__5735__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__4580__auto__","size__4581__auto__","cljs.core/count","b__37626","cljs.core/chunk-buffer","i__37625","vec__37627","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__37623","cljs.core/chunk-rest","vec__37632","cljs.core/first","cljs.core/cons","cljs.core/rest","k","v","lib-draw-graph.processor/maybe-paths","g","opts","subs","cljs.core._EQ_","start-sub","end-sub","cljs.core/second","lib-draw-graph.preprocessor/paths","lib-draw-graph.util/err","lib-draw-graph.processor/maybe-filter","g'","lib-draw-graph.preprocessor/filter-graph","lib-draw-graph.processor/maybe-fix-ranks","lib-draw-graph.preprocessor/fix-ranks","cljs.core.keyword","lib-draw-graph.processor/maybe-elide","lib-draw-graph.preprocessor/remove-levels","js/parseInt","lib-draw-graph.processor/add-attr-map","node-or-edge","cljs.core.reduce","acc","cur","cljs.core.apply","loom.attr/add-attr","cljs.core/vec","lib-draw-graph.processor/add-meta-map-to-edge","src","dst","loom.attr/add-attr-to-edges","x__4487__auto__","m__4488__auto__","lib-draw-graph.processor/pop","goog/typeOf","m__4485__auto__","cljs.core/missing-protocol","lib-draw-graph.processor/peek","lib-draw-graph.processor/push","lib-draw-graph.processor/MultiStack","this","item","cljs.core/PROTOCOL_SENTINEL","cljs.core/Atom","cljs.core/deref","cljs.core.get","cljs.core.swap_BANG_","cljs.core/update-in","r","lib-draw-graph.processor/edge-attr-map","pe","cljs.core.merge","var_args","G__37638","lib-draw-graph.processor/loom-graph","js/Error","parsed","lib_draw_graph.processor.loom_graph","cluster-on","gr0","extra-loom.multigraph/multidigraph","p1__37636#","cljs.core.map","cljs.core/PersistentVector","gr1","p__37640","vec__37641","nd","attrs","and__4174__auto__","cljs.core/some","gr2","lib-draw-graph.clustered/add-attr-to-cluster","gr3","p__37645","vec__37646","c","p","lib-draw-graph.clustered/add-cluster-parent","gr4","p__37649","vec__37650","c1","c2","lib-draw-graph.clustered/add-cluster-edge","lib-draw-graph.clustered/add-cluster-key","lib-draw-graph.processor/apply-filtering-operations","lib-draw-graph.clustered/edge-graph","g''","or__4185__auto__","lib-draw-graph.preprocessor/filter-edge-graph","lib-draw-graph.clustered/clusters","lib-draw-graph.preprocessor/add-invisible-cluster-edges","loom.graph/edges","lib-draw-graph.processor/check-graph","lib-draw-graph.processor/not-blank","lib-draw-graph.processor/detect-format","e37653","cljs.core.subs","lib-draw-graph.processor/preprocess-graph","graph","lib-draw-graph.processor/postprocess-svg","svg","svg'","lib-draw-graph.postprocessor/optimize-clusters","cljs.core.partial","lib-draw-graph.graph/first-label","svg''","font","cljs.core.not_EQ_","clojure.string/replace","lib-draw-graph.processor/process-to-dot","in","lib-draw-graph.graph/process-graph","lib-draw-graph.processor/in->g","lib-draw-graph.parser/parse-csv-or-json","lib-draw-graph.processor/g->dot","lib-draw-graph.processor/process-to-svg","dot->svg","G__37654","G__37655","preproc-g","dot","cljs.core/chunk-first"],"sourcesContent":["(ns ^{:doc \"Process csv format to dot.\"\n      :author \"Jude Payne\"}\n  lib-draw-graph.processor\n  (:require [lib-draw-graph.graph           :as g]\n            [lib-draw-graph.parser          :as parser]\n            [loom.graph                     :as loom.graph]\n            [loom.attr                      :as loom.attr]\n            [extra-loom.multigraph          :as multigraph]\n            [clojure.string                 :as str]\n            [lib-draw-graph.clustered       :as clstr]\n            [lib-draw-graph.preprocessor    :as preprocessor]\n            [lib-draw-graph.postprocessor   :as postprocessor]\n            [lib-draw-graph.util            :as util])\n  (:refer-clojure :exclude [pop peek]))\n\n\n;; Keys used in all JSON messages\n\n(def ^:dynamic *data* :data)  ;; json key where graph data is kept\n(def ^:dynamic *options* :display-options)   ;; where options are kept\n\n\n(def ^:dynamic *list-sep* #\",\")   ;; separator to split a list (e.g. edge) into pieces\n(def ^:dynamic *definition-marker* #\"#\") ;; marker for node/ cluster info\n\n\n(defn split-list [e] (str/split e *list-sep* 3))\n(defn split-def [s] (str/split s *definition-marker* -1))\n\n\n(defn- third\n  \"Returns third element of coll, or nil.\"\n  [coll]\n  (try (nth coll 2)\n       #?(:clj (catch Exception e nil)\n          :cljs (catch js/Object e nil))))\n\n\n(defn some-dims?\n  \"Returns true if some of the map entries are true\"\n  [m]\n  (not (empty? (select-keys m (for [[k v] m :when v] k)))))\n\n\n;; ------------\n;; pre-processing functions\n\n(defn maybe-paths [g opts]\n  (if (and (some? (:paths opts)) (string? (:paths opts)))\n    (let [subs (str/split (:paths opts) #\"\\|\")]\n      (if (= 2 (count subs))\n        (let [start-sub (first subs)\n              end-sub (second subs)]\n          (preprocessor/paths g start-sub end-sub))\n        (throw (util/err \"Error: Paths input cannot be parsed.\"))))\n    g))\n\n\n(defn maybe-filter [g opts]\n  (if  (some? (:filter-graph opts))\n    (let [g' (preprocessor/filter-graph g (:filter-graph opts))]\n      g')\n    g))\n\n\n(defn maybe-fix-ranks [g opts]\n  (if (and (some? (:cluster-on opts))\n           (= (:layout opts) \"dot\")\n           (:fix-ranks? opts))\n    (preprocessor/fix-ranks g (keyword (:cluster-on opts)))\n    g))\n\n\n(defn maybe-elide [g opts]\n  (if (some? (:elide opts))\n    (preprocessor/remove-levels g\n                                #?(:clj (Integer/parseInt (:elide opts))\n                                   :cljs (js/parseInt (:elide opts))))\n    g))\n\n;; -----------\n;; Construction of the graph\n\n(defn- add-attr-map\n  [g node-or-edge m]\n  (reduce\n   (fn [acc cur] (apply loom.attr/add-attr acc node-or-edge cur))\n   g (vec m)))\n\n\n(defn- add-meta-map-to-edge\n  [g src dst m]\n  (loom.attr/add-attr-to-edges g :meta m [[src dst]]))\n\n\n;; For edges, I don't know which edge (its id) from parsed\n;; so I'll need to create a map of stacks of form\n;; { [src cur] <stack of edges> ... }\n;; then, when processing in loom-graph below, I find the edges at [src cur] in the map &\n;; pop the first edge, apply style and meta to it, rinse and repeat\n;; the stack will have to live inside an atom to preserve state and remove the \n;; need to pass around inside a reduction.\n\n(defprotocol MultiStack\n  (pop [this k] \"Pops the first item in the stack under key k.\")\n  (peek [this k] \"Peek at the first item in the stack under key k.\")\n  (push [this k item] \"Push the item onto the stack under key k.\"))\n\n\n(extend-type #?(:clj clojure.lang.Atom\n                :cljs Atom)\n  MultiStack\n  (pop [this k]\n    (let [item (first (get @this k))]\n      (swap! this update-in [k] rest)\n      item))\n  (peek [this k]\n    (first (get @this k)))\n  (push [this k item]\n    (swap! this update-in [k] (fn [r] (cons item r)))))\n\n\n(defn edge-attr-map\n  \"Makes an attr map from a parsed edge\"\n  [pe]\n  (merge (:style pe) (when (:meta pe) {:meta (:meta pe)})))\n\n\n(defn loom-graph\n  ([parsed] (loom-graph parsed nil))\n  ([parsed cluster-on]\n   (let [;; construct the initial graph\n         gr0 (apply multigraph/multidigraph (map #(vector (:src %) (:dst %) (edge-attr-map %))\n                                                 (:edges parsed)))\n         ;; add node attributes\n         gr1 (reduce (fn [acc [nd attrs]]\n                       (add-attr-map acc nd attrs))\n                     gr0 (:nodes parsed))]\n     (if (and cluster-on\n              (some #{(keyword cluster-on)} (:header parsed))) ;; check to prevent stack-overflow\n       (let [;; add cluster styles\n             gr2 (reduce (fn [acc cur]\n                           (clstr/add-attr-to-cluster acc (first cur) :style (second cur)))\n                         gr1\n                         (:cluster-styles parsed))\n             \n             ;; add cluster parents\n             gr3 (reduce (fn [acc [c p]]\n                           (clstr/add-cluster-parent acc c p))\n                         gr2 (:cluster-parents parsed))\n             ;; add cluster edges\n             gr4 (reduce (fn [acc [c1 c2]]\n                           (-> acc\n                               (clstr/add-cluster-edge c1 c2)\n                               ;(preprocessor/add-stack (keyword cluster-on) [c1 c2])\n                               ;we'll add te invisible edges later, post filtering\n                               ))\n                         gr3\n                         (:cluster-edges parsed))]\n\n         (clstr/add-cluster-key gr4 cluster-on))\n       gr1))))\n\n\n(defn apply-filtering-operations\n  ;; a single place to apply all filtering and filter to the correct\n  ;; edge graph and add cluster edges at the end.\n  [g opts]\n  (let [g' (-> g\n               (maybe-paths opts)\n               (maybe-filter opts))]\n    (if (clstr/edge-graph g')\n      (let [g'' (if (or (-> opts :filter-graph) (-> opts :path))\n                  ;; the graph has been filtered. Need to rebuild the edge-graph\n                  (preprocessor/filter-edge-graph g' (clstr/clusters g'))\n                  g')]\n        (if (clstr/edge-graph g'')\n          (preprocessor/add-invisible-cluster-edges\n           g''\n           opts\n           (loom.graph/edges (clstr/edge-graph g'')))\n          g'' ;; doesn't have an edge-graph - just return it\n          ))\n      ;; doesn't have an edge-graph - just return it\n      g')))\n\n\n\n;; -----------\n;; public interface functions\n\n(defn check-graph\n  \"Runs various tests over a clustered graph and outputs a warning message.\"\n  [g]\n  (reduce\n   (fn [acc cur]\n     (str acc (cur g)))\n   \"\"\n   []))\n\n\n(defn- not-blank [s]\n  (if (or (= \"\" s) nil)\n    nil\n    s))\n\n\n(defn detect-format\n  \"detects the format of the data string.\"\n  [s]\n  (try\n    (cond\n      (= (subs s 0 1) \"{\")       :json\n      (= (subs s 0 2) \"h,\")      :csv\n      (= (subs s 0 5) \"graph\")   :dot\n      (= (subs s 0 7) \"digraph\") :dot\n      :else                      nil)\n    #?(:clj (catch Exception e nil)\n       :cljs (catch js/Error e nil))))\n\n\n(defn preprocess-graph [graph opts]\n  (-> graph\n      (apply-filtering-operations opts)\n      (maybe-elide opts)\n      (maybe-fix-ranks opts)))\n\n\n(defn postprocess-svg [graph opts svg]\n  (if (-> opts :post-process?)\n    (let [svg' (if (and (not-blank (-> opts :cluster-on))\n                        (some-dims? (-> opts :pp-clusters))\n                        (or  (= \"dot\" (-> opts :layout))))\n                 ;; do cluster optimization\n                 (postprocessor/optimize-clusters\n                  svg\n                  graph\n                  (partial g/first-label (-> opts :label))\n                  opts)\n                 ;; not a clustered graph. just return the svg\n                 svg)\n          svg'' (let [font (-> opts :pp-font)]\n                  (if (and (not= font \"\") (not (nil? font)))\n                    (clojure.string/replace (if (nil? svg') svg svg') \"Monospace\" font)\n                    svg'))]\n      svg'')\n    ;; just return the svg as post processing not required\n    svg))\n\n\n(defn process-to-dot [in]\n  (let [cluster-on (not-blank (-> in :display-options :cluster-on))\n        g (if cluster-on\n            (loom-graph (:data in) cluster-on)\n            (loom-graph (:data in)))]\n    (-> g\n        (preprocess-graph (:display-options in))\n        (g/process-graph (:display-options in)))))\n\n\n(defn in->g [in]\n  (let [cluster-on (not-blank (-> in :display-options :cluster-on))\n        parsed (parser/parse-csv-or-json\n                (:data in)\n                (keyword (:format-in in)))]\n   ; (println parsed)\n    (if cluster-on\n      (loom-graph parsed cluster-on)\n      (loom-graph parsed))))\n\n\n(defn g->dot [in g]\n  (-> g\n      (g/process-graph (:display-options in))))\n\n\n(defn process-to-svg [in dot->svg]\n  (case (:format-in in)\n\n    \"dot\" (dot->svg (:data in)) ;; we can't do any post-processing\n\n    (\"csv\" \"json\") (let [g (in->g in)\n                         opts (:display-options in)\n                         preproc-g (preprocess-graph g opts)\n                         dot (g/process-graph preproc-g opts)\n                         svg (dot->svg dot)]\n                     (postprocess-svg preproc-g opts svg))\n\n    (throw (util/err \"Error: only 'csv' or 'dot' are allowed input formats.\"))))\n\n\n"]}