{"version":3,"sources":["instaparse/print.cljc"],"mappings":"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","names":["instaparse.print/paren-for-tags","tag-set","hidden?","parser","cljs.core/not","G__52013","instaparse.print/combinators->str","instaparse.print/paren-for-compound","cljs.core.partial","instaparse.print/regexp-replace","s","G__52017","instaparse.print/regexp->str","r","clojure.string/replace","cljs.core.subs","instaparse.print/number->hex-padded","n","p__52022","map__52023","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","instaparse.print/char-range->str","lo","hi","cljs.core._EQ_","var_args","G__52028","js/Error","p__52029","map__52030","p","instaparse.print.combinators__GT_str","parser1","parser2","parsers","tag","G__52034","cljs.core/Keyword","cljs.core.not_EQ_","clojure.string.join","cljs.core.map","sb__4720__auto__","goog.string/StringBuffer","*print-newline*-orig-val__52035","cljs.core/*print-newline*","*print-fn*-orig-val__52036","cljs.core/*print-fn*","*print-newline*-temp-val__52037","*print-fn*-temp-val__52038","x__4721__auto__","cljs.core.pr","*print-newline*-orig-val__52039","*print-fn*-orig-val__52040","*print-newline*-temp-val__52041","*print-fn*-temp-val__52042","instaparse.print/rule->str","non-terminal","cljs.core/name","p__52045","map__52047","instaparse.print/Parser->str","grammar","start","cljs.core/cons","iter__4582__auto__","s__52051","cljs.core/LazySeq","temp__5735__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__4580__auto__","size__4581__auto__","cljs.core/count","b__52053","cljs.core/chunk-buffer","i__52052","vec__52054","cljs.core/-nth","cljs.core.nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__52050","cljs.core/chunk-rest","vec__52060","cljs.core/first","cljs.core/rest","cljs.core/chunk-first"],"sourcesContent":["(ns instaparse.print\r\n  \"Facilities for taking parsers and grammars, and converting them to strings.\r\n   Used for pretty-printing.\"\r\n  (:require [clojure.string :as str]))\r\n\r\n(declare combinators->str) ; mutual recursion\r\n\r\n(defn paren-for-tags [tag-set hidden? parser]\r\n  (if (and (not hidden?) (tag-set (parser :tag)))\r\n    (str \"(\" (combinators->str parser false) \")\")\r\n    (combinators->str parser false)))\r\n\r\n(def paren-for-compound \r\n  (partial paren-for-tags #{:alt :ord :cat}))\r\n\r\n(defn regexp-replace\r\n  \"Replaces whitespace characters with escape sequences for better printing\" \r\n  [s]\r\n  (case s\r\n    \"\\n\" \"\\\\n\"\r\n    \"\\b\" \"\\\\b\"\r\n    \"\\f\" \"\\\\f\"\r\n    \"\\r\" \"\\\\r\"\r\n    \"\\t\" \"\\\\t\"\r\n    s)) \r\n\r\n(defn regexp->str [r]\r\n  (str/replace \r\n    (str \"#\\\"\"\r\n         #?(:clj (str r)\r\n            :cljs (subs (.-source r) 1))\r\n         \"\\\"\")\r\n    #\"[\\s]\" regexp-replace))\r\n\r\n#?(:clj\r\n   (defn char-range->str [{:keys [lo hi]}]\r\n     (if (= lo hi)\r\n       (format \"%%x%04x\" lo)\r\n       (format \"%%x%04x-%04x\" lo hi)))\r\n\r\n   :cljs\r\n   (do\r\n     (defn number->hex-padded [n]\r\n       (if (<= n 0xFFF)\r\n         (.substr (str \"0000\" (.toString n 16)) -4)\r\n         (.toString n 16)))\r\n\r\n     (defn char-range->str [{:keys [lo hi]}]\r\n       (if (= lo hi)\r\n         (str \"%x\" (number->hex-padded lo))\r\n         (str \"%x\" (number->hex-padded lo) \"-\" (number->hex-padded hi))))))\r\n\r\n(defn combinators->str\r\n  \"Stringifies a parser built from combinators\"\r\n  ([p] (combinators->str p false))\r\n  ([{:keys [parser parser1 parser2 parsers tag] :as p} hidden?]\r\n    (if (and (not hidden?) (:hide p))\r\n      (str \\< (combinators->str p true) \\>)\r\n      (case tag\r\n        :epsilon \"\\u03b5\"\r\n        :opt (str (paren-for-compound hidden? parser) \"?\")\r\n        :plus (str (paren-for-compound hidden? parser) \"+\")\r\n        :star (str (paren-for-compound hidden? parser) \"*\")\r\n        :rep (if (not= (:min p) (:max p))\r\n               (str (paren-for-compound hidden? parser) \\{ \r\n                    (:min p) \\, (:max p) \\})\r\n               (str (paren-for-compound hidden? parser) \\{ \r\n                    (:min p)\\}))\r\n        :alt (str/join \" | \" (map (partial paren-for-tags #{:ord} hidden?) parsers))\r\n        :ord (str (paren-for-tags #{:alt} hidden? parser1)\r\n                  \" / \"\r\n                  (paren-for-tags #{:alt} hidden? parser2))\r\n        :cat (str/join \" \" (map (partial paren-for-tags #{:alt :ord} hidden?) parsers))\r\n        :string (with-out-str (pr (:string p)))\r\n        :string-ci (with-out-str (pr (:string p)))\r\n        :char (char-range->str p)\r\n        :regexp (regexp->str (:regexp p))\r\n        :nt (subs (str (:keyword p)) 1)\r\n        :look (str \"&\" (paren-for-compound hidden? parser))\r\n        :neg (str \"!\" (paren-for-compound hidden? parser))))))\r\n  \r\n(defn rule->str\r\n  \"Takes a non-terminal symbol and a parser built from combinators,\r\n   and returns a string for the rule.\"\r\n  [non-terminal parser]\r\n  (if (= (-> parser :red :reduction-type) :raw)\r\n    (str \\< (name non-terminal) \\> \r\n         \" = \" \r\n         (combinators->str parser))\r\n    (str (name non-terminal)\r\n         \" = \" \r\n         (combinators->str parser))))\r\n\r\n(defn Parser->str\r\n  \"Takes a Parser object, i.e., something with a grammar map and a start \r\n   production keyword, and stringifies it.\" \r\n  [{grammar :grammar start :start-production}]\r\n  (str/join \\newline\r\n            (cons\r\n              ; Put starting production first\r\n              (rule->str start (grammar start))\r\n              ; Then the others\r\n              (for [[non-terminal parser] grammar\r\n                    :when (not= non-terminal start)]\r\n                (rule->str non-terminal parser)))))\r\n"]}