{"version":3,"sources":["promesa/impl/promise.cljc"],"mappings":"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","names":["promesa.impl.promise/Promise","js/Promise.noConflict","cljs.core/PROTOCOL_SENTINEL","it","cb","p1__28550#","p1__28551#","p1__28552#","goog.object/set","promesa.impl.proto/IPromise","promesa.impl.proto/-map","promesa.impl.proto/-bind","promesa.impl.proto/-catch","promesa.impl.promise/resolved","v","promesa.impl.promise/rejected","promesa.impl.proto/IPromiseFactory","promesa.impl.proto/-promise","func","p","js/Error","e","promesa.impl.promise/promise->str","promesa.impl.proto/-pending?","promesa.impl.proto/-rejected?","promesa.impl.proto/-extract","writer","opts","cljs.core/-write"],"sourcesContent":[";; Copyright (c) 2015-2016 Andrey Antukh <niwi@niwi.nz>\n;; All rights reserved.\n;;\n;; Redistribution and use in source and binary forms, with or without\n;; modification, are permitted provided that the following conditions\n;; are met:\n;;\n;; 1. Redistributions of source code must retain the above copyright\n;;    notice, this list of conditions and the following disclaimer.\n;; 2. Redistributions in binary form must reproduce the above copyright\n;;    notice, this list of conditions and the following disclaimer in the\n;;    documentation and/or other materials provided with the distribution.\n;;\n;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n;; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n;; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n;; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n;; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n;; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n;; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n(ns promesa.impl.promise\n  (:require #?(:cljs [org.bluebird])\n            [promesa.impl.proto :as pt])\n  #?(:clj (:import java.util.concurrent.CompletableFuture\n                   java.util.concurrent.CompletionStage\n                   java.util.concurrent.TimeoutException\n                   java.util.concurrent.ExecutionException\n                   java.util.concurrent.CompletionException\n                   java.util.concurrent.Executor\n                   java.util.concurrent.Executors\n                   java.util.concurrent.ForkJoinPool\n                   java.util.function.Function\n                   java.util.function.Supplier)))\n\n;; --- Global Constants\n\n#?(:cljs\n   (def ^:const Promise (js/Promise.noConflict)))\n\n#?(:cljs\n   (.config Promise #js {:cancellation true\n                         :warnings false}))\n\n#?(:clj\n   (def ^:redef +executor+\n     (ForkJoinPool/commonPool)))\n\n;; --- Promise Impl\n\n#?(:cljs\n   (extend-type Promise\n     pt/ICancellable\n     (-cancel [it]\n       (.cancel it))\n     (-cancelled? [it]\n       (.isCancelled it))\n\n     pt/IPromise\n     (-map [it cb]\n       (.then it #(cb %)))\n     (-bind [it cb]\n       (.then it #(cb %)))\n     (-catch [it cb]\n       (.catch it #(cb %)))\n\n     pt/IState\n     (-extract [it]\n       (if (.isRejected it)\n         (.reason it)\n         (.value it)))\n     (-resolved? [it]\n       (.isFulfilled it))\n     (-rejected? [it]\n       (.isRejected it))\n     (-pending? [it]\n       (.isPending it))))\n\n(declare resolved)\n\n#?(:cljs\n   (extend-type default\n     pt/IPromise\n     (-map [it cb]\n       (pt/-map (resolved it) cb))\n     (-bind [it cb]\n       (pt/-bind (resolved it) cb))\n     (-catch [it cb]\n       (pt/-catch (resolved it) cb))))\n\n#?(:clj\n   (extend-type CompletableFuture\n     pt/ICancellable\n     (-cancel [it]\n       (.cancel it true))\n     (-cancelled? [it]\n       (.isCancelled it))\n\n     pt/IPromise\n     (-map [it cb]\n       (let [binds (clojure.lang.Var/getThreadBindingFrame)\n             func (reify Function\n                    (apply [_ v]\n                      (clojure.lang.Var/resetThreadBindingFrame binds)\n                      (cb v)))]\n         (.thenApplyAsync it ^Function func ^Executor +executor+)))\n\n     (-bind [it cb]\n       (let [binds (clojure.lang.Var/getThreadBindingFrame)\n             func (reify Function\n                    (apply [_ v]\n                      (clojure.lang.Var/resetThreadBindingFrame binds)\n                      (cb v)))]\n         (.thenComposeAsync it ^Function func ^Executor +executor+)))\n\n     (-catch [it cb]\n       (let [binds (clojure.lang.Var/getThreadBindingFrame)\n             func (reify Function\n                    (apply [_ e]\n                      (clojure.lang.Var/resetThreadBindingFrame binds)\n                      (if (instance? CompletionException e)\n                        (cb (.getCause ^Exception e))\n                        (cb e))))]\n         (.exceptionally it ^Function func)))\n\n     pt/IState\n     (-extract [it]\n       (try\n         (.getNow it nil)\n         (catch ExecutionException e\n           (.getCause e))\n         (catch CompletionException e\n           (.getCause e))))\n\n     (-resolved? [it]\n       (and (not (.isCompletedExceptionally it))\n            (not (.isCancelled it))\n            (.isDone it)))\n\n     (-rejected? [it]\n       (.isCompletedExceptionally it))\n\n     (-pending? [it]\n       (and (not (.isCompletedExceptionally it))\n            (not (.isCancelled it))\n            (not (.isDone it))))))\n\n;; --- Promise Factory Impl\n\n(defn resolved\n  [v]\n  #?(:cljs (.resolve Promise v)\n     :clj (let [p (CompletableFuture.)]\n            (.complete p v)\n            p)))\n\n(defn rejected\n  [v]\n  #?(:cljs (.reject Promise v)\n     :clj (let [p (CompletableFuture.)]\n            (.completeExceptionally p v)\n            p)))\n\n#?(:clj\n   (extend-protocol pt/IPromiseFactory\n     clojure.lang.Fn\n     (-promise [func]\n       (let [p (CompletableFuture.)\n             reject #(.completeExceptionally p %)\n             resolve #(.complete p %)]\n         (try\n           (func resolve reject)\n           (catch Throwable e\n             (reject e)))\n         p))\n\n     Throwable\n     (-promise [e]\n       (rejected e))\n\n     CompletionStage\n     (-promise [cs] cs)\n\n     Object\n     (-promise [v]\n       (resolved v))\n\n     nil\n     (-promise [v]\n       (resolved v)))\n\n   :cljs\n   (extend-protocol pt/IPromiseFactory\n     function\n     (-promise [func]\n       (Promise. func))\n\n     Promise\n     (-promise [p] p)\n\n     js/Error\n     (-promise [e]\n       (rejected e))\n\n     object\n     (-promise [v]\n       (resolved v))\n\n     number\n     (-promise [v]\n       (resolved v))\n\n     boolean\n     (-promise [v]\n       (resolved v))\n\n     string\n     (-promise [v]\n       (resolved v))\n\n     nil\n     (-promise [v]\n       (resolved v))))\n\n;; --- Pretty printing\n\n(defn promise->str\n  [p]\n  (str \"#<Promise[\"\n       (cond\n         (pt/-pending? p) \"~\"\n         (pt/-rejected? p) (str \"error=\" (pt/-extract p))\n         :else (str \"value=\" (pt/-extract p)))\n       \"]>\"))\n\n#?(:clj\n   (defmethod print-method java.util.concurrent.CompletionStage\n     [p ^java.io.Writer writer]\n     (.write writer ^String (promise->str p)))\n   :cljs\n   (extend-type Promise\n     IPrintWithWriter\n     (-pr-writer [p writer opts]\n       (-write writer (promise->str p)))))\n"]}