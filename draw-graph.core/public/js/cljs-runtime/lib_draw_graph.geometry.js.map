{"version":3,"sources":["lib_draw_graph/geometry.cljc"],"mappings":";;AAKA;;;;AAAA,AAAMA,AAGHC,AAAIC,AAAGC;AAHV,AAIE,AAAK,AAAG,AAAA,AAAID,AAAI,AAAA,AAAG,AAAA,AAAIC,AAAI,AAAA,AAAIA,AAAIF,AAC9B,AAAG,AAAA,AAAG,AAAA,AAAIC,AAAI,AAAA,AAAIA,AAAID,AAAK,AAAA,AAAIE,AAC/B,AAAG,AAAA,AAAID,AAAI,AAAA,AAAG,AAAA,AAAIC,AAAI,AAAA,AAAIA,AAAIF,AAC9B,AAAG,AAAA,AAAG,AAAA,AAAIC,AAAI,AAAA,AAAIA,AAAID,AAAK,AAAA,AAAIE;;AAGtC;;;AAAA,AAAMC,AAEHF,AAAGG;AAFN,AAGE,AAAK,AAAI,AAAA,AAAIA,AAAM,AAAA,AAAIH,AAClB,AAAI,AAAA,AAAIG,AAAM,AAAA,AAAIH,AAClB,AAAI,AAAG,AAAA,AAAIG,AAAG,AAAA,AAAIA,AAAI,AAAG,AAAA,AAAIH,AAAI,AAAA,AAAIA,AACrC,AAAI,AAAG,AAAA,AAAIG,AAAG,AAAA,AAAIA,AAAI,AAAG,AAAA,AAAIH,AAAI,AAAA,AAAIA;;AAG5C;;;;;AAAA,AAAMI,AAIHL,AAAIM;AAJP,AAKE,AAAI,AAASN;AAAK,AAAAO,AAAA,AAAA,AAAA,AAAA,AAAA,AAAgBP,AAAOA,AAAOA,AAAOA;AAArCQ,AAA0CF;AAA1C,AAAA,AAAAC,AAAAC,AAAAD,AAAAC,AAACH,AAAAA,AAAAA;;AACf,AAAA,AAAA,AAAA,AAAA,AAACI,AAAMH,AACG,AAAG,AAAA,AAAIA,AAAM,AAAA,AAAIN,AACjB,AAAG,AAAA,AAAIM,AAAM,AAAA,AAAIN,AACjB,AAAA,AAAG,AAAA,AAAIM,AAAM,AAAA,AAAIN,AAAK,AAAA,AAAIA,AAC1B,AAAA,AAAG,AAAA,AAAIM,AAAM,AAAA,AAAIN,AAAK,AAAA,AAAIA;;;AAG1C;;;AAAA,AAAMU,AAEHT,AAAGC;AAFN,AAGE,AAAI,AAAG,AAAA,AAAIA,AAAI,AAAA,AAAID,AACf,AAAG,AAAA,AAAIC,AAAI,AAAA,AAAID,AACf,AAAG,AAAA,AAAIC,AAAI,AAAA,AAAID,AACf,AAAG,AAAA,AAAIC,AAAI,AAAA,AAAID;;AAGrB,AAAKU,AAAK,AAAKP;AAAL,AAAQ,AAAG,AAAA,AAAIA,AAAG,AAAA,AAAIA","names":["lib-draw-graph.geometry/overlaps?","sep","m1","m2","lib-draw-graph.geometry/inside?","m","lib-draw-graph.geometry/inner-rect","rect","G__36076","G__36077","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","lib-draw-graph.geometry/bigger?","lib-draw-graph.geometry/area"],"sourcesContent":["(ns ^{:doc \"Facilities for working with geometric shapes.\"\n      :author \"Jude Payne\"}\n    lib-draw-graph.geometry)\n\n\n(defn overlaps?\n  \"Returns true if m1 and m2 are in collision with each other.\n   sep is a single distance to be taken into consideration.\"\n  [sep m1 m2]\n  (and (< (:x m1) (+ (:x m2) (:w m2) sep))\n       (> (+ (:x m1) (:w m1) sep) (:x m2))\n       (< (:y m1) (+ (:y m2) (:h m2) sep))\n       (> (+ (:y m1) (:h m1) sep) (:y m2))))\n\n\n(defn inside?\n  \"Returns true if m is completely inside m1.\"\n  [m1 m]\n  (and (>= (:x m) (+ (:x m1)))\n       (>= (:y m) (+ (:y m1)))\n       (<= (+ (:x m) (:w m)) (+ (:x m1) (:w m1)))\n       (<= (+ (:y m) (:h m)) (+ (:y m1) (:h m1)))))\n\n\n(defn inner-rect\n  \"Returns rect where the boundary is shifted inwards by the sep (separation).\n   sep is either a single integer or is a map of individual :l :r :t :b\n   (left right top bottom) separation distances that should used in the shift.\"\n  [sep rect]\n  (if (number? sep) (inner-rect {:l sep :r sep :t sep :b sep} rect)\n      (assoc rect\n             :x (+ (:x rect) (:l sep))\n             :y (+ (:y rect) (:t sep))\n             :w (- (:w rect) (:r sep) (:l sep))\n             :h (- (:h rect) (:b sep) (:t sep)))))\n\n\n(defn bigger?\n  \"Returns true if m2 has grown from m1\"\n  [m1 m2]\n  (or (< (:x m2) (:x m1))\n      (< (:y m2) (:y m1))\n      (> (:w m2) (:w m1))\n      (> (:h m2) (:h m1))))\n\n\n(def area (fn [m] (* (:w m) (:h m))))\n\n\n\n"]}