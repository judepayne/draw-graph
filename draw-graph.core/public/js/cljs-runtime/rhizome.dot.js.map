{"version":3,"sources":["rhizome/dot.cljc"],"mappings":"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","names":["rhizome.dot/escapable-characters","rhizome.dot/escape-string","s","p1__51477#","p2__51478#","cljs.core.reduce","clojure.string/replace","rhizome.dot/default-options","rhizome.dot/default-node-options","rhizome.dot/default-edge-options","rhizome.dot/option-translations","rhizome.dot/translate-options","m","cljs.core.map","p__51488","vec__51489","cljs.core.nth","k","v","temp__5733__auto__","vec__51495","k*","f","cljs.core/contains?","cljs.core.remove","cljs.core/nil?","cljs.core.into","rhizome.dot/->literal","rhizome.dot/literal?","x","cljs.core/meta","rhizome.dot/unwrap-literal","cljs.core/first","rhizome.dot/format-options-value","v-str","clojure.string/starts-with?","cljs.core/Keyword","cljs.core/name","cljs.core/coll?","cljs.core.interpose","cljs.core.apply","cljs.core/str","rhizome.dot/format-label","label","cljs.core/sequential?","p1__51516#","cljs.core.pr_str","rhizome.dot/format-options","separator","p1__51521#","cljs.core.update_in","cljs.core.comp","cljs.core/second","p__51526","vec__51527","p__51532","map__51533","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","cljs.core.get","rhizome.dot/format-edge","src","dst","directed?","options","p1__51531#","or__4185__auto__","cljs.core.dissoc","p__51541","map__51542","rhizome.dot/format-node","id","shape","cljs.core.assoc","rhizome.dot/format-rank","ids","cljs.core.concat","rhizome.dot/*node->id*","rhizome.dot/*cluster->id*","rhizome.dot/node->id","n","rhizome.dot/cluster->id","rhizome.dot/clust->nds","nodes","cljs.core/reduce-kv","separated","cljs.core/zipmap","cljs.core.repeat","cljs.core.merge_with","clojure.set/union","cljs.core/group-by","var_args","args__4795__auto__","len__4789__auto__","i__4790__auto__","argseq__4796__auto__","cljs.core/IndexedSeq","rhizome.dot/graph->dot","p__51576","map__51577","seq51570","G__51572","cljs.core/next","G__51573","self__4776__auto__","adjacent","vertical?","node->descriptor","edge->descriptor","cluster->parent","node->clusters","cluster->descriptor","cluster->ranks","cljs.core/constantly","graph-descriptor","*node->id*-orig-val__51582","*cluster->id*-orig-val__51583","*node->id*-temp-val__51584","*cluster->id*-temp-val__51585","cljs.core/memoize","_","cljs.core.gensym","current-cluster","subgraph?","cljs.core/boolean","cluster->nodes","cluster?","node?","cljs.core/set","ranks","edge-options","node-options","cljs.core.merge","p1__51555#","p1__51556#","p1__51557#","p1__51560#","p1__51561#","r","cljs.core.mapv","cljs.core/keys","p1__51562#","cljs.core.not_EQ_","p1__51563#","cljs.core/concat","cljs.core.mapcat","node","cljs.core/vector","p1__51564#","p__51595","vec__51596","vec__51599","a","type","b","p1__51565#","descriptor","format","cljs.core._EQ_","cljs.core/vector?"],"sourcesContent":["(ns rhizome.dot\n  (:require [clojure.string :as str]\n            [clojure.set :as set]))\n\n;;;\n\n(def ^:private escapable-characters \"\\\\|{}\\\"\")\n\n(defn- escape-string\n  \"Escape characters that are significant for the dot format.\"\n  [s]\n  (reduce\n    #(str/replace %1 (str %2) (str \"\\\\\" %2))\n    s\n    escapable-characters))\n\n;;;\n\n(def ^:private default-options\n  {:dpi 100})\n\n(def ^:private default-node-options\n  {})\n\n(def ^:private default-edge-options\n  {})\n\n;;;\n\n(def ^:private option-translations\n  {:vertical? [:rankdir {true :TP, false :LR}]})\n\n(defn translate-options [m]\n  (->> m\n    (map\n      (fn [[k v]]\n        (if-let [[k* f] (option-translations k)]\n          (when-not (contains? m k*)\n            [k* (f v)])\n          [k v])))\n    (remove nil?)\n    (into {})))\n\n;;;\n\n(defn ->literal [s]\n  ^::literal [s])\n\n(defn literal? [x]\n  (-> x meta ::literal))\n\n(defn unwrap-literal [x]\n  (if (literal? x)\n    (first x)\n    x))\n\n;;;\n\n\n\n(defn- format-options-value [v]\n  (let [v-str (str v)]\n    (cond\n      ;; added first condition to handle html like labels which don't\n      ;; work if wrapped in quotes\n      (str/starts-with? v-str \"<<\") v-str\n      (string? v) (str \\\" (escape-string v) \\\")\n      (keyword? v) (name v)\n      (coll? v) (if (literal? v)\n                  (str \"\\\"\" (unwrap-literal v) \"\\\"\")\n                  (str \"\\\"\"\n                       (->> v\n                            (map format-options-value)\n                            (interpose \",\")\n                            (apply str))\n                       \"\\\"\"))\n      :else (str v))))\n\n(defn format-label [label]\n  (cond\n    (sequential? label)\n    (->> label\n      (map #(str \"{ \" (-> % format-label unwrap-literal) \" }\"))\n      (interpose \" | \")\n      (apply str)\n      ->literal)\n\n    (string? label)\n    label\n\n    (nil? label)\n    \"\"\n\n    :else\n    (pr-str label)))\n\n(defn- format-options [m separator]\n  (->>\n    (update-in m [:label] #(when % (format-label %)))\n    (remove (comp nil? second))\n    (map\n      (fn [[k v]]\n        (str (name k) \"=\" (format-options-value v))))\n    (interpose separator)\n    (apply str)))\n\n(defn- format-edge [src dst {:keys [directed?] :as options}]\n  (let [options (update-in options [:label] #(or % \"\"))]\n    (str src\n      (if directed?\n        \" -> \"\n        \" -- \")\n      dst\n      \"[\" (format-options (dissoc options :directed?) \", \") \"]\")))\n\n(defn- format-node [id {:keys [label shape] :as options}]\n  (let [shape (or shape\n                (when (sequential? label)\n                  :record))\n        options (assoc options\n                  :label (or label \"\")\n                  :shape shape)]\n    (str id \"[\"\n      (format-options options \", \")\n      \"]\")))\n\n\n;; added formatter for ranks\n(defn- format-rank [ids]\n  (apply str \"{ rank=same; \"\n         (concat (interpose \", \" ids) [\"}\"])))\n\n;;;\n\n(def ^:private ^:dynamic *node->id* nil)\n(def ^:private ^:dynamic *cluster->id* nil)\n\n(defn- node->id [n]\n  (*node->id* n))\n\n(defn- cluster->id [s]\n  (*cluster->id* s))\n\n;; added to allow for a node to be in more than one cluster which\n;; is needed when we have nested clusters\n(defn- clust->nds [f nodes] \n  (reduce-kv\n   (fn [m k v]\n     (let [separated (zipmap k (repeat (into #{} v)))]\n       (merge-with set/union separated m)))\n   {}\n   (dissoc (group-by f nodes) nil)))\n\n\n(defn graph->dot\n  \"Takes a description of a graph, and returns a string describing a GraphViz dot file.\n\n   Requires two fields: `nodes`, which is a list of the nodes in the graph, and `adjacent`, which\n   is a function that takes a node and returns a list of adjacent nodes.\"\n  [nodes adjacent\n   & {:keys [directed?\n             vertical?\n             options\n             node->descriptor\n             edge->descriptor\n             cluster->parent\n             node->clusters  ;; changed from ->cluster to ->cluster*s*\n             cluster->descriptor\n             cluster->ranks]\n      :or {directed? true\n           vertical? true\n           node->descriptor (constantly nil)\n           edge->descriptor (constantly nil)\n           cluster->parent (constantly nil)\n           node->clusters (constantly nil)\n           cluster->descriptor (constantly nil)\n           cluster->ranks (constantly nil)}\n      :as graph-descriptor}]\n\n;; inlined the macro code for cljc\n  (binding [*node->id* (or *node->id* (memoize (fn [_] (gensym \"node\"))))\n            *cluster->id* (or *cluster->id* (memoize (fn [_] (gensym \"cluster\"))))]\n    (let [current-cluster (::cluster graph-descriptor)\n          subgraph? (boolean current-cluster)\n          cluster->nodes (when node->clusters\n                           (clust->nds node->clusters nodes)) ;; changed for nested clusters\n          cluster? (if cluster->nodes\n                     (comp boolean cluster->nodes)\n                     (constantly false))\n          node? (set nodes)\n          ranks (cluster->ranks current-cluster)]\n\n     (apply str\n       (if current-cluster\n         (str \"subgraph \" (cluster->id current-cluster))\n         (if directed?\n           \"digraph\"\n           \"graph\"))\n       \" {\\n\"\n\n       ;; global options\n       (let [edge-options (:edge options)\n             node-options (:node options)]\n         (str\n           ;; graph[...]\n           \"graph[\"\n           (-> (merge default-options options)\n             (update-in [:fontname] #(or % (when subgraph? \"Monospace\")))\n             (assoc :vertical? vertical?)\n             (dissoc :edge :node)\n             translate-options\n             (format-options \", \"))\n           \"]\\n\"\n\n           ;; node[...]\n           \"node[\"\n           (-> node-options\n             (update-in [:fontname] #(or % \"Monospace\"))\n             (translate-options)\n             (format-options \", \"))\n           \"]\\n\"\n\n           ;; edge[...]\n           \"edge[\"\n           (-> edge-options\n             (update-in [:fontname] #(or % \"Monospace\"))\n             (translate-options)\n             (format-options \", \"))\n           \"]\\n\\n\"))\n\n       (interpose \"\\n\"\n         (concat\n\n           ;; nodes\n           (->> nodes\n             (remove #(if current-cluster\n                        (not (contains? (node->clusters %) current-cluster))\n                        false)) ;; <-changed\n             (map\n               #(format-node (node->id %)\n                  (merge\n                    default-node-options\n                    (node->descriptor %)))))\n\n           ;; added ranks functionality\n           (->> ranks\n                (map\n                 (fn [r]\n                   (format-rank\n                    (mapv *node->id* r)))))\n\n           ;; clusters\n           (->> cluster->nodes\n             keys\n             (remove #(not= current-cluster (cluster->parent %)))\n             (map\n               #(apply graph->dot\n                  nodes\n                  adjacent\n                  (apply concat\n                    (assoc graph-descriptor\n                      ::cluster %\n                      :options (cluster->descriptor %))))))\n\n           ;; edges\n           (when-not subgraph?\n\n             (->> nodes\n\n               ;; filter out destinations that aren't in `nodes`, and differentiate\n               ;; between nodes and clusters\n               (mapcat\n                 (fn [node]\n                   (map vector\n                     (repeat node)\n                     (->> node\n                       adjacent\n                       (map\n                         #(cond\n                            (node? %) [:node %]\n                            (cluster? %) [:cluster %]\n                            :else nil))\n                       (remove nil?)))))\n\n               ;; format the edges\n               (map (fn [[a [type b]]]\n                      (let [descriptor (edge->descriptor a b)\n                            format #(format-edge\n                                      (node->id a)\n                                      (if (= :node type)\n                                        (node->id b)\n                                        (cluster->id b))\n                                      (merge\n                                        default-edge-options\n                                        {:directed? directed?}\n                                        %))]\n                        (if (vector? descriptor)\n                          (->> descriptor\n                            (map format)\n                            (interpose \"\\n\")\n                            (apply str))\n                          (format descriptor)))))))\n\n           [\"}\\n\"]))))))\n\n;; deleted tree->dot as didn't need\n"]}