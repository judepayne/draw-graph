{"version":3,"sources":["rhizome/dot.cljc"],"mappings":";;;;AAMA,AAAA,AAAeA;AAEf;;;AAAA,AAAOC,AAEJC;AAFH,AAGE,AAAA,AAAAC,AAAAC,AAACC;AAAD,AACG,AAAAF,AAACG,AAAe,AAAAF,AAAS,AAAA,AAAAA;AAC1BF,AACAF;;AAIJ,AAAA,AAAA,AAAA,AAAeO;AAGf,AAAA,AAAeC;AAGf,AAAA,AAAeC;AAKf,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAeC;AAGf,AAAA,AAAMC,AAAmBC;AAAzB,AAEI,AAACC,AACC,AAAAC,AAKF,AAACU,AAAOC,AACR,AAAA,AAACC;AANC,AAAA,AAAAX,AAAAD;AAAA,AAAAE,AAAAD,AAAA,AAAA,AAAME;AAAN,AAAAD,AAAAD,AAAA,AAAA,AAAQG;AAAR,AACE,AAAAC,AAAgB,AAACT,AAAAA,AAAAA,AAAoBO,AAAAA;AAArC,AAAA,AAAAE;AAAA,AAAAC,AAAAD;AAAA,AAAAH,AAAAI,AAAA,AAAA,AAAUC;AAAV,AAAAL,AAAAI,AAAA,AAAA,AAAaE;AAAb,AACE,AAAU,AAACC,AAAUX,AAAES;AAAvB;;AAAA,AAAA,AACGA,AAAG,AAACC,AAAAA,AAAAA,AAAEJ,AAAAA;;;AAFX,AAGGD,AAAEC;;AANNN;;AAYP,AAAA,AAAMe,AAAWzB;AAAjB,AAAA,AAAA,AAAA,AAAA,AAAA,AACcA;;AAEd,AAAA,AAAM0B,AAAUC;AAAhB,AACE,AAAA,AAAA,AAAIA,AAAEC;;AAER,AAAA,AAAMC,AAAgBF;AAAtB,AACE,AAAI,AAACD,AAASC;AACZ,AAACG,AAAMH;;AACPA;;;AAMJ,AAAA,AAAOI,AAAsBf;AAA7B,AACE,AAAMgB,AAAM,AAAKhB;AAAjB,AACE,AAGE,AAAA,AAACiB,AAAiBD;AAAYA;;AAHhC,AAIE,AAAShB;AAAG,AAAA,AAAA,AAAQ,AAACjB,AAAciB;;AAJrC,AAKE,AAAAkB,AAAUlB;AAAG,AAACmB,AAAKnB;;AALrB,AAME,AAACoB,AAAMpB;AAAG,AAAI,AAACU,AAASV;AACZ,AAAA,AAAA,AAAU,AAACa,AAAeb;;AAC1B,AAAA,AAAA,AACUA,AACA,AAACL,AAAIoB,AACL,AAAA,AAACM,AACD,AAACC,AAAMC;;;AAZ/B,AAcQ,AAAKvB;;;;;;;AAEjB,AAAA,AAAMwB,AAAcC;AAApB,AACE,AACE,AAACC,AAAYD;AACb,AACE,AAAA,AAAAE,AAAChC,AACD,AAAA,AAAC0B,AACD,AAACC,AAAMC,AACPd;AAHA,AAAM,AAAA,AAAA,AAAU,AAAA,AAAAkB,AAAAA,AAAMH,AAAAA,AAAAA,AAAaX;AADhCY;;AAFP,AAQE,AAASA;AACTA;;AATF,AAWE,AAAA,AAAMA;AAXR;;AAAA,AAeE,AAACG,AAAOH;;;;;;AAEZ,AAAA,AAAOI,AAAgBnC,AAAEoC;AAAzB,AAII,AAACnC,AACC,AAAAwC,AAEF,AAACd,AAAUS,AACX,AAACR,AAAMC;AAHL,AAAA,AAAAa,AAAAD;AAAA,AAAArC,AAAAsC,AAAA,AAAA,AAAMrC;AAAN,AAAAD,AAAAsC,AAAA,AAAA,AAAQpC;AAAR,AACE,AAAA,AAAK,AAACmB,AAAKpB,AAAO,AAACgB,AAAqBf;AAJ5C,AAAA,AAAA,AAAA,AAAA+B,AAACC,AAAUtC,AACX,AAACY,AAAO,AAAC2B,AAAK1B,AAAK2B;AADnB,AAAuB,AAAAH;AAAA,AAAQ,AAAAA,AAACP;;AAAT;;;;AAQ3B,AAAA,AAAAa,AAAOK,AAAaC,AAAIC;AAAxB,AAAA,AAAAN,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAC,AAAA,AAAAD,AAAA,AAAA,AAAA,AAAA,AAAAhB,AAAAkB,AAAAF,AAAAA;AAAAA,AAAmDQ;AAAnD,AAAAL,AAAAH,AAAA,AAAoCO;AAApC,AACE,AAAMC,AAAQ,AAAA,AAAA,AAAA,AAACd,AAAUc;AAAXC;AAAA,AAA6B,AAAAC,AAAAD;AAAA,AAAA,AAAAC;AAAAA;;AAAA;;;;AAA3C,AACE,AAAA,AAAA,AAAKL,AACH,AAAA,AAAA,AAAIE,AAGJD,AACI,AAAA,AAACf,AAAe,AAAA,AAACoB,AAAOH;;AAElC,AAAA,AAAAI,AAAOE,AAAaC;AAApB,AAAA,AAAAF,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAZ,AAAA,AAAAY,AAAA,AAAA,AAAA,AAAA,AAAA7B,AAAAkB,AAAAW,AAAAA;AAAAA,AAAgDL;AAAhD,AAAAL,AAAAU,AAAA,AAA+B1B;AAA/B,AAAAgB,AAAAU,AAAA,AAAqCG;AAArC,AACE,AAAMA,AAAM,AAAAN,AAAIM;AAAJ,AAAA,AAAAN;AAAAA;;AACE,AAAM,AAACtB,AAAYD;AAAnB,AAAA;;AAAA;;;;AAERqB,AAAQ,AAAA,AAACS,AAAMT,AACE,AAAAE,AAAIvB;AAAJ,AAAA,AAAAuB;AAAAA;;AAAA;;AADT,AAESM;AALvB,AAME,AAAA,AAAA,AAAKD,AACH,AAAA,AAACxB,AAAeiB;;AAKtB,AAAA,AAAOU,AAAaC;AAApB,AACE,AAAA,AAACC,AAAMnC,AACA,AAAA,AAAA,AAACoC,AAAO,AAAA,AAACtC,AAAeoC;;AAIjC,AAAA,AAAyBG;AACzB,AAAA,AAAyBC;AAEzB,AAAA,AAAOC,AAAUC;AAAjB,AACE,AAACH,AAAAA,AAAAA,AAAWG,AAAAA;;AAEd,AAAA,AAAOC,AAAahF;AAApB,AACE,AAAC6E,AAAAA,AAAAA,AAAc7E,AAAAA;;AAIjB,AAAA,AAAOiF,AAAY7D,AAAE8D;AAArB,AACE,AAACC,AACA,AAAKzE,AAAEK,AAAEC;AAAT,AACE,AAAMoE,AAAU,AAACC,AAAOtE,AAAE,AAACuE,AAAO,AAAA,AAAC9D,AAASR;AAA5C,AACE,AAACuE,AAAWC,AAAUJ,AAAU1E;AAHrC,AAKC,AAAA,AAACuD,AAAO,AAACwB,AAASrE,AAAE8D;;AAGvB,AAAA;;;;;;AAAA,AAAAQ,AAAMM;AAAN,AAAA,AAAAL,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAAE;;AAAA,AAAA,AAAAA,AAAA;;;;AAAA;;;;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA,AAAA,AAAAI,AAAA,AAAAJ,AAAA,AAAA,AAAA,AAAA;AAAA,AAAA,AAAAK,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAF;;;AAAA,AAAA,AAAA,AAAA,AAAAG,AAAMD,AAKHd,AAAMuB;AALT,AAAA,AAAAP,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA3C,AAAA,AAAA2C,AAAA,AAAA,AAAA,AAAA,AAAA5D,AAAAkB,AAAA0C,AAAAA;AAAAA,AAuBUgB;AAvBV,AAAAzD,AAAAyC,AAAA,AAQapC;AARb,AAAAqC,AAAAD,AAAA,AAAA,AAMarC;AANb,AAAAsC,AAAAD,AAAA,AAaaa,AAQkB,AAAA,AAACE;AArBhC,AAAAd,AAAAD,AAAA,AAcac,AAQa,AAAA,AAACC;AAtB3B,AAAAd,AAAAD,AAAA,AAUaU,AAQe,AAAA,AAACK;AAlB7B,AAAAd,AAAAD,AAAA,AAWaW,AAQc,AAAA,AAACI;AAnB5B,AAAAd,AAAAD,AAAA,AASaS,AAQe,AAAA,AAACM;AAjB7B,AAAAd,AAAAD,AAAA,AAAA,AAOaQ;AAPb,AAAAP,AAAAD,AAAA,AAYaY,AAQa,AAAA,AAACG;AApB3B,AA0BE,AAAAE,AAAUvC;AAAVwC,AACUvC;AADVwC,AAAqB,AAAArD,AAAIY;AAAJ,AAAA,AAAAZ;AAAAA;;AAAe,AAACuD,AAAQ;AAAKC;AAAL,AAAQ,AAAA,AAACC;;;;;AAAtDH,AACwB,AAAAtD,AAAIa;AAAJ,AAAA,AAAAb;AAAAA;;AAAkB,AAACuD,AAAQ;AAAKC;AAAL,AAAQ,AAAA,AAACC;;;;;AAD5D,AAAA,AAAAJ,AAAUzC;;AAAV,AAAA0C,AACUzC;;AADV,AAAA,AAEE,AAAM6C,AAAgB,AAAA,AAAWR;AAC3BS,AAAU,AAACC,AAAQF;AACnBG,AAAe,AAAA,AAAA,AAAMf,AACJ,AAAC7B,AAAW6B,AAAe5B;AAC5C4C,AAAS,AAAID,AACF,AAAC5E,AAAK2E,AAAQC,AACd,AAAA,AAACZ;AACZc,AAAM,AAACC,AAAI9C;AACX+C,AAAM,AAACjB,AAAAA,AAAAA,AAAeU,AAAAA;AAR5B,AAUC,AAAA,AAACQ,AAAM3F,AACL,AAAImF,AACF,AAAA,AAAiB,AAAC1C,AAAY0C,AAC9B,AAAA,AAAA,AAAI7D,AAMN,AAAMsE,AAAa,AAAA,AAAOrE;AACpBsE,AAAa,AAAA,AAAOtE;AAD1B,AAEE,AAAA,AAGM,AAACuE,AAAMhI,AAAgByD,AACzB,AAAA,AAAA,AAAA,AAACd,AACD,AAACuF,AACD,AAACC,AACD/H,AACA,AAAA,AAACoC;AAJDyF;AAAA,AAAwB,AAAAtE,AAAAsE;AAAA,AAAA,AAAAtE;AAAAA;;AAAM,AAAM2D;AAAN,AAAA;;AAAA;;;;AAJlC,AAAA,AAKI,AAAkBjB,AAClB,AAAA,AAEA,AAKE0B,AACF,AAAA,AAAA,AAAA,AAACpF,AACD,AAACvC,AACD,AAACoC;AAFD4F;AAAA,AAAwB,AAAAzE,AAAAyE;AAAA,AAAA,AAAAzE;AAAAA;;AAAA;;;AAd5B,AAAA,AAgBI,AAKEmE,AACF,AAAA,AAAA,AAAA,AAACnF,AACD,AAACvC,AACD,AAACoC;AAFD6F;AAAA,AAAwB,AAAA1E,AAAA0E;AAAA,AAAA,AAAA1E;AAAAA;;AAAA;;;AAtB5B,AAwBI;AAGN,AAAA,AAAC3B,AACC,AAACsG,AAOG,AAAA,AAAChI;AAADkI;AAAA,AACG,AAACzE,AAAY,AAAAyE,AAAC/D,AACZ,AAACuD,AACC/H,AACA,AAAAuI,AAAAA,AAAClC,AAAAA,AAAAA;;AAPR,AAAA,AAACrF;AAADsH;AAAA,AAAS,AAAIlB;AACF,AAAK,AAACrG,AAAU,AAAAuH,AAAAA,AAAC9B,AAAAA,AAAAA,AAAkBY;;AADrC;;;AADNxC,AAYA,AAACvE,AACA;AAAKmI;AAAL,AACE,AAACtE,AACA,AAACuE,AAAKnE,AAAWkE;;AAJrBb,AAUH,AAAA,AAACtH;AAADwI;AAAA,AACG,AAACC,AAAMpD,AACLd,AACAuB,AACA,AAACnE,AAAM+G,AACL,AAAA,AAAAF,AAAA,AAAC5E,AAAM2C,AAEI,AAAAiC,AAAAA,AAACpC,AAAAA,AAAAA;;AARnB,AAAA,AAACzF;AAAD2H;AAAA,AAAS,AAACC,AAAKxB,AAAgB,AAAAuB,AAAAA,AAACpC,AAAAA,AAAAA;;AAF7BgB,AACHmB,AACA,AAWF,AAAA,AAAA,AAAUrB,AAoBN,AAAChH,AAAI;AAAAgJ;AAAA,AAAA,AAAAC,AAAAD;AAAA,AAAA7I,AAAA8I,AAAA,AAAA,AAAME;AAAND,AAAA,AAAA/I,AAAA8I,AAAA,AAAA;AAAA,AAAA9I,AAAA+I,AAAA,AAAA,AAASE;AAAT,AAAAjJ,AAAA+I,AAAA,AAAA,AAAcG;AAAd,AACE,AAAME,AAAW,AAACtD,AAAAA,AAAAA,AAAiBkD,AAAAA,AAAEE,AAAAA;AAArC,AACMG;AADNF;AAAA,AACc,AAACvG,AACC,AAACoB,AAASgF,AACV,AAAI,AAAA,AAACM,AAAQL,AACX,AAACjF,AAASkF,AACV,AAAChF,AAAYgF,AACf,AAAA,AAAA,AAAAC,AAAC5B,AACC9H,AACYsD;;;AAR9B,AAUE,AAAI,AAACwG,AAAQH;AACNA,AACH,AAACvJ,AAAIwJ,AACL,AAAA,AAAC9H,AACD,AAACC,AAAMC;;AACT,AAAC4H,AAAOD;;;AA9BnB,AAACZ,AACC;AAAKC;AAAL,AACE,AAACC,AAAIC,AACH,AAACnE,AAAOiE,AAGN,AAAA,AAAC5I,AAKD,AAACW,AAAOC;AALRmI;AAAA,AACG,AACE,AAAAA,AAAAA,AAAC3B,AAAAA,AAAAA;AADH,AAAA,AAAA2B;;AAAA,AAEE,AAAAA,AAAAA,AAAC5B,AAAAA,AAAAA;AAFH,AAAA,AAAA4B;;AAAA,AAAA;;;;;AAHAH,AAAAA,AACH9C,AAAAA,AAAAA,AACA;;AA9Cd,AAAA,AAoCSvB;AAvFhB,AAAA,AAAAkC,AACUvC;;AADV,AAAAsC,AAAUvC;;;AA1BZ,AAAA,AAAA,AAAMoB;;AAAN;AAAA,AAAA,AAAA,AAAAI,AAAMJ;AAAN,AAAA,AAAAK,AAAA,AAAAvE,AAAAsE;AAAAA,AAAA,AAAAE,AAAAF;AAAAG,AAAA,AAAAzE,AAAAsE;AAAAA,AAAA,AAAAE,AAAAF;AAAA,AAAA,AAAAI,AAAA;AAAA,AAAA,AAAAA,AAAAH,AAAAE,AAAAH;;;AAAA","names":["rhizome.dot/escapable-characters","rhizome.dot/escape-string","s","p1__47134#","p2__47135#","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","clojure.string/replace","rhizome.dot/default-options","rhizome.dot/default-node-options","rhizome.dot/default-edge-options","rhizome.dot/option-translations","rhizome.dot/translate-options","m","cljs.core.map.cljs$core$IFn$_invoke$arity$2","p__47140","vec__47141","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","k","v","temp__5718__auto__","vec__47145","k*","f","cljs.core/contains?","cljs.core.remove.cljs$core$IFn$_invoke$arity$2","cljs.core/nil?","cljs.core.into.cljs$core$IFn$_invoke$arity$2","rhizome.dot/->literal","rhizome.dot/literal?","x","cljs.core/meta","rhizome.dot/unwrap-literal","cljs.core/first","rhizome.dot/format-options-value","v-str","clojure.string/starts-with?","cljs.core/Keyword","cljs.core/name","cljs.core/coll?","cljs.core.interpose.cljs$core$IFn$_invoke$arity$2","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/str","rhizome.dot/format-label","label","cljs.core/sequential?","p1__47158#","cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic","rhizome.dot/format-options","separator","p1__47160#","cljs.core.update_in.cljs$core$IFn$_invoke$arity$3","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","cljs.core/second","p__47164","vec__47165","p__47172","map__47173","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","rhizome.dot/format-edge","src","dst","directed?","options","p1__47171#","or__4131__auto__","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","p__47191","map__47192","rhizome.dot/format-node","id","shape","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","rhizome.dot/format-rank","ids","cljs.core.apply.cljs$core$IFn$_invoke$arity$3","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","rhizome.dot/*node->id*","rhizome.dot/*cluster->id*","rhizome.dot/node->id","n","rhizome.dot/cluster->id","rhizome.dot/clust->nds","nodes","cljs.core/reduce-kv","separated","cljs.core/zipmap","cljs.core.repeat.cljs$core$IFn$_invoke$arity$1","cljs.core.merge_with.cljs$core$IFn$_invoke$arity$variadic","clojure.set/union","cljs.core/group-by","var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","rhizome.dot/graph->dot","p__47232","map__47233","cljs.core.get.cljs$core$IFn$_invoke$arity$3","seq47222","G__47223","cljs.core/next","G__47224","self__4717__auto__","adjacent","vertical?","node->descriptor","edge->descriptor","cluster->parent","node->clusters","cluster->descriptor","cluster->ranks","cljs.core/constantly","graph-descriptor","*node->id*-orig-val__47237","*cluster->id*-orig-val__47238","*node->id*-temp-val__47239","*cluster->id*-temp-val__47240","cljs.core/memoize","_","cljs.core.gensym.cljs$core$IFn$_invoke$arity$1","current-cluster","subgraph?","cljs.core/boolean","cluster->nodes","cluster?","node?","cljs.core/set","ranks","cljs.core.apply.cljs$core$IFn$_invoke$arity$5","edge-options","node-options","cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic","p1__47210#","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic","p1__47211#","p1__47212#","cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic","p1__47213#","p1__47214#","r","cljs.core.mapv.cljs$core$IFn$_invoke$arity$2","cljs.core/keys","p1__47215#","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","p1__47216#","cljs.core.apply.cljs$core$IFn$_invoke$arity$4","cljs.core/concat","cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic","node","cljs.core.map.cljs$core$IFn$_invoke$arity$3","cljs.core/vector","p1__47217#","p__47256","vec__47257","vec__47260","a","type","b","p1__47218#","descriptor","format","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/vector?"],"sourcesContent":["(ns rhizome.dot\n  (:require [clojure.string :as str]\n            [clojure.set :as set]))\n\n;;;\n\n(def ^:private escapable-characters \"\\\\|{}\\\"\")\n\n(defn- escape-string\n  \"Escape characters that are significant for the dot format.\"\n  [s]\n  (reduce\n    #(str/replace %1 (str %2) (str \"\\\\\" %2))\n    s\n    escapable-characters))\n\n;;;\n\n(def ^:private default-options\n  {:dpi 100})\n\n(def ^:private default-node-options\n  {})\n\n(def ^:private default-edge-options\n  {})\n\n;;;\n\n(def ^:private option-translations\n  {:vertical? [:rankdir {true :TP, false :LR}]})\n\n(defn translate-options [m]\n  (->> m\n    (map\n      (fn [[k v]]\n        (if-let [[k* f] (option-translations k)]\n          (when-not (contains? m k*)\n            [k* (f v)])\n          [k v])))\n    (remove nil?)\n    (into {})))\n\n;;;\n\n(defn ->literal [s]\n  ^::literal [s])\n\n(defn literal? [x]\n  (-> x meta ::literal))\n\n(defn unwrap-literal [x]\n  (if (literal? x)\n    (first x)\n    x))\n\n;;;\n\n\n\n(defn- format-options-value [v]\n  (let [v-str (str v)]\n    (cond\n      ;; added first condition to handle html like labels which don't\n      ;; work if wrapped in quotes\n      (str/starts-with? v-str \"<<\") v-str\n      (string? v) (str \\\" (escape-string v) \\\")\n      (keyword? v) (name v)\n      (coll? v) (if (literal? v)\n                  (str \"\\\"\" (unwrap-literal v) \"\\\"\")\n                  (str \"\\\"\"\n                       (->> v\n                            (map format-options-value)\n                            (interpose \",\")\n                            (apply str))\n                       \"\\\"\"))\n      :else (str v))))\n\n(defn format-label [label]\n  (cond\n    (sequential? label)\n    (->> label\n      (map #(str \"{ \" (-> % format-label unwrap-literal) \" }\"))\n      (interpose \" | \")\n      (apply str)\n      ->literal)\n\n    (string? label)\n    label\n\n    (nil? label)\n    \"\"\n\n    :else\n    (pr-str label)))\n\n(defn- format-options [m separator]\n  (->>\n    (update-in m [:label] #(when % (format-label %)))\n    (remove (comp nil? second))\n    (map\n      (fn [[k v]]\n        (str (name k) \"=\" (format-options-value v))))\n    (interpose separator)\n    (apply str)))\n\n(defn- format-edge [src dst {:keys [directed?] :as options}]\n  (let [options (update-in options [:label] #(or % \"\"))]\n    (str src\n      (if directed?\n        \" -> \"\n        \" -- \")\n      dst\n      \"[\" (format-options (dissoc options :directed?) \", \") \"]\")))\n\n(defn- format-node [id {:keys [label shape] :as options}]\n  (let [shape (or shape\n                (when (sequential? label)\n                  :record))\n        options (assoc options\n                  :label (or label \"\")\n                  :shape shape)]\n    (str id \"[\"\n      (format-options options \", \")\n      \"]\")))\n\n\n;; added formatter for ranks\n(defn- format-rank [ids]\n  (apply str \"{ rank=same; \"\n         (concat (interpose \", \" ids) [\"}\"])))\n\n;;;\n\n(def ^:private ^:dynamic *node->id* nil)\n(def ^:private ^:dynamic *cluster->id* nil)\n\n(defn- node->id [n]\n  (*node->id* n))\n\n(defn- cluster->id [s]\n  (*cluster->id* s))\n\n;; added to allow for a node to be in more than one cluster which\n;; is needed when we have nested clusters\n(defn- clust->nds [f nodes] \n  (reduce-kv\n   (fn [m k v]\n     (let [separated (zipmap k (repeat (into #{} v)))]\n       (merge-with set/union separated m)))\n   {}\n   (dissoc (group-by f nodes) nil)))\n\n\n(defn graph->dot\n  \"Takes a description of a graph, and returns a string describing a GraphViz dot file.\n\n   Requires two fields: `nodes`, which is a list of the nodes in the graph, and `adjacent`, which\n   is a function that takes a node and returns a list of adjacent nodes.\"\n  [nodes adjacent\n   & {:keys [directed?\n             vertical?\n             options\n             node->descriptor\n             edge->descriptor\n             cluster->parent\n             node->clusters  ;; changed from ->cluster to ->cluster*s*\n             cluster->descriptor\n             cluster->ranks]\n      :or {directed? true\n           vertical? true\n           node->descriptor (constantly nil)\n           edge->descriptor (constantly nil)\n           cluster->parent (constantly nil)\n           node->clusters (constantly nil)\n           cluster->descriptor (constantly nil)\n           cluster->ranks (constantly nil)}\n      :as graph-descriptor}]\n\n;; inlined the macro code for cljc\n  (binding [*node->id* (or *node->id* (memoize (fn [_] (gensym \"node\"))))\n            *cluster->id* (or *cluster->id* (memoize (fn [_] (gensym \"cluster\"))))]\n    (let [current-cluster (::cluster graph-descriptor)\n          subgraph? (boolean current-cluster)\n          cluster->nodes (when node->clusters\n                           (clust->nds node->clusters nodes)) ;; changed for nested clusters\n          cluster? (if cluster->nodes\n                     (comp boolean cluster->nodes)\n                     (constantly false))\n          node? (set nodes)\n          ranks (cluster->ranks current-cluster)]\n\n     (apply str\n       (if current-cluster\n         (str \"subgraph \" (cluster->id current-cluster))\n         (if directed?\n           \"digraph\"\n           \"graph\"))\n       \" {\\n\"\n\n       ;; global options\n       (let [edge-options (:edge options)\n             node-options (:node options)]\n         (str\n           ;; graph[...]\n           \"graph[\"\n           (-> (merge default-options options)\n             (update-in [:fontname] #(or % (when subgraph? \"Monospace\")))\n             (assoc :vertical? vertical?)\n             (dissoc :edge :node)\n             translate-options\n             (format-options \", \"))\n           \"]\\n\"\n\n           ;; node[...]\n           \"node[\"\n           (-> node-options\n             (update-in [:fontname] #(or % \"Monospace\"))\n             (translate-options)\n             (format-options \", \"))\n           \"]\\n\"\n\n           ;; edge[...]\n           \"edge[\"\n           (-> edge-options\n             (update-in [:fontname] #(or % \"Monospace\"))\n             (translate-options)\n             (format-options \", \"))\n           \"]\\n\\n\"))\n\n       (interpose \"\\n\"\n         (concat\n\n           ;; nodes\n           (->> nodes\n             (remove #(if current-cluster\n                        (not (contains? (node->clusters %) current-cluster))\n                        false)) ;; <-changed\n             (map\n               #(format-node (node->id %)\n                  (merge\n                    default-node-options\n                    (node->descriptor %)))))\n\n           ;; added ranks functionality\n           (->> ranks\n                (map\n                 (fn [r]\n                   (format-rank\n                    (mapv *node->id* r)))))\n\n           ;; clusters\n           (->> cluster->nodes\n             keys\n             (remove #(not= current-cluster (cluster->parent %)))\n             (map\n               #(apply graph->dot\n                  nodes\n                  adjacent\n                  (apply concat\n                    (assoc graph-descriptor\n                      ::cluster %\n                      :options (cluster->descriptor %))))))\n\n           ;; edges\n           (when-not subgraph?\n\n             (->> nodes\n\n               ;; filter out destinations that aren't in `nodes`, and differentiate\n               ;; between nodes and clusters\n               (mapcat\n                 (fn [node]\n                   (map vector\n                     (repeat node)\n                     (->> node\n                       adjacent\n                       (map\n                         #(cond\n                            (node? %) [:node %]\n                            (cluster? %) [:cluster %]\n                            :else nil))\n                       (remove nil?)))))\n\n               ;; format the edges\n               (map (fn [[a [type b]]]\n                      (let [descriptor (edge->descriptor a b)\n                            format #(format-edge\n                                      (node->id a)\n                                      (if (= :node type)\n                                        (node->id b)\n                                        (cluster->id b))\n                                      (merge\n                                        default-edge-options\n                                        {:directed? directed?}\n                                        %))]\n                        (if (vector? descriptor)\n                          (->> descriptor\n                            (map format)\n                            (interpose \"\\n\")\n                            (apply str))\n                          (format descriptor)))))))\n\n           [\"}\\n\"]))))))\n\n;; deleted tree->dot as didn't need\n"]}