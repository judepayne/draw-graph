{"version":3,"sources":["markdown/common.cljc"],"mappings":"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","names":["markdown.common/*inhibit-separator*","markdown.common/escape-delimiter","cljs.core/char","markdown.common/gen-token","n","var_args","args__4795__auto__","len__4789__auto__","i__4790__auto__","argseq__4796__auto__","cljs.core/IndexedSeq","markdown.common/freeze-string","seq40520","self__4777__auto__","cljs.core/seq","args","state","cljs.core/last","token","cljs.core/count","cljs.core/assoc-in","cljs.core.reduce","cljs.core/str","cljs.core/flatten","cljs.core.drop_last","markdown.common/thaw-string","text","temp__5733__auto__","matches","cljs.core/re-seq","cljs.core/re-pattern","s","r","p1__40521#","clojure.string/replace","cljs.core.get","p1__40522#","cljs.core.update","cljs.core.apply","cljs.core/dissoc","markdown.common/thaw-strings","cljs.core/empty?","markdown.common/escape-code","markdown.common/escaped-chars","or__4185__auto__","G__40533","markdown.common/make-separator","js/Error","separator","open","close","markdown.common.make_separator","cljs.core/identity","transformer","out","buf","tokens","cljs.core.partition_by","cljs.core.partial","cljs.core/=","cljs.core/first","cur-state","cljs.core.assoc","clojure.string.join","cljs.core.into","cljs.core.dissoc","cljs.core._EQ_","vec__40550","cljs.core.nth","new-buf","new-state","vec__40553","G__40556","G__40557","cljs.core/vec","cljs.core.concat","cljs.core/rest","markdown.common/escape-code-transformer","markdown.common/separator","escape?","markdown.common/strong","markdown.common/bold-italic","markdown.common/bold","markdown.common/em","markdown.common/italics","markdown.common/strikethrough","markdown.common/inline-code","markdown.common/inhibit","markdown.common/escape-inhibit-separator","markdown.common/heading-text","clojure.string/trim","markdown.common/heading-level","num-hashes","p1__40578#","cljs.core.filter","cljs.core.not_EQ_","p1__40579#","cljs.core.take_while","markdown.common/make-heading","heading-anchors","temp__5735__auto__","heading","clojure.string/lower-case","markdown.common/dashes"],"sourcesContent":["(ns markdown.common\n  (:require [clojure.string :as string]))\n\n(declare ^{:dynamic true} *substring*)\n\n(def ^:dynamic *inhibit-separator* nil)\n\n(def escape-delimiter (str (char 254) (char 491)))\n\n(defn gen-token [n]\n  (str escape-delimiter n escape-delimiter))\n\n(defn freeze-string\n  \"Freezes an output string.  Converts to a placeholder token and puts that into the output.\n  Returns the [text, state] pair.  Adds it into the state, the 'frozen-strings' hashmap\n  So that it can be unfrozen later.\"\n  [& args]\n  (let [state (last args)\n        token (gen-token (count (:frozen-strings state)))]\n    [token (assoc-in state\n                     [:frozen-strings token]\n                     (reduce str (flatten (drop-last args))))]))\n\n(defn thaw-string\n  \"Recursively replaces the frozen strings in the output with the original text.\"\n  [text state]\n  (if-let [matches (re-seq (re-pattern (str escape-delimiter \"\\\\d+\" escape-delimiter)) text)]\n    (recur\n      (reduce\n        (fn [s r]\n          (string/replace s (re-pattern r) #(get (:frozen-strings state) % %)))\n        text matches)\n      (update state :frozen-strings #(apply dissoc % matches)))\n    [text state]))\n\n(defn thaw-strings\n  \"Terminally encoded strings are ones that we've determined should no longer be processed or evaluated\"\n  [text state]\n  (if-not (empty? (:frozen-strings state))\n    (thaw-string text state)\n    [text state]))\n\n(defn escape-code [s]\n  (-> s\n      (string/replace #\"&\" \"&amp;\")\n      (string/replace #\"\\*\" \"&#42;\")\n      (string/replace #\"\\^\" \"&#94;\")\n      (string/replace #\"\\_\" \"&#95;\")\n      (string/replace #\"\\~\" \"&#126;\")\n      (string/replace #\"\\<\" \"&lt;\")\n      (string/replace #\"\\>\" \"&gt;\")\n      ;(string/replace #\"\\/\" \"&frasl;\") ;screws up ClojureScript compiling\n      (string/replace #\"\\[\" \"&#91;\")\n      (string/replace #\"\\]\" \"&#93;\")\n      (string/replace #\"\\(\" \"&#40;\")\n      (string/replace #\"\\)\" \"&#41;\")\n      (string/replace #\"\\\"\" \"&quot;\")))\n\n(defn escaped-chars [text state]\n  [(if (or (:code state) (:codeblock state))\n     text\n     (-> text\n         (string/replace #\"\\\\\\\\\" \"&#92;\")\n         (string/replace #\"\\\\`\" \"&#8216;\")\n         (string/replace #\"\\\\\\*\" \"&#42;\")\n         (string/replace #\"\\\\_\" \"&#95;\")\n         (string/replace #\"\\\\\\{\" \"&#123;\")\n         (string/replace #\"\\\\\\}\" \"&#125;\")\n         (string/replace #\"\\\\\\[\" \"&#91;\")\n         (string/replace #\"\\\\\\]\" \"&#93;\")\n         (string/replace #\"\\\\\\(\" \"&#40;\")\n         (string/replace #\"\\\\\\)\" \"&#41;\")\n         (string/replace #\"\\\\#\" \"&#35;\")\n         (string/replace #\"\\\\\\+\" \"&#43;\")\n         (string/replace #\"\\\\-\" \"&#45;\")\n         (string/replace #\"\\\\\\.\" \"&#46;\")\n         (string/replace #\"\\\\!\" \"&#33;\")))\n   state])\n\n(defn make-separator\n  \"Return a transformer to\n   - find all the chunks of the string delimited by the `separator',\n   - wrap the output with the `open' and `close' markers, and\n   - apply the `transformer' to the text inside the chunk.\"\n  ([separator open close]\n   (make-separator separator open close identity))\n  ([separator open close transformer]\n   (let [separator (seq separator)]  ;; allow char seq or string\n     (fn [text state]\n       (if (:code state)\n         [text state]\n         (loop [out       []\n                buf       []\n                tokens    (partition-by (partial = (first separator)) (seq text))\n                cur-state (assoc state :found-token false)]\n           (cond\n             (empty? tokens)\n             [(string/join (into (if (:found-token cur-state) (into out separator) out) buf))\n              (dissoc cur-state :found-token)]\n\n             (:found-token cur-state)\n             (if (= (first tokens) separator)\n               (let [[new-buf new-state]\n                     (if (identical? transformer identity)\n                       ;; Skip the buf->string->buf conversions in the common\n                       ;; case.\n                       [buf cur-state]\n                       (let [[s new-state] (transformer (string/join buf) cur-state)]\n                         [(seq s) new-state]))]\n                 (recur (vec (concat out (seq open) new-buf (seq close)))\n                        []\n                        (rest tokens)\n                        (assoc new-state :found-token false)))\n               (recur out\n                      (into buf (first tokens))\n                      (rest tokens)\n                      cur-state))\n\n             (= (first tokens) separator)\n             (recur out buf (rest tokens) (assoc cur-state :found-token true))\n\n             :default\n             (recur (into out (first tokens)) buf (rest tokens) cur-state))))))))\n\n(defn escape-code-transformer [text state]\n  [(escape-code text) state])\n\n;; Not used any more internally; kept around just in case third party code\n;; depends on this.\n(defn separator [escape? text open close separator state]\n  ((make-separator separator open close (if escape? escape-code-transformer identity))\n   text state))\n\n(def strong (make-separator \"**\" \"<strong>\" \"</strong>\"))\n\n(def bold-italic (make-separator \"***\" \"<b><i>\" \"</i></b>\"))\n\n(def bold (make-separator \"__\" \"<b>\" \"</b>\"))\n\n(def em (make-separator \"*\" \"<em>\" \"</em>\"))\n\n(def italics (make-separator \"_\" \"<i>\" \"</i>\"))\n\n(def strikethrough (make-separator \"~~\" \"<del>\" \"</del>\"))\n\n(def inline-code (make-separator \"`\" \"<code>\" \"</code>\" escape-code-transformer))\n\n(defn inhibit [text state]\n  (if *inhibit-separator*\n    ((make-separator *inhibit-separator* \"\" \"\" freeze-string)\n     text state)\n    [text state]))\n\n(defn escape-inhibit-separator [text state]\n  [(if *inhibit-separator*\n     (string/replace text\n                     (string/join (concat *inhibit-separator* *inhibit-separator*))\n                     (string/join *inhibit-separator*))\n     text)\n   state])\n\n(defn heading-text [text]\n  (-> (clojure.string/replace text #\"^([ ]+)?[#]+\" \"\")\n      (clojure.string/replace #\"[#]+$\" \"\")\n      string/trim))\n\n(defn heading-level [text]\n  (let [num-hashes (count (filter #(not= \\space %) (take-while #(or (= \\# %) (= \\space %)) (seq text))))]\n    (if (pos? num-hashes) num-hashes)))\n\n(defn make-heading [text heading-anchors]\n  (when-let [heading (heading-level text)]\n    (let [text (heading-text text)]\n      ;; We do not need to process the id string, HTML5 ids can contain anything except the space character.\n      ;; (https://www.w3.org/TR/html5/dom.html#the-id-attribute)\n      (str \"<h\" heading (when heading-anchors (str \" id=\\\"\" (-> text string/lower-case (string/replace \" \" \"&#95;\")) \"\\\"\")) \">\"\n           text \"</h\" heading \">\"))))\n\n(defn dashes [text state]\n  [(if (or (:code state) (:codeblock state))\n     text\n     (-> text\n         (string/replace #\"\\-\\-\\-\" \"&mdash;\")\n         (string/replace #\"\\-\\-\" \"&ndash;\")))\n   state])\n"]}