{"version":3,"sources":["markdown_to_hiccup/core.cljc"],"mappings":"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","names":["cljs.spec.alpha/def-impl","cljs.core/string?","cljs.core/vector?","cljs.spec.alpha/map-spec-impl","G__36631","cljs.core/map?","cljs.spec.alpha/fspec-impl","cljs.spec.alpha.spec_impl.cljs$core$IFn$_invoke$arity$4","cljs.spec.alpha/cat-impl","var_args","G__36666","markdown-to-hiccup.core/md->hiccup","js/Error","md-str","params","valid-md","cljs.spec.alpha/*compile-asserts*","cljs.core/deref","cljs.spec.alpha/*runtime-asserts*","cljs.spec.alpha/assert*","encode?","html","markdown.core/md->html","dom","hickory.core/parse","hiccup","cljs.core/first","hickory.core/as-hiccup","markdown-to-hiccup.decode/decode","markdown_to_hiccup.core.md__GT_hiccup.cljs$core$IFn$_invoke$arity$2","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","markdown-to-hiccup.core/hicc-in","seq36667","G__36668","cljs.core/next","self__4717__auto__","kws","kw","root","cljs.core/empty?","cljs.core/rest","branch-result","cljs.core.apply.cljs$core$IFn$_invoke$arity$3","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","markdown-to-hiccup.core/keywords?","seq36675","self__4718__auto__","cljs.core/seq","args","cljs.core/every?","cljs.core/keyword?","markdown-to-hiccup.core/dec-front","kw-pairs","vec__36676","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","count","new-count","new-pair","cljs.core/cons","markdown-to-hiccup.core/num-partition","arglist","ret-vec","curr-arg","prev-arg","cljs.core/peek","cljs.core/Keyword","cljs.core.partition.cljs$core$IFn$_invoke$arity$2","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","markdown_to_hiccup.core.keywords_QMARK_.cljs$core$IFn$_invoke$arity$variadic","cljs.core.conj.cljs$core$IFn$_invoke$arity$variadic","markdown-to-hiccup.core/same-length?","coll-a","coll-b","cljs.core/count","markdown-to-hiccup.core/get-nested-hiccup","vec__36679","nth-kw","front","remaining","nested-front","new-pairs","markdown-to-hiccup.core/hiccup-in","seq36690","G__36691","pathway","markdown-to-hiccup.core/component","body","markdown_to_hiccup.core.hiccup_in.cljs$core$IFn$_invoke$arity$variadic","cljs.core/vec"],"sourcesContent":["(ns markdown-to-hiccup.core\n  (:require [clojure.string :as str]\n            [clojure.spec.alpha :as spec]\n            [markdown-to-hiccup.decode :as d]\n            [hickory.core :refer [parse as-hiccup]]\n            [markdown.core :refer #?(:clj  [md-to-html-string]\n                                     :cljs [md->html])]))\n\n(spec/def ::markdown string?)\n(spec/def ::hiccup vector?)\n(spec/def ::options (spec/keys :opt-un [::encode?]))\n(spec/fdef md->hiccup\n           :args (spec/cat :md-str ::markdown\n                           :params ::options)\n           :ret ::hiccup)\n(defn md->hiccup\n  \"Accepts a markdown string and returns a hiccup data structure converted from that markdown.\n  Also accepts an optional params map. Use the :encode? boolean key to specify whether\n  or not you want html escape characters to be encoded. Example:\n    (md->hiccup \\\"#Title\\\" {:encode? true})\"\n  ([md-str params]\n   (let [valid-md (spec/assert ::markdown md-str)\n         encode? (:encode? (spec/assert ::options params))\n         html #?(:clj  (md-to-html-string valid-md)\n                 :cljs (md->html valid-md))\n         dom  (parse html)\n         hiccup (first (as-hiccup dom))]\n     (if encode?\n       hiccup ;; by default encoded by hickory\n       (d/decode hiccup))))\n  ([md-str]\n   (md->hiccup md-str {:encode? false})))\n   \n(defn hicc-in\n  \"Deprecated. Please use hiccup-in for better access to nested hiccup.\n  Accepts a hiccup data structure and a keyword representing\n  an html element tag (e.g. :body) and returns the first nested\n  hiccup vector identified by the keyword.\"\n  [hiccup & kws]\n  (let [kw   (first kws)\n        root (first hiccup)]\n    (cond\n      (nil? kw)              hiccup\n      (empty? hiccup)        []\n      (map? root)            (recur (rest hiccup) kws)\n      (vector? root)         (let [branch-result (apply hicc-in root kws)]\n                               (if (empty? branch-result)\n                                 (recur (rest hiccup) kws)\n                                 branch-result))\n      (= root kw)            (recur hiccup (rest kws))\n      :else                  (recur (rest hiccup) kws))))\n\n(defn- keywords?\n  [& args]\n  (every? keyword? args))\n\n(defn- dec-front\n  \"Accepts a list of [keyword count] pairs, and subtracts the count\n   of the first pair. If that count becomes negative, dec-front returns\n   the rest of the list. Otherwise, it returns the list with the new\n   count value for the first pair.\"\n  [kw-pairs]\n  (let [[kw count] (first kw-pairs)\n        new-count  (dec count)\n        new-pair   [kw new-count]]\n    (if (neg? new-count)\n      (rest kw-pairs)\n      (cons new-pair (rest kw-pairs)))))\n\n(defn- num-partition\n  \"Accepts a list of keywords and numbers. Any place in which\n  a number does not separate keywords, a zero will be inserted.\n  Returns the arg list as a sequence of keyword -> number pairs\n  nested as lists.\"\n  [args]\n  (loop [arglist    args\n         ret-vec   []]\n    (let [curr-arg (first arglist)\n          prev-arg (peek ret-vec)]\n      (cond\n        ;; base case\n        (nil? curr-arg)            (if (keyword? prev-arg)\n                                     (partition 2 (conj ret-vec 0))\n                                     (partition 2 ret-vec))\n        ;; recursive cases\n        (keywords? curr-arg\n                   prev-arg)       (recur (rest arglist)\n                                          (conj ret-vec 0 curr-arg))\n\n        :else                      (recur (rest arglist)\n                                          (conj ret-vec curr-arg))))))\n\n\n(defn- same-length?\n  [coll-a coll-b]\n  (= (count coll-a)\n     (count coll-b)))\n\n(defn- get-nested-hiccup\n  \"Recursive helper function for hiccup-in.\"\n  [hiccup kw-pairs]\n  (let [[kw nth-kw]   (first kw-pairs)\n        front         (first hiccup)\n        remaining     (rest hiccup)]\n    (cond\n      (empty? hiccup)        []\n      (nil? kw)              hiccup\n      (map? front)           (recur remaining kw-pairs)\n      (vector? front)        (let [branch-result (get-nested-hiccup front kw-pairs)]\n                               (if (empty? branch-result)\n                                 (let [nested-front (first front)]\n                                   (if (= nested-front kw) ;; the child recurse did find a match, but we need to update our kw-pair list if the first element had a match\n                                    (recur remaining (dec-front kw-pairs))\n                                    (recur remaining kw-pairs)))\n                                 branch-result))\n      (= front kw)           (let [new-pairs (dec-front kw-pairs)]\n                               (cond\n                                 (empty? new-pairs)                  hiccup                         ;; no keywords left, return what we have found\n                                 :else                               (recur remaining new-pairs)))  ;; prceed to the next instance of the keyword\n      :else                  (recur remaining kw-pairs))))\n\n\n\n(defn hiccup-in\n  \"Accepts a hiccup data structure and any series of args in keyword, index order.\n   Each keyword represents a hiccup element, and the paired index is which element at that level hiccup-in will look in.\n   If no number proceeds a keyword, hiccup-in will find the first element with that keyword.\n   Returns the nested hiccup vector identified by the keywords.\n   Example: (hiccup-in hiccup :html :body :div 0 :h1 2 :p)\"\n  [hiccup & kw-pairs]\n   (let [pathway (num-partition kw-pairs)]\n     (get-nested-hiccup hiccup pathway)))\n\n(defn component\n  \"Accepts hiccup and returns the same hiccup only\n   without the :html, :head, and :body elements. Useful\n   if you want to nest your markdown hiccup in existing\n   hiccup data structures.\"\n  [hiccup]\n  (let [body (hiccup-in hiccup :body)]\n    (vec (cons :div (rest body)))))\n\n#?(:clj\n  (defn file->hiccup\n  \"Generates a valid hiccup data structure from markdown\n   contained in the .md file located at file-path\"\n  [file-path]\n  (let [contents (slurp file-path)]\n    (md->hiccup contents))))\n"]}