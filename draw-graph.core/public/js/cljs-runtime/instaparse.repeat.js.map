{"version":3,"sources":["instaparse/repeat.cljc"],"mappings":"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","names":["instaparse.repeat/empty-result?","result","cljs.core/vector?","cljs.core._EQ_","cljs.core/count","cljs.core/map?","cljs.core/contains?","cljs.core/empty?","cljs.core.get","instaparse.repeat/failure-signal","instaparse.gll/->Failure","var_args","G__53932","instaparse.repeat/get-end","js/Error","parse","vec__53934","cljs.core.nth","start","end","instaparse.viz/span","cljs.core/long","index","vec__53937","instaparse.repeat/parse-from-index","grammar","initial-parser","text","segment","tramp","instaparse.gll.make_tramp","instaparse.gll/push-listener","instaparse.gll/TopListener","instaparse.gll.run","instaparse.repeat/select-parse","parses","length","cljs.core/seq","vec__53940","cljs.core/first","temp__5733__auto__","follow-ups","cljs.core/next","G__53944","instaparse.repeat/repeat-parse-hiccup","root-tag","instaparse.repeat.repeat_parse_hiccup","first-result","G__53948","vec__53950","vec__53957","instaparse.auto-flatten-seq/auto-flatten-seq","selection","instaparse.gll/safe-with-meta","instaparse.auto-flatten-seq/convert-afs-to-vec","instaparse.auto-flatten-seq/conj-flat","G__53966","instaparse.repeat/repeat-parse-enlive","instaparse.repeat.repeat_parse_enlive","G__53971","vec__53974","vec__53988","instaparse.auto-flatten-seq/EMPTY","G__53997","instaparse.repeat/repeat-parse-no-tag","instaparse.repeat.repeat_parse_no_tag","G__54006","vec__54011","vec__54020","G__54024","instaparse.repeat/repeat-parse","output-format","instaparse.gll/text->segment","fexpr__54043","instaparse.repeat/repeat-parse-with-header","header-parser","repeating-parser","header-results","or__4185__auto__","header-result","cljs.core.apply","cljs.core/max-key","instaparse.repeat.get_end","repeat-result","span-meta","instaparse.gll/Failure","G__54049","cljs.core/Keyword","instaparse.repeat/try-repeating-parse-strategy-with-header","start-production","start-rule","parsers","cljs.core/last","cljs.core/not","and__4174__auto__","G__54059","fexpr__54058","instaparse.combinators-source/cat","cljs.core/butlast","instaparse.reduction/raw-non-terminal-reduction","instaparse.repeat/try-repeating-parse-strategy","parser","instaparse.repeat.repeat_parse","instaparse.repeat/used-memory-optimization?","tree","cljs.core/meta"],"sourcesContent":["(ns instaparse.repeat\r\n  (:require [instaparse.gll :as gll\r\n             #?@(:clj [:refer [profile]])]\r\n            [instaparse.combinators-source :as c]\r\n            [instaparse.auto-flatten-seq :as afs]\r\n            [instaparse.viz :as viz]\r\n            [instaparse.reduction :as red]\r\n            [instaparse.failure :as fail])\r\n  #?(:cljs\r\n     (:require-macros [instaparse.gll :refer [profile]])))\r\n\r\n(defn empty-result? [result]\r\n  (or (and (vector? result) (= (count result) 1))\r\n      (and (map? result) (contains? result :tag) (empty? (get result :content)))\r\n      (empty? result)))       \r\n\r\n(def ^:constant failure-signal (gll/->Failure nil nil))\r\n\r\n(defn get-end \r\n  (#?(:clj ^long [parse]\r\n      :cljs ^number [parse])\r\n    (let [[start end] (viz/span parse)]\r\n      (if end (long end) (count parse))))\r\n  (#?(:clj ^long [parse ^long index]\r\n      :cljs ^number [parse ^number index])\r\n    (let [[start end] (viz/span parse)]\r\n      (if end (long end) (+ index (count parse))))))\r\n\r\n(defn parse-from-index [grammar initial-parser text segment index]\r\n  (let [tramp (gll/make-tramp grammar text segment)]\r\n    (gll/push-listener tramp [index initial-parser] (gll/TopListener tramp))\r\n    (gll/run tramp)))\r\n\r\n(defn select-parse\r\n  \"Returns either:\r\n   [a-parse end-index a-list-of-valid-follow-up-parses]\r\n   [a-parse end-index nil] (successfully reached end of text)\r\n   nil (hit a dead-end with this strategy)\"\r\n  [grammar initial-parser text segment index parses]\r\n  ;(clojure.pprint/pprint parses)\r\n  (let [length (count text)]\r\n    (loop [parses (seq parses)]\r\n      (when parses\r\n        (let [parse (first parses)\r\n              [start end] (viz/span parse)\r\n              end (if end end (+ index (count parse)))]\r\n          (cond\r\n            (= end length) [parse end nil]\r\n            :else \r\n            (if-let [follow-ups (seq (parse-from-index grammar initial-parser text segment end))]\r\n              [parse end follow-ups]\r\n              (recur (next parses)))))))))\r\n                                 \r\n(defn repeat-parse-hiccup \r\n  ([grammar initial-parser root-tag text segment]\r\n    (repeat-parse-hiccup grammar initial-parser root-tag text segment 0))\r\n  ([grammar initial-parser root-tag text segment index]\r\n    (let [length (count text)\r\n          first-result (parse-from-index grammar initial-parser text segment index)]\r\n      (loop [index (long index)\r\n             parses (afs/auto-flatten-seq [root-tag])\r\n             \r\n             [parse end follow-ups :as selection]\r\n             (select-parse grammar initial-parser text segment index first-result)]\r\n        (cond\r\n          (nil? selection) failure-signal\r\n          (= index end) failure-signal\r\n          (nil? follow-ups) (gll/safe-with-meta\r\n                              (afs/convert-afs-to-vec \r\n                                (afs/conj-flat parses parse))\r\n                              {:optimize :memory\r\n                               :instaparse.gll/start-index 0\r\n                               :instaparse.gll/end-index length})\r\n          :else (recur (long end)\r\n                       (afs/conj-flat parses parse)\r\n                       (select-parse grammar initial-parser text segment end follow-ups)))))))\r\n\r\n(defn repeat-parse-enlive\r\n  ([grammar initial-parser root-tag text segment]\r\n    (repeat-parse-enlive grammar initial-parser root-tag text segment 0))\r\n  ([grammar initial-parser root-tag text segment index]\r\n    (let [length (count text)\r\n          first-result (parse-from-index grammar initial-parser text segment index)]\r\n      (loop [index (long index)\r\n             parses afs/EMPTY\r\n             \r\n             [parse end follow-ups :as selection]\r\n             (select-parse grammar initial-parser text segment index first-result)]\r\n        (cond\r\n          (nil? selection) failure-signal\r\n          (= index end) failure-signal          \r\n          (nil? follow-ups) (gll/safe-with-meta\r\n                              {:tag root-tag \r\n                               :content (seq (afs/conj-flat parses parse))}\r\n                              {:optimize :memory\r\n                               :instaparse.gll/start-index 0\r\n                               :instaparse.gll/end-index length})\r\n          :else (recur (long end)\r\n                       (afs/conj-flat parses parse)\r\n                       (select-parse grammar initial-parser text segment end follow-ups)))))))\r\n\r\n(defn repeat-parse-no-tag \r\n  ([grammar initial-parser text segment]\r\n    (repeat-parse-no-tag grammar initial-parser text segment 0))\r\n  ([grammar initial-parser text segment index]\r\n    (let [length (count text)\r\n          first-result (parse-from-index grammar initial-parser text segment index)]\r\n      (loop [index (long index)\r\n             parses afs/EMPTY\r\n             \r\n             [parse end follow-ups :as selection]\r\n             (select-parse grammar initial-parser text segment index first-result)]\r\n        (cond\r\n          (nil? selection) failure-signal\r\n          (= index end) failure-signal          \r\n          (nil? follow-ups) (gll/safe-with-meta\r\n                              (afs/conj-flat parses parse)\r\n                              {:optimize :memory\r\n                               :instaparse.gll/start-index 0\r\n                               :instaparse.gll/end-index length})\r\n          :else (recur (long end)\r\n                       (afs/conj-flat parses parse)\r\n                       (select-parse grammar initial-parser text segment end follow-ups)))))))\r\n\r\n(defn repeat-parse \r\n  ([grammar initial-parser output-format text] (repeat-parse-no-tag grammar initial-parser text (gll/text->segment text)))\r\n  ([grammar initial-parser output-format root-tag text]\r\n    {:pre [(#{:hiccup :enlive} output-format)]} \r\n    (cond\r\n      (= output-format :hiccup)\r\n      (repeat-parse-hiccup grammar initial-parser root-tag text (gll/text->segment text))\r\n      (= output-format :enlive)\r\n      (repeat-parse-enlive grammar initial-parser root-tag text (gll/text->segment text)))))\r\n\r\n(defn repeat-parse-with-header\r\n  ([grammar header-parser repeating-parser output-format root-tag text]\r\n    (let [segment (gll/text->segment text)\r\n          length (count text)\r\n          header-results (parse-from-index grammar header-parser text segment 0)]\r\n      (if (or (empty? header-results)\r\n              (:hide header-parser))\r\n        failure-signal\r\n        (let [header-result (apply max-key get-end header-results)\r\n              end (get-end header-result)\r\n              repeat-result (repeat-parse-no-tag grammar (:parser repeating-parser) text segment end)\r\n              span-meta {:optimize :memory\r\n                         :instaparse.gll/start-index 0\r\n                         :instaparse.gll/end-index length}]\r\n          (if (or (instance? instaparse.gll.Failure repeat-result)\r\n                  (and (= (:tag repeating-parser) :star)\r\n                       (empty-result? repeat-result)))\r\n            failure-signal\r\n            (case output-format\r\n              :enlive\r\n              (gll/safe-with-meta\r\n                {:tag root-tag \r\n                 :content\r\n                 (afs/conj-flat (afs/conj-flat afs/EMPTY header-result) repeat-result)}\r\n                span-meta)\r\n              :hiccup\r\n              (gll/safe-with-meta\r\n                (afs/convert-afs-to-vec \r\n                  (afs/conj-flat (afs/conj-flat (afs/auto-flatten-seq [root-tag])\r\n                                                header-result) \r\n                                 repeat-result))\r\n                span-meta)\r\n              (gll/safe-with-meta \r\n                (afs/conj-flat (afs/conj-flat afs/EMPTY header-result) repeat-result)\r\n                span-meta))))))))\r\n    \r\n(defn try-repeating-parse-strategy-with-header\r\n  [grammar text start-production start-rule output-format]\r\n  (gll/profile (gll/clear!))\r\n  (let [parsers (:parsers start-rule)\r\n        repeating-parser (last parsers)]\r\n    (if\r\n      (not (and (= (:tag start-rule) :cat)\r\n                (#{:star :plus} (:tag repeating-parser))\r\n                (not (:hide repeating-parser))\r\n                (not (:hide (:parser repeating-parser)))))\r\n      failure-signal\r\n      (let [header-parser (apply c/cat (butlast parsers))]\r\n        (if (= (:red start-rule) red/raw-non-terminal-reduction)\r\n          (repeat-parse-with-header grammar header-parser repeating-parser nil start-production text)\r\n          (repeat-parse-with-header grammar header-parser repeating-parser output-format start-production text))))))\r\n  \r\n(defn try-repeating-parse-strategy\r\n  [parser text start-production]\r\n  (let [grammar (:grammar parser)\r\n        output-format (:output-format parser)\r\n        start-rule (get grammar start-production)]\r\n    (profile (gll/clear!))\r\n    (cond\r\n      (= (:hide start-rule) true) failure-signal\r\n      (= (:red start-rule) red/raw-non-terminal-reduction)\r\n      (cond\r\n        (= (:tag start-rule) :star)\r\n        (repeat-parse grammar (:parser start-rule) output-format text)\r\n        (= (:tag start-rule) :plus)\r\n        (let [result (repeat-parse grammar (:parser start-rule) output-format text)]\r\n          (if (empty-result? result)\r\n            failure-signal\r\n            result))\r\n        :else (try-repeating-parse-strategy-with-header \r\n                grammar text start-production start-rule output-format))\r\n              \r\n      (= (:tag start-rule) :star)\r\n      (repeat-parse grammar (:parser start-rule) output-format start-production text)\r\n      (= (:tag start-rule) :plus)      \r\n      (let [result (repeat-parse grammar (:parser start-rule) output-format start-production text)]\r\n        (if (empty-result? result)\r\n          failure-signal\r\n          result))\r\n      \r\n      :else (try-repeating-parse-strategy-with-header \r\n                grammar text start-production start-rule output-format))))\r\n\r\n(defn used-memory-optimization? [tree]\r\n  (= :memory (-> tree meta :optimize)))"]}