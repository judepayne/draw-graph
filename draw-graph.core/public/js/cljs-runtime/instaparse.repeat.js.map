{"version":3,"sources":["instaparse/repeat.cljc"],"mappings":"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","names":["instaparse.repeat/empty-result?","result","cljs.core/vector?","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/count","cljs.core/map?","cljs.core/contains?","cljs.core/empty?","cljs.core.get.cljs$core$IFn$_invoke$arity$2","instaparse.repeat/failure-signal","instaparse.gll/->Failure","var_args","G__49563","instaparse.repeat/get-end","js/Error","parse","vec__49564","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","start","end","instaparse.viz/span","cljs.core/long","index","vec__49568","instaparse.repeat/parse-from-index","grammar","initial-parser","text","segment","tramp","instaparse.gll.make_tramp.cljs$core$IFn$_invoke$arity$3","instaparse.gll/push-listener","instaparse.gll/TopListener","instaparse.gll.run.cljs$core$IFn$_invoke$arity$1","instaparse.repeat/select-parse","parses","length","cljs.core/seq","vec__49572","cljs.core/first","temp__5718__auto__","follow-ups","cljs.core/next","G__49576","instaparse.repeat/repeat-parse-hiccup","root-tag","instaparse.repeat.repeat_parse_hiccup.cljs$core$IFn$_invoke$arity$6","first-result","G__49582","vec__49583","vec__49594","instaparse.auto-flatten-seq/auto-flatten-seq","selection","instaparse.gll/safe-with-meta","instaparse.auto-flatten-seq/convert-afs-to-vec","instaparse.auto-flatten-seq/conj-flat","G__49599","instaparse.repeat/repeat-parse-enlive","instaparse.repeat.repeat_parse_enlive.cljs$core$IFn$_invoke$arity$6","G__49613","vec__49614","vec__49625","instaparse.auto-flatten-seq/EMPTY","G__49635","instaparse.repeat/repeat-parse-no-tag","instaparse.repeat.repeat_parse_no_tag.cljs$core$IFn$_invoke$arity$5","G__49639","vec__49643","vec__49659","G__49669","instaparse.repeat/repeat-parse","output-format","instaparse.repeat.repeat_parse_no_tag.cljs$core$IFn$_invoke$arity$4","instaparse.gll/text->segment","fexpr__49681","instaparse.repeat.repeat_parse_hiccup.cljs$core$IFn$_invoke$arity$5","instaparse.repeat.repeat_parse_enlive.cljs$core$IFn$_invoke$arity$5","instaparse.repeat/repeat-parse-with-header","header-parser","repeating-parser","header-results","or__4131__auto__","header-result","cljs.core.apply.cljs$core$IFn$_invoke$arity$3","cljs.core/max-key","instaparse.repeat.get_end.cljs$core$IFn$_invoke$arity$1","repeat-result","span-meta","instaparse.gll/Failure","G__49682","cljs.core/Keyword","instaparse.repeat/try-repeating-parse-strategy-with-header","start-production","start-rule","parsers","cljs.core/last","cljs.core/not","and__4120__auto__","G__49688","fexpr__49687","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","instaparse.combinators-source/cat","cljs.core/butlast","instaparse.reduction/raw-non-terminal-reduction","instaparse.repeat/try-repeating-parse-strategy","parser","instaparse.repeat.repeat_parse.cljs$core$IFn$_invoke$arity$4","instaparse.repeat.repeat_parse.cljs$core$IFn$_invoke$arity$5","instaparse.repeat/used-memory-optimization?","tree","cljs.core/meta"],"sourcesContent":["(ns instaparse.repeat\r\n  (:require [instaparse.gll :as gll\r\n             #?@(:clj [:refer [profile]])]\r\n            [instaparse.combinators-source :as c]\r\n            [instaparse.auto-flatten-seq :as afs]\r\n            [instaparse.viz :as viz]\r\n            [instaparse.reduction :as red]\r\n            [instaparse.failure :as fail])\r\n  #?(:cljs\r\n     (:require-macros [instaparse.gll :refer [profile]])))\r\n\r\n(defn empty-result? [result]\r\n  (or (and (vector? result) (= (count result) 1))\r\n      (and (map? result) (contains? result :tag) (empty? (get result :content)))\r\n      (empty? result)))       \r\n\r\n(def ^:constant failure-signal (gll/->Failure nil nil))\r\n\r\n(defn get-end \r\n  (#?(:clj ^long [parse]\r\n      :cljs ^number [parse])\r\n    (let [[start end] (viz/span parse)]\r\n      (if end (long end) (count parse))))\r\n  (#?(:clj ^long [parse ^long index]\r\n      :cljs ^number [parse ^number index])\r\n    (let [[start end] (viz/span parse)]\r\n      (if end (long end) (+ index (count parse))))))\r\n\r\n(defn parse-from-index [grammar initial-parser text segment index]\r\n  (let [tramp (gll/make-tramp grammar text segment)]\r\n    (gll/push-listener tramp [index initial-parser] (gll/TopListener tramp))\r\n    (gll/run tramp)))\r\n\r\n(defn select-parse\r\n  \"Returns either:\r\n   [a-parse end-index a-list-of-valid-follow-up-parses]\r\n   [a-parse end-index nil] (successfully reached end of text)\r\n   nil (hit a dead-end with this strategy)\"\r\n  [grammar initial-parser text segment index parses]\r\n  ;(clojure.pprint/pprint parses)\r\n  (let [length (count text)]\r\n    (loop [parses (seq parses)]\r\n      (when parses\r\n        (let [parse (first parses)\r\n              [start end] (viz/span parse)\r\n              end (if end end (+ index (count parse)))]\r\n          (cond\r\n            (= end length) [parse end nil]\r\n            :else \r\n            (if-let [follow-ups (seq (parse-from-index grammar initial-parser text segment end))]\r\n              [parse end follow-ups]\r\n              (recur (next parses)))))))))\r\n                                 \r\n(defn repeat-parse-hiccup \r\n  ([grammar initial-parser root-tag text segment]\r\n    (repeat-parse-hiccup grammar initial-parser root-tag text segment 0))\r\n  ([grammar initial-parser root-tag text segment index]\r\n    (let [length (count text)\r\n          first-result (parse-from-index grammar initial-parser text segment index)]\r\n      (loop [index (long index)\r\n             parses (afs/auto-flatten-seq [root-tag])\r\n             \r\n             [parse end follow-ups :as selection]\r\n             (select-parse grammar initial-parser text segment index first-result)]\r\n        (cond\r\n          (nil? selection) failure-signal\r\n          (= index end) failure-signal\r\n          (nil? follow-ups) (gll/safe-with-meta\r\n                              (afs/convert-afs-to-vec \r\n                                (afs/conj-flat parses parse))\r\n                              {:optimize :memory\r\n                               :instaparse.gll/start-index 0\r\n                               :instaparse.gll/end-index length})\r\n          :else (recur (long end)\r\n                       (afs/conj-flat parses parse)\r\n                       (select-parse grammar initial-parser text segment end follow-ups)))))))\r\n\r\n(defn repeat-parse-enlive\r\n  ([grammar initial-parser root-tag text segment]\r\n    (repeat-parse-enlive grammar initial-parser root-tag text segment 0))\r\n  ([grammar initial-parser root-tag text segment index]\r\n    (let [length (count text)\r\n          first-result (parse-from-index grammar initial-parser text segment index)]\r\n      (loop [index (long index)\r\n             parses afs/EMPTY\r\n             \r\n             [parse end follow-ups :as selection]\r\n             (select-parse grammar initial-parser text segment index first-result)]\r\n        (cond\r\n          (nil? selection) failure-signal\r\n          (= index end) failure-signal          \r\n          (nil? follow-ups) (gll/safe-with-meta\r\n                              {:tag root-tag \r\n                               :content (seq (afs/conj-flat parses parse))}\r\n                              {:optimize :memory\r\n                               :instaparse.gll/start-index 0\r\n                               :instaparse.gll/end-index length})\r\n          :else (recur (long end)\r\n                       (afs/conj-flat parses parse)\r\n                       (select-parse grammar initial-parser text segment end follow-ups)))))))\r\n\r\n(defn repeat-parse-no-tag \r\n  ([grammar initial-parser text segment]\r\n    (repeat-parse-no-tag grammar initial-parser text segment 0))\r\n  ([grammar initial-parser text segment index]\r\n    (let [length (count text)\r\n          first-result (parse-from-index grammar initial-parser text segment index)]\r\n      (loop [index (long index)\r\n             parses afs/EMPTY\r\n             \r\n             [parse end follow-ups :as selection]\r\n             (select-parse grammar initial-parser text segment index first-result)]\r\n        (cond\r\n          (nil? selection) failure-signal\r\n          (= index end) failure-signal          \r\n          (nil? follow-ups) (gll/safe-with-meta\r\n                              (afs/conj-flat parses parse)\r\n                              {:optimize :memory\r\n                               :instaparse.gll/start-index 0\r\n                               :instaparse.gll/end-index length})\r\n          :else (recur (long end)\r\n                       (afs/conj-flat parses parse)\r\n                       (select-parse grammar initial-parser text segment end follow-ups)))))))\r\n\r\n(defn repeat-parse \r\n  ([grammar initial-parser output-format text] (repeat-parse-no-tag grammar initial-parser text (gll/text->segment text)))\r\n  ([grammar initial-parser output-format root-tag text]\r\n    {:pre [(#{:hiccup :enlive} output-format)]} \r\n    (cond\r\n      (= output-format :hiccup)\r\n      (repeat-parse-hiccup grammar initial-parser root-tag text (gll/text->segment text))\r\n      (= output-format :enlive)\r\n      (repeat-parse-enlive grammar initial-parser root-tag text (gll/text->segment text)))))\r\n\r\n(defn repeat-parse-with-header\r\n  ([grammar header-parser repeating-parser output-format root-tag text]\r\n    (let [segment (gll/text->segment text)\r\n          length (count text)\r\n          header-results (parse-from-index grammar header-parser text segment 0)]\r\n      (if (or (empty? header-results)\r\n              (:hide header-parser))\r\n        failure-signal\r\n        (let [header-result (apply max-key get-end header-results)\r\n              end (get-end header-result)\r\n              repeat-result (repeat-parse-no-tag grammar (:parser repeating-parser) text segment end)\r\n              span-meta {:optimize :memory\r\n                         :instaparse.gll/start-index 0\r\n                         :instaparse.gll/end-index length}]\r\n          (if (or (instance? instaparse.gll.Failure repeat-result)\r\n                  (and (= (:tag repeating-parser) :star)\r\n                       (empty-result? repeat-result)))\r\n            failure-signal\r\n            (case output-format\r\n              :enlive\r\n              (gll/safe-with-meta\r\n                {:tag root-tag \r\n                 :content\r\n                 (afs/conj-flat (afs/conj-flat afs/EMPTY header-result) repeat-result)}\r\n                span-meta)\r\n              :hiccup\r\n              (gll/safe-with-meta\r\n                (afs/convert-afs-to-vec \r\n                  (afs/conj-flat (afs/conj-flat (afs/auto-flatten-seq [root-tag])\r\n                                                header-result) \r\n                                 repeat-result))\r\n                span-meta)\r\n              (gll/safe-with-meta \r\n                (afs/conj-flat (afs/conj-flat afs/EMPTY header-result) repeat-result)\r\n                span-meta))))))))\r\n    \r\n(defn try-repeating-parse-strategy-with-header\r\n  [grammar text start-production start-rule output-format]\r\n  (gll/profile (gll/clear!))\r\n  (let [parsers (:parsers start-rule)\r\n        repeating-parser (last parsers)]\r\n    (if\r\n      (not (and (= (:tag start-rule) :cat)\r\n                (#{:star :plus} (:tag repeating-parser))\r\n                (not (:hide repeating-parser))\r\n                (not (:hide (:parser repeating-parser)))))\r\n      failure-signal\r\n      (let [header-parser (apply c/cat (butlast parsers))]\r\n        (if (= (:red start-rule) red/raw-non-terminal-reduction)\r\n          (repeat-parse-with-header grammar header-parser repeating-parser nil start-production text)\r\n          (repeat-parse-with-header grammar header-parser repeating-parser output-format start-production text))))))\r\n  \r\n(defn try-repeating-parse-strategy\r\n  [parser text start-production]\r\n  (let [grammar (:grammar parser)\r\n        output-format (:output-format parser)\r\n        start-rule (get grammar start-production)]\r\n    (profile (gll/clear!))\r\n    (cond\r\n      (= (:hide start-rule) true) failure-signal\r\n      (= (:red start-rule) red/raw-non-terminal-reduction)\r\n      (cond\r\n        (= (:tag start-rule) :star)\r\n        (repeat-parse grammar (:parser start-rule) output-format text)\r\n        (= (:tag start-rule) :plus)\r\n        (let [result (repeat-parse grammar (:parser start-rule) output-format text)]\r\n          (if (empty-result? result)\r\n            failure-signal\r\n            result))\r\n        :else (try-repeating-parse-strategy-with-header \r\n                grammar text start-production start-rule output-format))\r\n              \r\n      (= (:tag start-rule) :star)\r\n      (repeat-parse grammar (:parser start-rule) output-format start-production text)\r\n      (= (:tag start-rule) :plus)      \r\n      (let [result (repeat-parse grammar (:parser start-rule) output-format start-production text)]\r\n        (if (empty-result? result)\r\n          failure-signal\r\n          result))\r\n      \r\n      :else (try-repeating-parse-strategy-with-header \r\n                grammar text start-production start-rule output-format))))\r\n\r\n(defn used-memory-optimization? [tree]\r\n  (= :memory (-> tree meta :optimize)))"]}