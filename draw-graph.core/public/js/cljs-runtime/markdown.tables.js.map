{"version":3,"sources":["markdown/tables.cljc"],"mappings":"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","names":["markdown.tables/parse-table-row","text","p1__40922#","cljs.core._EQ_","cljs.core/first","cljs.core.apply","cljs.core/str","cljs.core/rest","clojure.string/trim","p1__40923#","clojure.string.split","cljs.core.map","p1__40924#","cljs.core/identity","markdown.tables/table-row->str","row-data","is-header?","cljs.core.reduce","row","col","alignment-str","cljs.core/name","markdown.tables/table->str","table","table-data","cljs.core.map_indexed","cljs.core/vector","alignment-seq","table-acc","row-idx","cljs.core.mapv","cljs.core/merge","cljs.core/second","is-first-row?","is-last-row?","cljs.core/count","markdown.tables/divider-seq->alignment","divider-seq","divider","cljs.core/re-find","markdown.tables/table","state","table-row-re","table-divider-re","is-table-row?","is-table-header?","cljs.core/not","cljs.core.get_in","is-table-divider?","and__4174__auto__","header-seq","cljs.core/assoc-in","cljs.core.update_in","cljs.core.fnil","cljs.core/conj","cljs.core/vec","row-seq","out","cljs.core/empty?","cljs.core.dissoc"],"sourcesContent":["(ns markdown.tables\n  (:require [clojure.string :as string]))\n\n(defn parse-table-row [text]\n  (->> text\n       (#(if (= (first %) \\|)\n          (apply str (rest %))\n          %))\n       (string/trim)\n       (#(string/split % #\"\\|\"))\n       (map string/trim)\n       (map #(identity {:text %}))))\n\n(defn table-row->str [row-data is-header?]\n  (reduce\n    (fn [row col]\n      (let [alignment-str (when (:alignment col)\n                            (str \" align='\" (name (:alignment col)) \"'\"))]\n        (if is-header?\n          (str row\n               \"<th\" alignment-str \">\" (:text col) \"</th>\")\n          (str row\n               \"<td\" alignment-str \">\" (:text col) \"</td>\"))))\n    \"\"\n    row-data))\n\n(defn table->str [table]\n  (let [table-data (map-indexed vector (:data table))\n        alignment-seq (:alignment-seq table)]\n    (str \"<table>\"\n         (reduce\n           (fn [table-acc row]\n             (let [row-idx (first row)\n                   row-data (mapv merge (second row) alignment-seq)\n                   is-header? (= row-idx 0)\n                   is-first-row? (= row-idx 1)\n                   is-last-row? (= row-idx (dec (count table-data)))]\n               (str\n                 table-acc\n                 (cond\n                   is-header?\n                   \"<thead>\"\n                   is-first-row?\n                   \"<tbody>\")\n                 \"<tr>\"\n                 (table-row->str row-data is-header?)\n                 \"</tr>\"\n                 (cond\n                   is-header?\n                   \"</thead>\"\n                   is-last-row?\n                   \"</tbody>\"))))\n           \"\"\n           table-data)\n         \"</table>\")))\n\n(defn divider-seq->alignment [divider-seq]\n  (mapv (fn [divider]\n          (cond\n            (= (re-find #\"^:-+\" (:text divider))\n               (:text divider))\n            (identity {:alignment :left})\n\n            (= (re-find #\"^-+:\" (:text divider))\n               (:text divider))\n            (identity {:alignment :right})\n\n            (= (re-find #\"^:-+:\" (:text divider))\n               (:text divider))\n            (identity {:alignment :center})\n\n            :else\n            nil))\n        divider-seq))\n\n(defn table [text state]\n  (let [table-row-re (re-find #\"\\|(?: [\\S ]+ \\|)+\" text)\n        table-divider-re (re-find #\"\\|(?: :?-+:? \\|)+\" text)\n        is-table-row? (= table-row-re text)\n        is-table-header?\n        (and is-table-row?\n             (not (get-in state [:table :in-table-body?])))\n        is-table-divider?\n        (and (= table-divider-re text)\n             (get-in state [:table :in-table-body?])\n             (get-in state [:table :is-prev-header?]))]\n    (cond\n      is-table-header?\n      (let [header-seq (parse-table-row text)]\n        [\"\" (-> state\n                (assoc-in [:table :is-prev-header?] true)\n                (assoc-in [:table :in-table-body?] true)\n                (update-in [:table :data] (fnil conj []) (vec header-seq)))])\n\n      is-table-divider?\n      (let [divider-seq (parse-table-row text)]\n        [\"\" (-> state\n                (assoc-in [:table :is-prev-header?] false)\n                (assoc-in [:table :alignment-seq]\n                          (divider-seq->alignment divider-seq)))])\n\n      is-table-row?\n      (let [row-seq (parse-table-row text)]\n        [\"\" (-> state\n                (assoc-in [:table :is-prev-header?] false)\n                (update-in [:table :data] (fnil conj []) (vec row-seq)))])\n\n      :else\n      (let [out (if (empty? (get-in state [:table :data]))\n                  text\n                  (str (table->str (:table state)) text))]\n        [out (dissoc state :table)]))))"]}