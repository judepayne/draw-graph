{"version":3,"sources":["markdown/tables.cljc"],"mappings":"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","names":["markdown.tables/parse-table-row","text","fexpr__36267","p1__36262#","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/first","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/str","cljs.core/rest","clojure.string/trim","G__36266","fexpr__36265","p1__36263#","clojure.string.split.cljs$core$IFn$_invoke$arity$2","cljs.core.map.cljs$core$IFn$_invoke$arity$2","p1__36264#","cljs.core/identity","markdown.tables/table-row->str","row-data","is-header?","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","row","col","alignment-str","cljs.core/name","markdown.tables/table->str","table","table-data","cljs.core.map_indexed.cljs$core$IFn$_invoke$arity$2","cljs.core/vector","alignment-seq","table-acc","row-idx","cljs.core.mapv.cljs$core$IFn$_invoke$arity$3","cljs.core/merge","cljs.core/second","is-first-row?","is-last-row?","cljs.core/count","markdown.tables/divider-seq->alignment","divider-seq","cljs.core.mapv.cljs$core$IFn$_invoke$arity$2","divider","cljs.core/re-find","markdown.tables/table","state","table-row-re","table-divider-re","is-table-row?","is-table-header?","cljs.core/not","cljs.core.get_in.cljs$core$IFn$_invoke$arity$2","is-table-divider?","and__4120__auto__","header-seq","cljs.core/assoc-in","cljs.core.update_in.cljs$core$IFn$_invoke$arity$4","cljs.core.fnil.cljs$core$IFn$_invoke$arity$2","cljs.core/conj","cljs.core/vec","row-seq","out","cljs.core/empty?","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2"],"sourcesContent":["(ns markdown.tables\n  (:require [clojure.string :as string]))\n\n(defn parse-table-row [text]\n  (->> text\n       (#(if (= (first %) \\|)\n          (apply str (rest %))\n          %))\n       (string/trim)\n       (#(string/split % #\"\\|\"))\n       (map string/trim)\n       (map #(identity {:text %}))))\n\n(defn table-row->str [row-data is-header?]\n  (reduce\n    (fn [row col]\n      (let [alignment-str (when (:alignment col)\n                            (str \" align='\" (name (:alignment col)) \"'\"))]\n        (if is-header?\n          (str row\n               \"<th\" alignment-str \">\" (:text col) \"</th>\")\n          (str row\n               \"<td\" alignment-str \">\" (:text col) \"</td>\"))))\n    \"\"\n    row-data))\n\n(defn table->str [table]\n  (let [table-data (map-indexed vector (:data table))\n        alignment-seq (:alignment-seq table)]\n    (str \"<table>\"\n         (reduce\n           (fn [table-acc row]\n             (let [row-idx (first row)\n                   row-data (mapv merge (second row) alignment-seq)\n                   is-header? (= row-idx 0)\n                   is-first-row? (= row-idx 1)\n                   is-last-row? (= row-idx (dec (count table-data)))]\n               (str\n                 table-acc\n                 (cond\n                   is-header?\n                   \"<thead>\"\n                   is-first-row?\n                   \"<tbody>\")\n                 \"<tr>\"\n                 (table-row->str row-data is-header?)\n                 \"</tr>\"\n                 (cond\n                   is-header?\n                   \"</thead>\"\n                   is-last-row?\n                   \"</tbody>\"))))\n           \"\"\n           table-data)\n         \"</table>\")))\n\n(defn divider-seq->alignment [divider-seq]\n  (mapv (fn [divider]\n          (cond\n            (= (re-find #\"^:-+\" (:text divider))\n               (:text divider))\n            (identity {:alignment :left})\n\n            (= (re-find #\"^-+:\" (:text divider))\n               (:text divider))\n            (identity {:alignment :right})\n\n            (= (re-find #\"^:-+:\" (:text divider))\n               (:text divider))\n            (identity {:alignment :center})\n\n            :else\n            nil))\n        divider-seq))\n\n(defn table [text state]\n  (let [table-row-re (re-find #\"\\|(?: [\\S ]+ \\|)+\" text)\n        table-divider-re (re-find #\"\\|(?: :?-+:? \\|)+\" text)\n        is-table-row? (= table-row-re text)\n        is-table-header?\n        (and is-table-row?\n             (not (get-in state [:table :in-table-body?])))\n        is-table-divider?\n        (and (= table-divider-re text)\n             (get-in state [:table :in-table-body?])\n             (get-in state [:table :is-prev-header?]))]\n    (cond\n      is-table-header?\n      (let [header-seq (parse-table-row text)]\n        [\"\" (-> state\n                (assoc-in [:table :is-prev-header?] true)\n                (assoc-in [:table :in-table-body?] true)\n                (update-in [:table :data] (fnil conj []) (vec header-seq)))])\n\n      is-table-divider?\n      (let [divider-seq (parse-table-row text)]\n        [\"\" (-> state\n                (assoc-in [:table :is-prev-header?] false)\n                (assoc-in [:table :alignment-seq]\n                          (divider-seq->alignment divider-seq)))])\n\n      is-table-row?\n      (let [row-seq (parse-table-row text)]\n        [\"\" (-> state\n                (assoc-in [:table :is-prev-header?] false)\n                (update-in [:table :data] (fnil conj []) (vec row-seq)))])\n\n      :else\n      (let [out (if (empty? (get-in state [:table :data]))\n                  text\n                  (str (table->str (:table state)) text))]\n        [out (dissoc state :table)]))))"]}