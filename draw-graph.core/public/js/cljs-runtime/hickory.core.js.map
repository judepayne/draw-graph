{"version":3,"sources":["hickory/core.cljs"],"mappings":";;;;;AASA,AAAA;AAAA;;;;;AAAA,AAAaM;;AAAb;;;;;AAAA,AAGGJ,AAAWK;AAHd,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAGcA,AAAAA;AAHd,AAGcA,AAAAA;;AAHd,AAAAP,AAAA,AAAA,AAAA,AAAA,AAGcO,AAAAA;AAHdN,AAAA,AAAAC,AAAA,AAAAC,AAAAH;AAAA,AAAA,AAAA,AAAA,AAAAC,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AAGcM,AAAAA;;AAHd,AAAAH,AAAA,AAAAF,AAAA;AAAA,AAAA,AAAA,AAAA,AAAAE,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AAGcG,AAAAA;;AAHd,AAAA,AAAAF,AAAA,AAGcE;;;;;;AAHd,AAQA,AAAA;AAAA;;;;;;;;;;;;;;AAAA,AAAaE;;AAAb;;;;;AAAA,AAYGD,AAAYD;AAZf,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAYeA,AAAAA;AAZf,AAYeA,AAAAA;;AAZf,AAAAP,AAAA,AAAA,AAAA,AAAA,AAYeO,AAAAA;AAZfN,AAAA,AAAAO,AAAA,AAAAL,AAAAH;AAAA,AAAA,AAAA,AAAA,AAAAC,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AAYeM,AAAAA;;AAZf,AAAAH,AAAA,AAAAI,AAAA;AAAA,AAAA,AAAA,AAAA,AAAAJ,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AAYeG,AAAAA;;AAZf,AAAA,AAAAF,AAAA,AAYeE;;;;;;AAZf,AAiBA,AAAA,AAAMG,AACHC;AADH,AAEE,AAAMC,AAAQ,AAAA,AAAKD;;AAErB,AAAKE,AAAU,AAAA,AAACH;AAChB,AAAKI,AAAQ,AAAA,AAACJ;AACd,AAAKK,AAAS,AAAA,AAACL;AACf,AAAKM,AAAa,AAAA,AAACN;AACnB,AAAKO,AAAQ,AAAA,AAACP;AACd,AAAKQ,AAAK,AAAA,AAACR;AAEX,AAAA,AAAMS,AACHC;AADH,AAEE,AAAA,AAAA,AAAA,AAAAC,AAAaD;;AAAb,AAAA,AAAA,AAAaA,AAEX,AAAOE;AAAP,AAAA,AAAA,AAAOA;AAAP,AAAc,AAACC,AAAUD;;;AAE7B,AAACH,AAAyBK;AAE1B,AAAM,AAAAC;AAAN,AACE,AAACN,AAAyBM;;AAD5B;AAGA,AAAM,AAAAC;AAAN,AACE,AAACP,AAAyBO;;AAD5B;AAGA,AAAA,AAAMC,AACHC;AADH,AAEE,AAAMC,AAAK,AAAA,AAAMD;AACXE,AAAS,AAAA,AAAMF;AACfG,AAAS,AAAA,AAAMH;AAFrB,AAGE,AAAI,AAAK,AAACI,AAAOF;AACf,AAAA,AAACG,AAAoDJ,AAAKC,AAASC;;AACnE,AAAA,AAAA,AAAkBF;;;AAExB,AAAA,AAAA,AAAAK,AAAA5B,AAAA,AAAA;;AAAA,AAAA6B,AAAAjC;AAAAkC,AAAA;AAAAC,AAEE;AAAY9B;AAAZ,AAAkB,AAAA+B,AAAOG;AAAPF,AAAS,AAAA,AAAMhC;AAAf,AAAA,AAAA,AAAA+B,AAAAA,AAAAC,AAAAD,AAAAC,AACE1B,AAAAA;AADF,AACa,AAAC6B,AAAyB,AAAA,AAAMnC,AAChC,AAAA,AAAMA;;AAFnB,AAAA,AAAA+B,AAAAA,AAAAC,AAAAD,AAAAC,AAGEzB,AAAAA;AAAQ,AAAA,AAAA,AAAY,AAAA,AAAMP;;AAH5B,AAAA,AAAA+B,AAAAA,AAAAC,AAAAD,AAAAC,AAIExB,AAAAA;AAAS,AAAC4B,AAAIzC,AAAU,AAAA,AAAMK;;AAJhC,AAAA,AAAA+B,AAAAA,AAAAC,AAAAD,AAAAC,AAKEvB,AAAAA;AAAa,AAACW,AAAepB;;AAL/B,AAAA,AAAA+B,AAAAA,AAAAC,AAAAD,AAAAC,AAkBEtB,AAAAA;AAAQ,AAAM2B,AAAI,AAACF,AAAyB,AAAA,AAAMnC;AAA1C,AACE,AAAA,AAACsC,AAAQ,AAAA,AAACC,AAAQF,AACA,AAAA,AAACC,AAAQ,AAACF,AAAIzC,AAAU,AAAA,AAAMK,AAC/B,AAAI,AAACwC,AAAAA,AAAAA,AAA0BH,AAAAA,AAC7B,AAAA,AAACD;AAADK;AAAA,AAAM,AAAAA,AAAA;;AAAqB,AAAA,AAAMzC,AACjC,AAACoC,AAAIzC,AAAU,AAAA,AAAMK;;AAvBpD,AAAA,AAAA+B,AAAAA,AAAAC,AAAAD,AAAAC,AAwBErB,AAAAA;AAAK,AAAC+B,AAAkB,AAAA,AAAM1C;;AAxBhC,AAAA,AAAAiC,AAAA,AAAA,AAAAD;;;;;;;;;AAFpB,AAAA,AAAAL,AAAAC,AAAAC,AAAAC;AA4BA,AAAA,AAAA,AAAAH,AAAAzB,AAAA,AAAA;;AAAA,AAAAyC,AAAA1C;AAAA2C,AAAA;AAAAC,AAEE;AAAa7C;AAAb,AAAmB,AAAA8C,AAAOZ;AAAPa,AAAS,AAAA,AAAM/C;AAAf,AAAA,AAAA,AAAA8C,AAAAA,AAAAC,AAAAD,AAAAC,AACEzC,AAAAA;AADF,AACa,AAAC6B,AAAyB,AAAA,AAAMnC,AAAc,AAAA,AAAMA;;AADjE,AAAA,AAAA8C,AAAAA,AAAAC,AAAAD,AAAAC,AAEExC,AAAAA;AAFF,AAAA,AAAA,AAAA,AAAA,AAGqB,AAAA,AAAMP;;AAH3B,AAAA,AAAA8C,AAAAA,AAAAC,AAAAD,AAAAC,AAIEvC,AAAAA;AAJF,AAAA,AAAA,AAAA,AAKqB,AAACwC,AACC,AAAA,AAACV,AAAQ,AAACF,AAAInC,AACA,AAAA,AAAMD;;AAP3C,AAAA,AAAA8C,AAAAA,AAAAC,AAAAD,AAAAC,AAQEtC,AAAAA;AARF,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAS8B,AAAA,AAAMT,AACF,AAAA,AAAMA,AACN,AAAA,AAAMA;;AAXxC,AAAA,AAAA8C,AAAAA,AAAAC,AAAAD,AAAAC,AAYErC,AAAAA;AAZF,AAAA,AAAA,AAAA,AAAA,AAAA,AAakB,AAACsC,AAAU,AAAA,AAACV,AAAQ,AAACF,AAAInC,AAAW,AAAA,AAAMD,AAC5C,AAACmC,AAAyB,AAAA,AAAMnC,AAC5B,AAACgD,AACC,AAAA,AAACV,AAAQ,AAACF,AAAInC,AACA,AAAA,AAAMD;;AAjB1C,AAAA,AAAA8C,AAAAA,AAAAC,AAAAD,AAAAC,AAkBEpC,AAAAA;AAAK,AAAA,AAAMX;;AAlBb,AAAA,AAAAiC,AAAA,AAAA,AAAAc;;;;;;;;;AAFrB,AAAA,AAAApB,AAAAgB,AAAAC,AAAAC;AAsBA,AAAA,AAAMI,AACHC;AADH,AAGE,AAAAC,AAAmB,AAACE,AAAO,AAAAC,AAAI,AAAA,AAACC,AAA8BL;AAAnC,AAAA,AAAAI;AAAAA;;AACI,AAAA,AAACC,AAA8BL;;;AAD9D,AAAA,AAAAC;AAAA,AAAA,AAAAA,AAAWC;AAAX,AAEE,AAAA,AAACG,AAA0EH;;AAF7E;;;AAIF,AAAA,AAAMI,AACHC;AADH,AAEE,AAAc,AAAA,AAAMA,AAAiBA;;AAEvC,AAAA,AAAMC,AACHR;AADH,AAEE,AAAI,AAAAS;AACF,AAAA,AAAkB,AAAAA,AAAgBT;;AADpC;;;AAGF;;;AAAA,AAAMU,AAEHV;AAFH,AAIE,AAAMW,AAAI,AAAA,AAAqBC;AACzBC,AAAW,AAAA,AAAMF;AADvB,AAEE,AAAU,AAACZ,AAAgBC;AAA3B;AAAA,AACE,AAACM,AAAUO;;;AACb,AAAAZ,AAAoB,AAACc,AAAM,AAAA,AAAA,AAAMJ;AAAjC,AAAA,AAAAV;AAAA,AAAA,AAAAA,AAAWa;AAAX,AACE,AAAM,AAACvC,AAAO,AAAA,AAAMuC;AAApB,AACI,AAACR,AAAUQ;;AADf;;AADF;;AAGA,AAAQH,AAAIX;;AACZW;;AAEJ;;;;;;;;;;;;;;;;;AAAA,AAAMK,AAgBHhB;AAhBH,AAiBE,AAAAI,AAAI,AAACI,AAAyBR;AAA9B,AAAA,AAAAI;AAAAA;;AAAiC,AAACM,AAAqBV;;;AAEzD;;;;;AAAA,AAAMiB,AAIHjB;AAJH,AAKE,AAAA,AAAA,AAAM,AAACgB,AAAMhB","names":["x__4433__auto__","m__4434__auto__","hickory.core/as-hiccup","goog/typeOf","m__4431__auto__","cljs.core/missing-protocol","hickory.core/HiccupRepresentable","this","hickory.core/as-hickory","hickory.core/HickoryRepresentable","hickory.core/node-type","type","js/Node","hickory.core/Attribute","hickory.core/Comment","hickory.core/Document","hickory.core/DocumentType","hickory.core/Element","hickory.core/Text","hickory.core/extend-type-with-seqable","t","cljs.core/PROTOCOL_SENTINEL","array","cljs.core.array_seq.cljs$core$IFn$_invoke$arity$1","js/NodeList","js/NamedNodeMap","js/MozNamedAttrMap","hickory.core/format-doctype","dt","name","publicId","systemId","cljs.core/empty?","goog.string/format","goog.object/set","G__35905","G__35906","G__35907","pred__35913","expr__35914","js/Error","cljs.core/=","hickory.utils/lower-case-keyword","cljs.core.map.cljs$core$IFn$_invoke$arity$2","tag","cljs.core.into.cljs$core$IFn$_invoke$arity$2","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","hickory.utils/unescapable-content","p1__35897#","hickory.utils/html-escape","G__35930","G__35931","G__35932","pred__35934","expr__35935","cljs.core/not-empty","hickory.core/extract-doctype","s","temp__5720__auto__","doctype","cljs.core/second","or__4131__auto__","cljs.core/re-find","hickory.core/remove-el","el","hickory.core/parse-dom-with-domparser","js/DOMParser","hickory.core/parse-dom-with-write","doc","js/document.implementation","doctype-el","title-el","cljs.core/first","hickory.core/parse","hickory.core/parse-fragment"],"sourcesContent":["(ns hickory.core\n  (:require [hickory.utils :as utils]\n            [clojure.zip :as zip]\n            [goog.string :as gstring]))\n\n;;\n;; Protocols\n;;\n\n(defprotocol HiccupRepresentable\n  \"Objects that can be represented as Hiccup nodes implement this protocol in\n   order to make the conversion.\"\n  (as-hiccup [this]\n    \"Converts the node given into a hiccup-format data structure. The\n     node must have an implementation of the HiccupRepresentable\n     protocol; nodes created by parse or parse-fragment already do.\"))\n\n(defprotocol HickoryRepresentable\n  \"Objects that can be represented as HTML DOM node maps, similar to\n   clojure.xml, implement this protocol to make the conversion.\n\n   Each DOM node will be a map or string (for Text/CDATASections). Nodes that\n   are maps have the appropriate subset of the keys\n\n     :type     - [:comment, :document, :document-type, :element]\n     :tag      - node's tag, check :type to see if applicable\n     :attrs    - node's attributes as a map, check :type to see if applicable\n     :content  - node's child nodes, in a vector, check :type to see if\n                 applicable\"\n  (as-hickory [this]\n    \"Converts the node given into a hickory-format data structure. The\n     node must have an implementation of the HickoryRepresentable protocol;\n     nodes created by parse or parse-fragment already do.\"))\n\n(defn node-type\n  [type]\n  (aget js/Node (str type \"_NODE\")))\n\n(def Attribute (node-type \"ATTRIBUTE\"))\n(def Comment (node-type \"COMMENT\"))\n(def Document (node-type \"DOCUMENT\"))\n(def DocumentType (node-type \"DOCUMENT_TYPE\"))\n(def Element (node-type \"ELEMENT\"))\n(def Text (node-type \"TEXT\"))\n\n(defn extend-type-with-seqable\n  [t]\n  (extend-type t\n    ISeqable\n    (-seq [array] (array-seq array))))\n\n(extend-type-with-seqable js/NodeList)\n\n(when (exists? js/NamedNodeMap)\n  (extend-type-with-seqable js/NamedNodeMap))\n\n(when (exists? js/MozNamedAttrMap) ;;NamedNodeMap has been renamed on modern gecko implementations (see https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap)\n  (extend-type-with-seqable js/MozNamedAttrMap))\n\n(defn format-doctype\n  [dt]\n  (let [name (aget dt \"name\")\n        publicId (aget dt \"publicId\")\n        systemId (aget dt \"systemId\")]\n    (if (not (empty? publicId))\n      (gstring/format \"<!DOCTYPE %s PUBLIC \\\"%s\\\" \\\"%s\\\">\" name publicId systemId)\n      (str \"<!DOCTYPE \" name \">\"))))\n\n(extend-protocol HiccupRepresentable\n  object\n  (as-hiccup [this] (condp = (aget this \"nodeType\")\n                      Attribute [(utils/lower-case-keyword (aget this \"name\"))\n                                 (aget this \"value\")]\n                      Comment (str \"<!--\" (aget this \"data\") \"-->\")\n                      Document (map as-hiccup (aget this \"childNodes\"))\n                      DocumentType (format-doctype this)\n                      ;; There is an issue with the hiccup format, which is that it\n                      ;; can't quite cover all the pieces of HTML, so anything it\n                      ;; doesn't cover is thrown into a string containing the raw\n                      ;; HTML. This presents a problem because it is then never the case\n                      ;; that a string in a hiccup form should be html-escaped (except\n                      ;; in an attribute value) when rendering; it should already have\n                      ;; any escaping. Since the HTML parser quite properly un-escapes\n                      ;; HTML where it should, we have to go back and un-un-escape it\n                      ;; wherever text would have been un-escaped. We do this by\n                      ;; html-escaping the parsed contents of text nodes, and not\n                      ;; html-escaping comments, data-nodes, and the contents of\n                      ;; unescapable nodes.\n                      Element (let [tag (utils/lower-case-keyword (aget this \"tagName\"))]\n                                (into [] (concat [tag\n                                                  (into {} (map as-hiccup (aget this \"attributes\")))]\n                                                 (if (utils/unescapable-content tag)\n                                                   (map #(aget % \"wholeText\") (aget this \"childNodes\"))\n                                                   (map as-hiccup (aget this \"childNodes\"))))))\n                      Text (utils/html-escape (aget this \"wholeText\")))))\n\n(extend-protocol HickoryRepresentable\n  object\n  (as-hickory [this] (condp = (aget this \"nodeType\")\n                       Attribute [(utils/lower-case-keyword (aget this \"name\")) (aget this \"value\")]\n                       Comment {:type :comment\n                                :content [(aget this \"data\")]}\n                       Document {:type :document\n                                 :content (not-empty\n                                            (into [] (map as-hickory\n                                                          (aget this \"childNodes\"))))}\n                       DocumentType {:type :document-type\n                                     :attrs {:name (aget this \"name\")\n                                             :publicid (aget this \"publicId\")\n                                             :systemid (aget this \"systemId\")}}\n                       Element {:type :element\n                                :attrs (not-empty (into {} (map as-hickory (aget this \"attributes\"))))\n                                :tag (utils/lower-case-keyword (aget this \"tagName\"))\n                                :content (not-empty\n                                           (into [] (map as-hickory\n                                                         (aget this \"childNodes\"))))}\n                       Text (aget this \"wholeText\"))))\n\n(defn extract-doctype\n  [s]\n  ;;Starting HTML5 doctype definition can be uppercase\n  (when-let [doctype (second (or (re-find #\"<!DOCTYPE ([^>]*)>\" s)\n                                 (re-find #\"<!doctype ([^>]*)>\" s)))]\n    (re-find #\"([^\\s]*)(\\s+PUBLIC\\s+[\\\"]?([^\\\"]*)[\\\"]?\\s+[\\\"]?([^\\\"]*)[\\\"]?)?\" doctype)))\n\n(defn remove-el\n  [el]\n  (.removeChild (aget el \"parentNode\") el))\n\n(defn parse-dom-with-domparser\n  [s]\n  (if (exists? js/DOMParser)\n    (.parseFromString (js/DOMParser.) s \"text/html\")))\n\n(defn parse-dom-with-write\n  \"Parse an HTML document (or fragment) as a DOM using document.implementation.createHTMLDocument and document.write.\"\n  [s]\n  ;;See http://www.w3.org/TR/domcore/#dom-domimplementation-createhtmldocument for more details.\n  (let [doc (.createHTMLDocument js/document.implementation \"\") ;;empty title for older implementation\n        doctype-el (aget doc \"doctype\")]\n    (when-not (extract-doctype s);; Remove default doctype if parsed string does not define it.\n      (remove-el doctype-el))\n    (when-let [title-el (first (aget doc \"head\" \"childNodes\"))];; Remove default title if parsed string does not define it.\n      (when (empty? (aget title-el \"text\"))\n          (remove-el title-el)))\n    (.write doc s)\n    doc))\n\n(defn parse\n  \"Parse an entire HTML document into a DOM structure that can be\n   used as input to as-hiccup or as-hickory.\n\n```klipse\n  (-> (parse \\\"<a style=\\\\\\\"visibility:hidden\\\\\\\">foo</a><div style=\\\\\\\"color:green\\\\\\\"><p>Hello</p></div>\\\")\n    as-hiccup)\n```\n\n```klipse\n  (-> (parse \\\"<a style=\\\\\\\"visibility:hidden\\\\\\\">foo</a><div style=\\\\\\\"color:green\\\\\\\"><p>Hello</p></div>\\\")\n    as-hickory)\n```\n\n\n  \"\n  [s]\n  (or (parse-dom-with-domparser s) (parse-dom-with-write s)))\n\n(defn parse-fragment\n  \"Parse an HTML fragment (some group of tags that might be at home somewhere\n   in the tag hierarchy under <body>) into a list of DOM elements that can\n   each be passed as input to as-hiccup or as-hickory.\"\n  [s]\n  (aget (parse s) \"body\" \"childNodes\"))\n"]}