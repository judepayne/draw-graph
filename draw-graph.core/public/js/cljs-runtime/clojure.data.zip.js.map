{"version":3,"sources":["clojure/data/zip.cljs"],"mappings":"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","names":["clojure.data.zip/auto","v","x","cljs.core/with-meta","G__50086","G__50087","G__50088","fexpr__50085","cljs.core/dissoc","cljs.core/assoc","cljs.core/meta","clojure.data.zip/auto?","cljs.core/not","clojure.data.zip/right-locs","loc","cljs.core/LazySeq","cljs.core/cons","G__50089","clojure.zip/right","clojure.data.zip/left-locs","G__50091","clojure.zip/left","clojure.data.zip/leftmost?","clojure.data.zip/rightmost?","clojure.data.zip/children","clojure.zip/branch?","p1__50092#","cljs.core.map.cljs$core$IFn$_invoke$arity$2","clojure.zip/down","clojure.data.zip/children-auto","p1__50093#","clojure.data.zip/descendants","cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic","clojure.data.zip/ancestors","G__50103","clojure.zip/up","clojure.data.zip/fixup-apply","pred","rtn","and__4120__auto__","cljs.core/map?","cljs.core/List","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/sequential?","clojure.data.zip/mapcat-chain","preds","mkpred","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","prevseq","expr","p1__50110#","or__4131__auto__","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3"],"sourcesContent":["; Copyright (c) Chris Houser, April 2008. All rights reserved.\n; The use and distribution terms for this software are covered by the\n; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n; which can be found in the file epl-v10.html at the root of this distribution.\n; By using this software in any fashion, you are agreeing to be bound by\n; the terms of this license.\n; You must not remove this notice, or any other, from this software.\n; System for filtering trees and nodes generated by zip.clj in\n; general, and xml trees in particular.\n\n(ns ^{:author \"Chris Houser\",\n      :doc \"System for filtering trees and nodes generated by zip.clj in\n           general, and xml trees in particular.\"}\n  clojure.data.zip\n  (:refer-clojure :exclude (descendants ancestors))\n  (:require [clojure.zip :as zip]))\n\n; This uses the negative form (no-auto) so that the result from any\n; naive function, including user functions, defaults to \"auto\".\n(defn auto\n  [v x] (with-meta x ((if v dissoc assoc) (meta x) :zip-filter/no-auto? true)))\n\n(defn auto?\n  [x] (not (:zip-filter/no-auto? (meta x))))\n\n(defn right-locs\n  \"Returns a lazy sequence of locations to the right of loc, starting with loc.\"\n  [loc] (lazy-seq (when loc (cons (auto false loc) (right-locs (zip/right loc))))))\n\n(defn left-locs\n  \"Returns a lazy sequence of locations to the left of loc, starting with loc.\"\n  [loc] (lazy-seq (when loc (cons (auto false loc) (left-locs (zip/left loc))))))\n\n(defn leftmost?\n  \"Returns true if there are no more nodes to the left of location loc.\"\n  [loc] (nil? (zip/left loc)))\n\n(defn rightmost?\n  \"Returns true if there are no more nodes to the right of location loc.\"\n  [loc] (nil? (zip/right loc)))\n\n(defn children\n  \"Returns a lazy sequence of all immediate children of location loc,\n  left-to-right.\"\n  [loc]\n  (when (zip/branch? loc)\n    (map #(auto false %) (right-locs (zip/down loc)))))\n\n(defn children-auto\n  \"Returns a lazy sequence of all immediate children of location loc,\n  left-to-right, marked so that a following tag= predicate will auto-descend.\"\n  ^{:private true}\n  [loc]\n  (when (zip/branch? loc)\n    (map #(auto true %) (right-locs (zip/down loc)))))\n\n(defn descendants\n  \"Returns a lazy sequence of all descendants of location loc, in\n  depth-first order, left-to-right, starting with loc.\"\n  [loc] (lazy-seq (cons (auto false loc) (mapcat descendants (children loc)))))\n\n(defn ancestors\n  \"Returns a lazy sequence of all ancestors of location loc, starting\n  with loc and proceeding to loc's parent node and on through to the\n  root of the tree.\"\n  [loc] (lazy-seq (when loc (cons (auto false loc) (ancestors (zip/up loc))))))\n\n(defn- fixup-apply\n  \"Calls (pred loc), and then converts the result to the 'appropriate'\n  sequence.\"\n  ^{:private true}\n  [pred loc]\n  (let [rtn (pred loc)]\n    (cond (and (map? (meta rtn)) (:zip-filter/is-node? (meta rtn))) (list rtn)\n          (= rtn true)                (list loc)\n          (= rtn false)               nil\n          (nil? rtn)                  nil\n          (sequential? rtn)           rtn\n          :else                       (list rtn))))\n\n(defn mapcat-chain\n  ^{:private true}\n  [loc preds mkpred]\n  (reduce (fn [prevseq expr]\n            (mapcat #(fixup-apply (or (mkpred expr) expr) %) prevseq))\n          (list (with-meta loc (assoc (meta loc) :zip-filter/is-node? true)))\n          preds))\n"]}