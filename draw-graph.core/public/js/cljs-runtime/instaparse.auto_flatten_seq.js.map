{"version":3,"sources":["instaparse/auto_flatten_seq.cljc"],"mappings":";;AAIA,AAAA,AAAaA;AAEb,AAAA;AAAA;;;AAAA,AAAaQ;;AAAb,AAAA,AACGL,AAAWM,AAAKC;AADnB,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AACcD,AAAAA;AADd,AACcA,AAAAA,AAAKC;;AADnB,AAAAT,AAAA,AAAA,AAAA,AAAA,AACcQ,AAAAA;AADdP,AAAA,AAAAC,AAAA,AAAAC,AAAAH;AAAA,AAAA,AAAA,AAAA,AAAAC,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AACcO,AAAAA,AAAKC,AAAAA;;AADnB,AAAAL,AAAA,AAAAF,AAAA;AAAA,AAAA,AAAA,AAAA,AAAAE,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AACcI,AAAAA,AAAKC,AAAAA;;AADnB,AAAA,AAAAJ,AAAA,AACcG;;;;;;AADd,AAAA,AAEGF,AAASE;AAFZ,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAEYA,AAAAA;AAFZ,AAEYA,AAAAA;;AAFZ,AAAAR,AAAA,AAAA,AAAA,AAAA,AAEYQ,AAAAA;AAFZP,AAAA,AAAAK,AAAA,AAAAH,AAAAH;AAAA,AAAA,AAAA,AAAA,AAAAC,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AAEYO,AAAAA;;AAFZ,AAAAJ,AAAA,AAAAE,AAAA;AAAA,AAAA,AAAA,AAAA,AAAAF,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AAEYI,AAAAA;;AAFZ,AAAA,AAAAH,AAAA,AAEYG;;;;;;AAFZ,AAgBA,AAAA;AAAA;AAAA;AAAA,AAMG;;;;;AAAA,AAAcE,AAIXC,AAAaC;AAJhB,AAKE,AAAG,AAAA,AAACC,AAAQF,AAAc,AAACG,AAAKF;;AAalC,AAAA,AAAOG,AAAMC,AAAKC;AAAlB,AACE,AAAI,AAAA,AAAOA;AAAX;;AAEE,AAAOC,AAAE,AAAA,AAAKD;AAAME,AAAE,AAAA,AAAA;AAASC,AAAE,AAAA,AAAKJ;;AAAtC,AACE,AAAMK,AAAE,AAACC,AAAMJ;AAAIA,AAAE,AAAA,AAACK,AAAKL;AAA3B,AACE,AACEG;AAAE,AAAOH;AAAEC;AAAE,AAACN,AAAKO,AAAEA;;;;;;AADvB,AAEE,AAAA,AAAOF;AAAG,AAACL,AAAKO,AAAED;;AAFpB,AAGQ,AAAOD;AAAE,AAACL,AAAKO,AAAED;AAAG,AAACN,AAAKO,AAAEA;;;;;;;;;;;;AAE/C,AAAA,AAAMI,AAAOC,AAAEC;AAAf,AACE,AAAOD,AAAE,AAACE,AAAOF,AAAEC;AACZA,AAAMA;;AADb,AAEE,AAAI,AAACE,AAAAA,AAAAA,AAAKH,AAAAA;AACR,AAAO,AAAA,AAACI,AAAIJ;AAAK,AAAA,AAACK,AAAKJ;;;;;AACvBA;;;;;AAEN,AAAA,AAAMK,AAASN,AAAEC;;AAAjB,AACE,AACE,AAAA,AAACM,AAAE,AAACC,AAAMP;AACV,AAAM,AAAG,AAACQ,AAAKR,AAAO,AAAA,AAAK,AAACS,AAAAA,AAAAA,AAAWV,AAAAA;AAAvC,AACE,AAAA,AAACD,AAAMC,AAAG,AAAA,AAAK,AAACS,AAAKR;;AADvB;;;AAFF,AAKE,AAAG,AAACQ,AAAKR,AAAO,AAAK,AAAAU,AAAY,AAACT,AAAOF,AAAE,AAACY,AAAIX;AAA3B,AAAA,AAAAU,AAAAA,AAACD,AAAAA,AAAAA;AAAN;AAChB,AAACX,AAAMC,AAAE,AAACK,AAAK,AAACO,AAAIX,AAAO,AAAA,AAAK,AAACQ,AAAKR;;AANxC,AASE,AAAOD;AAAE,AAACY,AAAIX;;;;;;;;;;AAElB,AAAA,AAAA,AAAAY,AAAME;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMD,AACFf;AADJ,AACO,AAAI,AAAA,AAAM,AAACQ,AAAMR;AACf,AAACiB,AAASjB,AAAE,AAAA,AAAA,AAACD,AAAMC;;AADrB;;;;AADP,AAAA,AAAA,AAAMe,AAIFf,AAAEC;AAJN,AAKI,AAAAiB,AAAA,AAAA;AAAA,AACE,AAACC,AAAK,AAACjB,AAAOF,AAAEC,AACV,AAAAmB,AAAsB,AAACd,AAAQN,AAAEC;AAAjC,AAAA,AAAAmB;AAAA,AAAA,AAAAA,AAAWC;AAAX,AACE,AAACJ,AAASjB,AAAEqB;;AADd;;;AAFR,AAAA;;;AALJ,AAAA,AAAA,AAAMN;;AAAN,AA2FA,AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,AAAA,AAAA,AAAA,AAAA,AAASY;;AAAT,AAAA,AAAA,AAGa5C;AAHb,AAGmB,AAACmD,AAAQ,AAACC,AAAIpD;;;AAHjC,AAAA,AAAA,AAAA,AAAS4C,AAgDG5C,AAAKmE;;AAhDjB,AAAA,AAAA,AAgDYnE;AAhDZ,AAiDI,AAASiB,AAAEkD;;;AAjDf,AAAA,AAAA,AAAA,AAASvB,AAkDG5C,AAAKmE,AAAIC;;AAlDrB,AAAA,AAAA,AAkDYpE;AAlDZ,AAmDI,AAASiB,AAAEkD,AAAIC;;;AAnDnB,AAAA,AAAA,AAAA,AAASxB,AAwDC5C;;AAxDV,AAAA,AAAA,AAwDUA;AAxDV,AAyDI,AAAC2D,AAAK1C;;;AAzDV,AAAA,AAAA,AAAA,AAAS2B,AAsBC5C;;AAtBV,AAAA,AAAA,AAsBUA;AAtBV,AAsBgB,AAAC4D,AAAK,AAACR,AAAIpD;;;AAtB3B,AAAA,AAAA,AAAA,AAAS4C,AA8CE5C;;AA9CX,AAAA,AAAA,AA8CWA;AA9CX,AA8CiBgD;;;AA9CjB,AAAA,AAAA,AAAA,AAASJ,AAKC5C;;AALV,AAAA,AAAA,AAKUA;AALV,AAKgB+C;;;AALhB,AAAA,AAAA,AAAA,AAASH,AAWE5C,AAAKuD;;AAXhB,AAAA,AAAA,AAWWvD;AAXX,AAYI,AACK,AAACwB,AAAEuB,AAAS,AAACzC,AAAKiD,AAClB,AAAC/B,AAAEwB,AAAI,AAACvB,AAAM8B,AACd,AAAI,AAAA,AAAC/B,AAAEwB,AACH,AAACxB,AAAE,AAAC4B,AAAIpD,AAAMuD;;;AAhB3B,AAAA,AAAA,AAAA,AAASX,AAoBE5C;;AApBX,AAAA,AAAA,AAoBWA;AApBX,AAoBiB,AAACyD,AAAUC,AAAM,AAACC,AAAK3D;;;AApBxC,AAAA,AAAA,AAAA,AAAS4C,AAQE5C;;AARX,AAAA,AAAA,AAQWA;AARX,AAQiB,AAACqD,AAAM,AAACD,AAAIpD;;;AAR7B,AAAA,AAAA,AAAA,AAAS4C,AASC5C;;AATV,AAAA,AAAA,AASUA;AATV,AASgB,AAACsD,AAAK,AAACF,AAAIpD;;;AAT3B,AAAA,AAAA,AAAA,AAAS4C,AA2DA5C;;AA3DT,AAAA,AAAA,AA2DSA;AA3DT,AA4DI,AAAIkD;AAAWA;;AACb,AACE,AAAMA,AAAW,AAAID,AAAM,AAACf,AAASjB,AAAG,AAACmC,AAAInC;;AAC7CiC;;;;AA/DR,AAAA,AAAA,AAAA,AAASN,AAqDM5C,AAAKqE;;AArDpB,AAAA,AAAA,AAqDerE;AArDf,AAsDI,AAAA4C,AAAA,AAAiB,AAACa,AAAUxC,AAAEoD,AAASvB,AAAgBC,AAASC,AAAIC;;;AAtDxE,AAAA,AAAA,AAAA,AAASL,AAkBC5C,AAAKwD;;AAlBf,AAAA,AAAA,AAkBUxD;AAlBV,AAkBkB,AAACoC,AAAKoB,AAAExD;;;AAlB1B,AAAA,AAAA,AAAAuC,AAASK;;AAAT,AAAA,AAAA,AAAA,AAASA,AAwBK5C,AAAKC;;AAxBnB,AAAA,AAAA,AAwBcD;AAxBd,AAyBI,AACE,AAAA,AAAMC;AAAKD;;AADb,AAEE,AAACoB,AAAAA,AAAAA,AAAKnB,AAAAA;AACN,AACE,AAAA,AAAO+C;AAAK/C;;AADd,AAEE,AAAI,AAACwB,AAAMxB,AAAKV,AAAA;AAChB,AAAMsE,AAAI,AAACC,AAAAA,AAAAA,AAAS9D,AAAAA,AAAKC,AAAAA;AACnB8D,AAAQ,AAAGf,AAAI,AAACvB,AAAMxB;AAD5B,AAEE,AAAA2C,AAAiB,AAACoB,AAAK/C,AAAEhB,AAAK4D,AAAI,AAACI,AAAoBJ,AAAIE,AAASA,AACnD,AAAAG,AAAIjB;AAAJ,AAAA,AAAAiB;AAAAA;;AAAU,AAAyBjE;;AADpD;;AALJ,AAQE,AAAM4D,AAAI,AAACC,AAAAA,AAAAA,AAAS9D,AAAAA,AAAKC,AAAAA;AACnB8D,AAAQ,AAAGf,AAAI,AAACvB,AAAMxB;AAD5B,AAEE,AAAA2C,AAAA,AAAA,AAAiB,AAACtB,AAAKL,AAAEhB,AAAK4D,AAAI,AAACI,AAAoBJ,AAAIE,AAASA;;;;;AAb1E,AAgBE,AAAMF,AAAI,AAAC3D,AAAU4C,AAAgB7C;AAC/B8D,AAAQ,AAAA,AAAKf;AADnB,AAEE,AAAAJ,AAAA,AAAiB,AAACtB,AAAKL,AAAEhB,AAAK4D,AAAI,AAACI,AAAoBJ,AAAIE,AAASA,AAAQd;;;;;;AA3CpF,AAAA,AAAA,AAAA,AAASL,AA4CG5C;;AA5CZ,AAAA,AAAA,AA4CYA;AA5CZ,AA4CkBkD;;;AA5ClB,AAAA,AAAA,AAASN;AAAT,AAAA,AAAA;;;AAAA,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAAAJ,AAAAC,AAAAC,AAASE;AAAT,AAAA,AAAAD,AAAAF,AAAA;;;AAAA;;;AAAA,AAASI,AAAkC5B,AAAU6B,AAAwBC,AAAiBC,AAAaC,AACnDC;AADxD,AAAA,AAAAN,AAA2C3B,AAAU6B,AAAwBC,AAAiBC,AAAaC,AACnDC;;;AAD/CN,AAyEN,AAAA,AAAOkB,AAAkCQ,AAAmBC;AAA5D,AACE,AAAMC,AAAE,AAAC/C,AAAM8C;AACTE,AAAE,AAAA,AAAK,AAAA,AAAClE,AAAQiE;AADtB,AAEE,AAAG,AAACnE,AAAKoE,AAAE,AAAmBH,AAC3B,AAAG,AAAmBC,AAAIE;;AAgBjC,AAAA;;;AAAA,AAAA3C,AAAc6C;AAAd,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAA1C,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAc0C,AAEVC;AAFJ,AAGG,AAAA,AAACC,AAAgCD;;;AAHpC,AAAA,AAAA,AAAcD,AAIVG,AAAsBF;AAJ1B,AAKG,AAAOzE,AAAa2E;AACbF,AAAK,AAACxB,AAAIwB;;AADjB,AAEE,AAAA,AAAQ,AAAA,AAAMA;AACZ,AAAO,AAAA,AAAQ,AAAG,AAAA,AAACvE,AAAQF,AAAc,AAACG,AAAK,AAAC+C,AAAMuB;AAC/C,AAAChB,AAAKgB;;;;;AACbzE;;;;;;AAVP,AAAA,AAAA,AAAcwE;;AAAd,AAaA,AAAA,AAAA,AAAA,AAAA,AAAApC,AACEK;;AADF,AAAA,AAAA,AACEA,AACA,AAAamC,AAAIC,AAAOC;AAAxB,AAAA,AAAA,AAAaF;AAAb,AACE,AAACG,AAAW,AAAC9B,AAAI2B,AAAKC,AAAOC;;AAEpC,AAAA,AAAME,AAAkBlE;AAAxB,AACE,AAAMA,AAAE,AAACmE,AAAInE;AAAb,AACE,AAAA2B,AAAA,AAAA,AAAiB3B,AACA,AAAC4D,AAA8B5D,AAC/B,AAACX,AAAKW,AAAG,AAACQ,AAAMR;;AAGrC,AAAKyC,AAAM,AAAA,AAACyB;AAEZ,AAAA,AAAM/D,AAAMiE;AAAZ,AACE,AAAWzC,AAAeyC;;AAE5B,AAAA,AAAM1D,AAAYV;AAAlB,AACE,AAAI,AAACG,AAAKH;AACR,AAACQ,AAAM,AAAqBR;;AAC5B,AAACQ,AAAMR;;;AAIX,AAAA,AAAMqE,AAAiBC,AAAItE;;AAA3B,AACE,AAAAuE,AAAW,AAACpC,AAAInC;AAAhB,AAAA,AAAAuE;AAAA,AAAAA,AAASH;AAAT,AACE,AAAMI,AAAI,AAACpC,AAAMpC;AAAjB,AACE,AAAI,AAACG,AAAKqE;AACR,AAAO,AAACH,AAAAA,AAAAA,AAAgBC,AAAAA,AAAIE,AAAAA;AAAK,AAAC7B,AAAK3C;;;;;AACvC,AAAO,AAACyE,AAAMH,AAAIE;AAAK,AAAC7B,AAAK3C;;;;;;AACjCsE;;;;;AAEJ;;;AAAA,AAAMI,AAEH1E;AAFH,AAGE,AAAC2E,AAAY,AAACN,AAAgB,AAAA,AAACO,AAAc5E;;AAE/C,AAAA;AAAA;;;AAAA,AAAa8E;;AAAb,AAAA,AACqBD,AAAS9F;AAD9B,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAC8BA,AAAAA;AAD9B,AAC8BA,AAAAA;;AAD9B,AAAAR,AAAA,AAAA,AAAA,AAAA,AAC8BQ,AAAAA;AAD9BP,AAAA,AAAAqG,AAAA,AAAAnG,AAAAH;AAAA,AAAA,AAAA,AAAA,AAAAC,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AAC8BO,AAAAA;;AAD9B,AAAAJ,AAAA,AAAAkG,AAAA;AAAA,AAAA,AAAA,AAAA,AAAAlG,AAAA;AAAA,AAAAA,AAAAA,AAAAA,AAC8BI,AAAAA;;AAD9B,AAAA,AAAAH,AAAA,AAC8BG;;;;;;AAD9B,AAgHA,AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,AAAA,AAAA,AAAA,AAAA,AAASsG;;AAAT,AAAA,AAAA,AAYatG;AAZb,AAaI,AAACmD,AAAQ,AAASnD;;;AAbtB,AAAA,AAAA,AAAA,AAASsG,AA6CGtG,AAAKmE;;AA7CjB,AAAA,AAAA,AA6CYnE;AA7CZ,AA8CI,AAAS,AAASA,AAAMmE;;;AA9C5B,AAAA,AAAA,AAAA,AAASmC,AA+CGtG,AAAKmE,AAAIC;;AA/CrB,AAAA,AAAA,AA+CYpE;AA/CZ,AAgDI,AAAS,AAASA,AAAMmE,AAAIC;;;AAhDhC,AAAA,AAAA,AAAA7B,AAAS+D;;AAAT,AAAA,AAAA,AAAA,AAASA,AAKGtG;;AALZ,AAAA,AAAA,AAKYA;AALZ,AAMI,AAAM,AAAA,AAAAgG,AAACS,AAAKD;AAAZ,AACE,AAACE,AAAMF,AAAK,AAAKG;AAAL,AAAQ,AAAClD,AAAU,AAAA,AAAAuC,AAACL,AAAU1E,AAAG,AAAA,AAAA+E,AAACrC,AAAM1C;;;AACpD,AAACyF,AAAMzF,AAAE,AAAK0F;AAAL,AAAA;;;AAFX;;AANJ,AAAAX,AASKQ;;;AATL,AAAA,AAAA,AAAA,AAASF,AA2EMtG,AAAKmH,AAAEC;;AA3EtB,AAAA,AAAA,AA2EepH;AA3Ef,AA4EI,AAAY,AAASA,AAAMmH,AAAEC;;;AA5EjC,AAAA,AAAA,AAAA,AAASd,AAkDAtG,AAAK4G;;AAlDd,AAAA,AAAA,AAkDS5G;AAlDT,AAmDI,AAAM,AAASA,AAAM4G;;;AAnDzB,AAAA,AAAA,AAAA,AAASN,AAoDAtG,AAAK4G,AAAExC;;AApDhB,AAAA,AAAA,AAoDSpE;AApDT,AAqDI,AAAM,AAASA,AAAM4G,AAAExC;;;AArD3B,AAAA,AAAA,AAAA,AAASkC,AA2BItG,AAAK4G,AAAEC;;AA3BpB,AAAA,AAAA,AA2Ba7G;AA3Bb,AA4BI,AAAU,AAASA,AAAM4G,AAAEC;;;AA5B/B,AAAA,AAAA,AAAA,AAASP,AAsCCtG;;AAtCV,AAAA,AAAA,AAsCUA;AAtCV,AAuCI,AAAA,AAAAgG,AAAKQ;AAAK,AAAA,AAAAR,AAACrC,AAAM6C;;AAAM,AAAA,AAAAR,AAACrC,AAAM1C;;;;AAvClC,AAAA,AAAA,AAAA,AAASqF,AAyBEtG;;AAzBX,AAAA,AAAA,AAyBWA;AAzBX,AAyBiBgD;;;AAzBjB,AAAA,AAAA,AAAA,AAASsD,AAiECtG;;AAjEV,AAAA,AAAA,AAiEUA;AAjEV,AAkEI,AAAO,AAASA;;;AAlEpB,AAAA,AAAA,AAAA,AAASsG,AAmEAtG;;AAnET,AAAA,AAAA,AAmESA;AAnET,AAoEI,AAAM,AAASA;;;AApEnB,AAAA,AAAA,AAAA,AAASsG,AA4DCtG;;AA5DV,AAAA,AAAA,AA4DUA;AA5DV,AA6DI,AAAI,AAAA,AAAMgD;AACR,AAACgE,AAAK,AAAShH;;AADjB;;;;AA7DJ,AAAA,AAAA,AAAA,AAASsG,AAeCtG;;AAfV,AAAA,AAAA,AAeUA;AAfV,AAegB+C;;;AAfhB,AAAA,AAAA,AAAA,AAASuD,AAiBEtG,AAAKuD;;AAjBhB,AAAA,AAAA,AAiBWvD;AAjBX,AAmBK,AAAK,AAACwB,AAAEuB,AAAS,AAACzC,AAAKiD,AAClB,AAAC/B,AAAEwB,AAAI,AAACvB,AAAM8B,AACd,AAAC/B,AAAE,AAASxB,AAAMuD;;;AArB5B,AAAA,AAAA,AAAA,AAAS+C,AAuBEtG;;AAvBX,AAAA,AAAA,AAuBWA;AAvBX,AAuBiB,AAAA,AAACyD,AAAa,AAACE,AAAK3D;;;AAvBrC,AAAA,AAAA,AAAA,AAASsG,AAsEEtG,AAAK4G,AAAEC;;AAtElB,AAAA,AAAA,AAsEW7G;AAtEX,AAuEI,AAACiH,AAAM,AAASjH,AAAM4G,AAAEC;;;AAvE5B,AAAA,AAAA,AAAA,AAASP,AAwEUtG,AAAKkH;;AAxExB,AAAA,AAAA,AAwEmBlH;AAxEnB,AAyEI,AAAgB,AAASA,AAAMkH;;;AAzEnC,AAAA,AAAA,AAAA,AAASZ,AA0CAtG;;AA1CT,AAAA,AAAA,AA0CSA;AA1CT,AA2CI,AAACoD,AAAI,AAASpD;;;AA3ClB,AAAA,AAAA,AAAA,AAASsG,AAiCMtG,AAAKqE;;AAjCpB,AAAA,AAAA,AAiCerE;AAjCf,AAkCI,AAAA,AAAAgG,AAAKQ;AACH,AAAAF,AAAwB,AAAA,AAAAN,AAACc,AAAM7F,AAAG8B,AAASC,AAAI,AAAC8D,AAAK,AAAA,AAAAd,AAACvC,AAAW+C,AAAKnC;;AACtE,AAAAiC,AAAwB,AAACQ,AAAK,AAAA,AAAAd,AAACvC,AAAWxC,AAAEoD,AAAUtB,AAASC,AAAI,AAAA,AAAAgD,AAACc,AAAMN;;;;AApChF,AAAA,AAAA,AAAA,AAASF,AA8BCtG,AAAKC;;AA9Bf,AAAA,AAAA,AA8BUD;AA9BV,AA+BI,AAACsB,AAAK,AAAStB,AAAMC;;;AA/BzB,AAAA,AAAA,AAAA,AAAAgG,AAASK;;AAAT,AAAA,AAAAJ,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAD,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAjE,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAA,AAAAiE,AAAAE,AAASE;;AAAT,AAAA,AAAAJ,AAAA;AAAA,AAAA,AAAA,AAAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAAG,AAAAD;;;AAAA,AAAA,AAAA,AAAA,AAASE,AAuDQS;;AAvDjB,AAAA,AAAA,AAuDY/G;AAvDZ,AAwDI,AAAS,AAASA,AAAM+G;;;AAxD5B,AAAA,AAAA,AAAA,AAAST,AAyDQS,AAAI3C;;AAzDrB,AAAA,AAAA,AAyDYpE;AAzDZ,AA0DI,AAAS,AAASA,AAAM+G,AAAI3C;;;AA1DhC,AAAA,AAAA,AAAA,AAASkC,AA8EItG,AAAKqH;;AA9ElB,AAAA,AAAA,AA8EarH;AA9Eb,AA+EI,AAACsH,AAAS,AAAStH,AAAMqH;;;AA/E7B,AAAA,AAAA,AAASf;AAAT,AAAA,AAAA;;;AAAA,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAAA9D,AAAAC,AAAAC,AAAS4D;AAAT,AAAA,AAAA3D,AAAAF,AAAA;;;AAAA;;;AAAA,AAAS8D,AAAuBtF,AACQ8B,AACAC,AACRwD;AAHhC,AAAA,AAAAF,AAAgCrF,AACQ8B,AACAC,AACRwD;;;AAHvBF,AAmFN,AAAA,AAAA,AAAA,AAAA,AAAA/D,AACE+D;;AADF,AAAA,AAAA,AACEA,AACA,AAAarF,AAAE+D,AAAOC;AAAtB,AAAA,AAAA,AAAahE;AAAb,AACE,AAACiE,AAAW,AAASjE,AAAG+D,AAAOC;;AAEtC,AAAA,AAAMsC,AAAoCxC;AAA1C,AACE,AACE,AAASA;AACT,AAAI,AAASA;AACX,AAACK,AAAI,AAAChC,AAAI2B;;AAQP,AAAAuB,AACC,AAACQ,AAAK,AAAK/B,AACX,AAAYA,AACZ,AAAOA,AACP,AAAA,AAAC+B;;;AAfT,AAiBE,AAAK/B","names":["instaparse.auto-flatten-seq/threshold","x__4487__auto__","m__4488__auto__","instaparse.auto-flatten-seq/conj-flat","goog/typeOf","m__4485__auto__","cljs.core/missing-protocol","instaparse.auto-flatten-seq/cached?","instaparse.auto-flatten-seq/ConjFlat","self","obj","instaparse.auto-flatten-seq/hash-conj","unmixed-hash","item","cljs.core/imul","cljs.core/hash","instaparse.auto-flatten-seq/expt","base","pow","n","y","z","t","cljs.core/even?","cljs.core/quot","instaparse.auto-flatten-seq/delve","v","index","cljs.core.get_in","instaparse.auto-flatten-seq/afs?","cljs.core.get","cljs.core.conj","instaparse.auto-flatten-seq/advance","cljs.core._EQ_","cljs.core/count","cljs.core/peek","instaparse.auto-flatten-seq/true-count","G__52000","cljs.core/pop","var_args","G__52003","instaparse.auto-flatten-seq/flat-seq","js/Error","instaparse.auto_flatten_seq.flat_seq","cljs.core/LazySeq","cljs.core/cons","temp__5735__auto__","next-index","cljs.core/PROTOCOL_SENTINEL","this__4428__auto__","writer__4429__auto__","opt__4430__auto__","cljs.core/-write","instaparse.auto-flatten-seq/AutoFlattenSeq","instaparse.auto-flatten-seq/->AutoFlattenSeq","premix-hashcode","hashcode","cnt","dirty","cached-seq","cljs.core/pr-str*","cljs.core/seq","cljs.core/first","cljs.core/rest","other","o","cljs.core/with-meta","instaparse.auto-flatten-seq/EMPTY","cljs.core/meta","cljs.core/next","phc","instaparse.auto-flatten-seq/hash-cat","new-cnt","cljs.core.into","cljs.core/mix-collection-hash","or__4185__auto__","key","not-found","metamap","v1","v2","c","e","G__52021","instaparse.auto-flatten-seq/hash-ordered-coll-without-mix","coll","instaparse.auto_flatten_seq.hash_ordered_coll_without_mix","existing-unmixed-hash","afs","writer","opts","cljs.core/-pr-writer","instaparse.auto-flatten-seq/auto-flatten-seq","cljs.core/vec","s","instaparse.auto-flatten-seq/flat-vec-helper","acc","temp__5733__auto__","fst","cljs.core.conj_BANG_","instaparse.auto-flatten-seq/flat-vec","cljs.core/persistent!","cljs.core/transient","instaparse.auto-flatten-seq/get-vec","instaparse.auto-flatten-seq/GetVec","cljs.core/deref","unused__9292__auto__","self__","G__52129","args52049","cljs.core/aclone","instaparse.auto-flatten-seq/FlattenOnDemandVector","instaparse.auto-flatten-seq/->FlattenOnDemandVector","flat","cljs.core/not","cljs.core.swap_BANG_","_","i","val","cljs.core.atom","arg","cljs.core/rseq","cljs.core.assoc","k","f","init","that","cljs.core/-compare","instaparse.auto-flatten-seq/convert-afs-to-vec"],"sourcesContent":["(ns instaparse.auto-flatten-seq\r\n  #?(:clj (:import clojure.lang.PersistentVector))\r\n  #?(:clj (:require [clojure.core.protocols :refer [IKVReduce]])))\r\n\r\n(def ^:const threshold 32)\r\n\r\n(defprotocol ConjFlat\r\n  (conj-flat [self obj])\r\n  (cached? [self]))\r\n\r\n; Need a backwards compatible version of mix-collection-hash\r\n#?(:clj (defmacro compile-if [test then else]\r\n          (if (eval test)\r\n            then\r\n            else)))\r\n\r\n#?(:clj (defmacro mix-collection-hash-bc [x y]\r\n          ;; backwards-compatible\r\n          `(compile-if (resolve 'clojure.core/mix-collection-hash)\r\n                       (mix-collection-hash ~x ~y)\r\n                       ~x)))\r\n\r\n(declare EMPTY hash-cat afs? true-count)\r\n\r\n#?(:clj\r\n   (defmacro hash-conj [premix-hash-v item]\r\n     `(unchecked-add-int (unchecked-multiply-int 31 ~premix-hash-v) (hash ~item)))\r\n   :cljs\r\n   (defn ^number hash-conj\r\n     \"Returns the hash code, consistent with =, for an external ordered\r\n  collection implementing Iterable.\r\n  See http://clojure.org/data_structures#hash for full algorithms.\"\r\n     [unmixed-hash item]\r\n     (+ (imul 31 unmixed-hash) (hash item))))\r\n\r\n#?(:clj\r\n   (defn- expt [base pow]\r\n     (if (zero? pow)\r\n       1\r\n       (loop [n (int pow), y (int 1), z (int base)]\r\n         (let [t (even? n), n (quot n 2)]\r\n           (cond\r\n             t (recur n y (unchecked-multiply-int z z))\r\n             (zero? n) (unchecked-multiply-int z y)\r\n             :else (recur n (unchecked-multiply-int z y) (unchecked-multiply-int z z)))))))\r\n   :cljs\r\n   (defn- expt [base pow]\r\n     (if (zero? pow)\r\n       1\r\n       (loop [n (int pow), y (int 1), z (int base)]\r\n         (let [t (even? n), n (quot n 2)]\r\n           (cond\r\n             t (recur n y (imul z z))\r\n             (zero? n) (imul z y)\r\n             :else (recur n (imul z y) (imul z z))))))))\r\n\r\n(defn delve [v index]\r\n  (loop [v (get-in v index)\r\n         index index]\r\n    (if (afs? v)\r\n      (recur (get v 0) (conj index 0))\r\n      index)))\r\n\r\n(defn advance [v index]\r\n  (cond\r\n    (= (count index) 1)\r\n    (when (< (peek index) (dec (true-count v)))\r\n      (delve v [(inc (peek index))]))\r\n    \r\n    (< (peek index) (dec (true-count (get-in v (pop index)))))\r\n    (delve v (conj (pop index) (inc (peek index))))\r\n    \r\n    :else\r\n    (recur v (pop index))))\r\n\r\n(defn flat-seq\r\n  ([v] (if (pos? (count v)) \r\n         (flat-seq v (delve v [0]))\r\n         nil))\r\n  ([v index]\r\n    (lazy-seq\r\n      (cons (get-in v index) \r\n            (when-let [next-index (advance v index)] \r\n              (flat-seq v next-index))))))  \r\n\r\n#?(:clj\r\n(deftype AutoFlattenSeq [^PersistentVector v ^int premix-hashcode ^int hashcode\r\n                         ^int cnt ^boolean dirty\r\n                         ^:unsynchronized-mutable ^clojure.lang.ISeq cached-seq]\r\n  Object\r\n  (toString [self] (.toString (seq self)))\r\n  (hashCode [self] hashcode)\r\n  (equals [self other]\r\n    (and (instance? AutoFlattenSeq other)\r\n         (== hashcode (.hashcode ^AutoFlattenSeq other))\r\n         (== cnt (.cnt ^AutoFlattenSeq other))\r\n         (= dirty (.dirty ^AutoFlattenSeq other))\r\n         (= v (.v ^AutoFlattenSeq other))))\r\n  clojure.lang.IHashEq\r\n  (hasheq [self] hashcode)\r\n  java.util.Collection\r\n  (iterator [self]\r\n    (if-let [^java.util.Collection s (seq self)]\r\n      (.iterator s)\r\n      (let [^java.util.Collection e ()]\r\n        (.iterator e))))\r\n  (size [self]\r\n    cnt)\r\n  (toArray [self]\r\n    (let [^java.util.Collection s (seq self)]\r\n      (.toArray s)))\r\n  clojure.lang.Sequential\r\n  clojure.lang.ISeq\r\n  (equiv [self other]\r\n    (and (== hashcode (hash other))\r\n         (== cnt (count other))\r\n         (or (== cnt 0)\r\n             (= (seq self) other))))\r\n  (empty [self] (with-meta EMPTY (meta self))) \r\n  (first [self] (first (seq self)))\r\n  (next [self] (next (seq self)))\r\n  (more [self] (rest (seq self)))\r\n  (cons [self obj]\r\n    (cons obj self))\r\n  ConjFlat\r\n  (conj-flat [self obj]\r\n    (cond\r\n      (nil? obj) self\r\n      (afs? obj)\r\n      (cond\r\n        (zero? cnt) obj\r\n        (<= (count obj) threshold)\r\n        (let [phc (hash-cat self obj)\r\n              new-cnt (+ cnt (count obj))]\r\n          (AutoFlattenSeq. (into v obj) phc (mix-collection-hash-bc phc new-cnt) new-cnt\r\n                           (or dirty (.dirty ^AutoFlattenSeq obj)) nil))\r\n        :else\r\n        (let [phc (hash-cat self obj)\r\n              new-cnt (+ cnt (count obj))]\r\n          (AutoFlattenSeq. (conj v obj) phc (mix-collection-hash-bc phc new-cnt) new-cnt\r\n                           true nil)))\r\n      :else \r\n      (let [phc (hash-conj premix-hashcode obj)\r\n            new-cnt (inc cnt)]\r\n        (AutoFlattenSeq. (conj v obj) phc (mix-collection-hash-bc phc new-cnt) new-cnt dirty nil))))\r\n  (cached? [self] cached-seq)\r\n  clojure.lang.Counted\r\n  (count [self] cnt)\r\n  clojure.lang.ILookup\r\n  (valAt [self key]    \r\n    (.valAt v key))\r\n  (valAt [self key not-found]\r\n    (.valAt v key not-found))\r\n  clojure.lang.IObj\r\n  (withMeta [self metamap]\r\n    (AutoFlattenSeq. (with-meta v metamap) premix-hashcode hashcode cnt dirty nil))\r\n  clojure.lang.IMeta\r\n  (meta [self]\r\n    (meta v))\r\n  clojure.lang.Seqable\r\n  (seq [self]\r\n    (if cached-seq cached-seq\r\n      (do\r\n        (set! cached-seq (if dirty (flat-seq v) (seq v)))\r\n        cached-seq))))\r\n:cljs\r\n(deftype AutoFlattenSeq [^PersistentVector v ^number premix-hashcode ^number hashcode ^number cnt ^boolean dirty\r\n                         ^:unsynchronized-mutable ^ISeq cached-seq]\r\n  Object\r\n  (toString [self] (pr-str* (seq self)))\r\n  IHash\r\n  (-hash [self] hashcode)\r\n  ISequential\r\n  ISeq\r\n  (-first [self] (first (seq self)))\r\n  (-rest [self] (rest (seq self)))\r\n  IEquiv\r\n  (-equiv [self other]\r\n    (and ;(instance? AutoFlattenSeq other)\r\n         (= hashcode (hash other))\r\n         (= cnt (count other))\r\n         (or (= cnt 0)\r\n             (= (seq self) other))))\r\n  ICollection\r\n  (-conj [self o] (cons o self))\r\n  IEmptyableCollection\r\n  (-empty [self] (with-meta EMPTY (meta self))) \r\n  INext\r\n  (-next [self] (next (seq self)))\r\n  ConjFlat\r\n  (conj-flat [self obj]\r\n    (cond\r\n      (nil? obj) self\r\n      (afs? obj)\r\n      (cond\r\n        (zero? cnt) obj\r\n        (<= (count obj) threshold)\r\n        (let [phc (hash-cat self obj)\r\n              new-cnt (+ cnt (count obj))]\r\n          (AutoFlattenSeq. (into v obj) phc (mix-collection-hash phc new-cnt) new-cnt\r\n                           (or dirty (.-dirty ^AutoFlattenSeq obj)) nil))\r\n        :else\r\n        (let [phc (hash-cat self obj)\r\n              new-cnt (+ cnt (count obj))]\r\n          (AutoFlattenSeq. (conj v obj) phc (mix-collection-hash phc new-cnt) new-cnt\r\n                           true nil)))\r\n      :else\r\n      (let [phc (hash-conj premix-hashcode obj)\r\n            new-cnt (inc cnt)]\r\n        (AutoFlattenSeq. (conj v obj) phc (mix-collection-hash phc new-cnt) new-cnt dirty nil))))\r\n  (cached? [self] cached-seq)\r\n  ICounted\r\n  (-count [self] cnt)\r\n  ILookup\r\n  (-lookup [self key]\r\n    (-lookup v key))\r\n  (-lookup [self key not-found]\r\n    (-lookup v key not-found))\r\n  IWithMeta\r\n  (-with-meta [self metamap]\r\n    (AutoFlattenSeq. (with-meta v metamap) premix-hashcode hashcode cnt dirty nil))\r\n  IMeta\r\n  (-meta [self]\r\n    (meta v))\r\n  ISeqable\r\n  (-seq [self]\r\n    (if cached-seq cached-seq\r\n      (do\r\n        (set! cached-seq (if dirty (flat-seq v) (seq v)))\r\n        cached-seq)))))\r\n\r\n#?(:clj\r\n   (defn- hash-cat ^long [^AutoFlattenSeq v1 ^AutoFlattenSeq v2]\r\n     (let [c (count v2)\r\n           e (int (expt 31 c))]\r\n       (unchecked-add-int\r\n        (unchecked-multiply-int e (.premix-hashcode v1))\r\n        (unchecked-subtract-int (.premix-hashcode v2) e))))\r\n   :cljs\r\n   (defn- hash-cat ^number [^AutoFlattenSeq v1 ^AutoFlattenSeq v2]\r\n     (let [c (count v2)\r\n           e (int (expt 31 c))]\r\n       (+ (imul e (.-premix-hashcode v1))\r\n          (- (.-premix-hashcode v2) e)))))\r\n\r\n#?(:clj\r\n   (defn hash-ordered-coll-without-mix ^long [v]\r\n     (compile-if (resolve 'clojure.core/mix-collection-hash)\r\n       (let [thirty-one (int 31)\r\n             cnt (count v)]\r\n         (loop [acc (int 1) i (int 0)]\r\n           (if (< i cnt)\r\n             (recur (unchecked-add-int\r\n                     (unchecked-multiply-int thirty-one acc)\r\n                     (hash (v i)))\r\n                    (inc i))\r\n             acc)))\r\n       (hash v)))\r\n   :cljs\r\n   (defn ^number hash-ordered-coll-without-mix\r\n     \"Returns the partially calculated hash code, still requires a call to mix-collection-hash\"\r\n     ([coll]\r\n      (hash-ordered-coll-without-mix 1 coll))\r\n     ([existing-unmixed-hash coll]\r\n      (loop [unmixed-hash existing-unmixed-hash\r\n             coll (seq coll)]\r\n        (if-not (nil? coll)\r\n          (recur (bit-or (+ (imul 31 unmixed-hash) (hash (first coll))) 0) \r\n                 (next coll))\r\n          unmixed-hash)))))\r\n\r\n#?(:cljs\r\n   (extend-protocol IPrintWithWriter\r\n     instaparse.auto-flatten-seq/AutoFlattenSeq\r\n     (-pr-writer [afs writer opts]\r\n       (-pr-writer (seq afs) writer opts))))\r\n\r\n(defn auto-flatten-seq [v]\r\n  (let [v (vec v)]\r\n    (AutoFlattenSeq. v\r\n                     (hash-ordered-coll-without-mix v)\r\n                     (hash v) (count v)\r\n                     false nil)))\r\n\r\n(def EMPTY (auto-flatten-seq []))\r\n\r\n(defn afs? [s]\r\n  (instance? AutoFlattenSeq s))\r\n\r\n(defn true-count [v]\r\n  (if (afs? v)\r\n    (count (.-v ^AutoFlattenSeq v))\r\n    (count v)))\r\n\r\n;; For hiccup format, we need to be able to convert the seq to a vector.\r\n\r\n(defn flat-vec-helper [acc v]\r\n  (if-let [s (seq v)]\r\n    (let [fst (first v)]\r\n      (if (afs? fst) \r\n        (recur (flat-vec-helper acc fst) (next v))\r\n        (recur (conj! acc fst) (next v))))\r\n    acc))\r\n\r\n(defn flat-vec\r\n  \"Turns deep vector (like the vector inside of FlattenOnDemandVector) into a flat vec\"\r\n  [v]\r\n  (persistent! (flat-vec-helper (transient []) v)))\r\n\r\n(defprotocol GetVec\r\n  (^PersistentVector get-vec [self]))\r\n\r\n#?(:clj\r\n(deftype FlattenOnDemandVector [v   ; ref containing PersistentVector or nil \r\n                                ^int hashcode\r\n                                ^int cnt\r\n                                flat] ; ref containing PersistentVector or nil                                \r\n  GetVec\r\n  (get-vec [self] \r\n           (when (not @flat)             \r\n             (dosync\r\n               (when (not @flat)\r\n                 (ref-set flat (with-meta (flat-vec @v) (meta @v))) \r\n                 (ref-set v nil)))) ; clear out v so it can be garbage collected\r\n           @flat)\r\n                    \r\n  Object\r\n  (toString [self] (.toString (get-vec self)))\r\n  (hashCode [self] hashcode)\r\n  (equals [self other]\r\n    (and (instance? FlattenOnDemandVector other)\r\n         (== hashcode (.hashcode ^FlattenOnDemandVector other))\r\n         (== cnt (.cnt ^FlattenOnDemandVector other))\r\n         (= v (.v ^FlattenOnDemandVector other))\r\n         (= flat (.flat ^FlattenOnDemandVector other))))\r\n  clojure.lang.IHashEq\r\n  (hasheq [self] hashcode)\r\n  java.util.Collection\r\n  (iterator [self]\r\n    (.iterator (get-vec self)))\r\n  (size [self]\r\n    cnt)\r\n  (toArray [self]\r\n    (.toArray (get-vec self)))\r\n  clojure.lang.IPersistentCollection\r\n  (equiv [self other]\r\n    (or \r\n      (and (== hashcode (hash other))\r\n           (== cnt (count other))\r\n           (= (get-vec self) other))))\r\n  (empty [self] (with-meta [] (meta self))) \r\n  clojure.lang.Counted\r\n  (count [self] cnt)\r\n  clojure.lang.IPersistentVector\r\n  (assoc [self i val]\r\n    (assoc (get-vec self) i val))\r\n  (assocN [self i val]\r\n    (.assocN (get-vec self) i val))\r\n  (length [self]\r\n    cnt)\r\n  (cons [self obj]\r\n    (conj (get-vec self) obj))\r\n  clojure.lang.IObj\r\n  (withMeta [self metamap]    \r\n    (if @flat\r\n      (FlattenOnDemandVector. (ref @v) hashcode cnt (ref (with-meta @flat metamap)))\r\n      (FlattenOnDemandVector. (ref (with-meta @v metamap)) hashcode cnt (ref @flat))))\r\n  clojure.lang.IMeta\r\n  (meta [self]\r\n    (if @flat (meta @flat) (meta @v)))\r\n  clojure.lang.Seqable\r\n  (seq [self]\r\n    (seq (get-vec self)))\r\n  clojure.lang.ILookup\r\n  (valAt [self key]\r\n    (.valAt (get-vec self) key))\r\n  (valAt [self key not-found]\r\n    (.valAt (get-vec self) key not-found))\r\n  clojure.lang.Indexed\r\n  (nth [self i]\r\n    (.nth (get-vec self) i))\r\n  (nth [self i not-found]\r\n    (.nth (get-vec self) i not-found))\r\n  clojure.lang.IFn\r\n  (invoke [self arg]\r\n    (.invoke (get-vec self) arg))\r\n  (applyTo [self arglist]\r\n    (.applyTo (get-vec self) arglist))\r\n  clojure.lang.Reversible\r\n  (rseq [self]\r\n    (if (pos? cnt)\r\n      (rseq (get-vec self))\r\n      nil))\r\n  clojure.lang.IPersistentStack\r\n  (peek [self] \r\n    (peek (get-vec self)))\r\n  (pop [self] \r\n    (pop (get-vec self)))\r\n  clojure.lang.Associative\r\n  (containsKey [self k]\r\n    (.containsKey (get-vec self) k))\r\n  (entryAt [self k]\r\n    (.entryAt (get-vec self) k))\r\n  IKVReduce\r\n  (kv-reduce [self f init]\r\n    (.kvreduce (get-vec self) f init))\r\n  java.lang.Comparable\r\n  (compareTo [self that]\r\n    (.compareTo (get-vec self) that))\r\n  java.util.List\r\n  (get [self i] (nth (get-vec self) i))\r\n  (indexOf [self o] (.indexOf (get-vec self) o))\r\n  (lastIndexOf [self o] (.lastIndexOf (get-vec self) o))\r\n  (listIterator [self]\r\n    (.listIterator (get-vec self) 0))\r\n  (listIterator [self i]\r\n    (.listIterator (get-vec self) i))\r\n  (subList [self a z]\r\n    (.subList (get-vec self) a z))\r\n  )\r\n:cljs\r\n(deftype FlattenOnDemandVector [v   ; atom containing PersistentVector or nil \r\n                                ^number hashcode\r\n                                ^number cnt\r\n                                flat] ; atom containing PersistentVector or nil\r\n  GetVec\r\n  (get-vec [self] \r\n    (when (not @flat)             \r\n      (swap! flat (fn [_] (with-meta (flat-vec @v) (meta @v))))\r\n      (swap! v (fn [_] nil))) ; clear out v so it can be garbage collected \r\n    @flat)\r\n  \r\n  Object\r\n  (toString [self]\r\n    (pr-str* (get-vec self)))\r\n  IHash\r\n  (-hash [self] hashcode)\r\n  IEquiv\r\n  (-equiv [self other]\r\n    (or \r\n     (and (= hashcode (hash other))\r\n          (= cnt (count other))\r\n          (= (get-vec self) other))))\r\n  IEmptyableCollection\r\n  (-empty [self] (with-meta [] (meta self))) \r\n  ICounted\r\n  (-count [self] cnt)\r\n  IVector\r\n  (-assoc-n [self i val]\r\n    (-assoc-n (get-vec self) i val))\r\n  ICollection\r\n  (-conj [self obj]\r\n    (conj (get-vec self) obj))\r\n  IWithMeta\r\n  (-with-meta [self metamap]    \r\n    (if @flat\r\n      (FlattenOnDemandVector. (atom @v) hashcode cnt (atom (with-meta @flat metamap)))\r\n      (FlattenOnDemandVector. (atom (with-meta @v metamap)) hashcode cnt (atom @flat))))\r\n  IMeta\r\n  (-meta [self]\r\n    (if @flat (meta @flat) (meta @v)))\r\n  ISequential\r\n  ISeqable\r\n  (-seq [self]\r\n    (seq (get-vec self)))\r\n  ILookup\r\n  (-lookup [self key]\r\n    (-lookup (get-vec self) key))\r\n  (-lookup [self key not-found]\r\n    (-lookup (get-vec self) key not-found))\r\n  IIndexed\r\n  (-nth [self i]\r\n    (-nth (get-vec self) i))\r\n  (-nth [self i not-found]\r\n    (-nth (get-vec self) i not-found))\r\n  IFn\r\n  (-invoke [self arg]\r\n    (-invoke (get-vec self) arg))\r\n  (-invoke [self arg not-found]\r\n    (-invoke (get-vec self) arg not-found))\r\n  IReversible\r\n  (-rseq [self]\r\n    (if (pos? cnt)\r\n      (rseq (get-vec self))\r\n      nil))\r\n  IStack\r\n  (-peek [self] \r\n    (-peek (get-vec self)))\r\n  (-pop [self] \r\n    (-pop (get-vec self)))\r\n  IAssociative\r\n  (-assoc [self i val]\r\n    (assoc (get-vec self) i val))\r\n  (-contains-key? [self k]\r\n    (-contains-key? (get-vec self) k))\r\n  IKVReduce\r\n  (-kv-reduce [self f init]\r\n    (-kv-reduce (get-vec self) f init))\r\n  IComparable\r\n  (-compare [self that]\r\n    (-compare (get-vec self) that))\r\n  ))\r\n\r\n#?(:cljs\r\n   (extend-protocol IPrintWithWriter\r\n     instaparse.auto-flatten-seq/FlattenOnDemandVector\r\n     (-pr-writer [v writer opts]\r\n       (-pr-writer (get-vec v) writer opts))))\r\n\r\n(defn convert-afs-to-vec [^AutoFlattenSeq afs]\r\n  (cond\r\n    (.-dirty afs)\r\n    (if (cached? afs)\r\n      (vec (seq afs))\r\n      #?(:clj\r\n         (FlattenOnDemandVector.\r\n          (ref (.-v afs))\r\n          (.-hashcode afs)\r\n          (.-cnt afs)\r\n          (ref nil))\r\n         :cljs\r\n         (FlattenOnDemandVector.\r\n          (atom (.-v afs))\r\n          (.-hashcode afs)\r\n          (.-cnt afs)\r\n          (atom nil))))\r\n    :else\r\n    (.-v afs)))\r\n"]}