{
"version":3,
"file":"module$node_modules$scheduler$cjs$scheduler_development.js",
"lineCount":21,
"mappings":"AAAAA,cAAA,wDAAA,CAA4E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CACtGF,OAAA,CAAQ,qCAAR,CAUd,aAKG,UAAQ,EAAG,CAgDdG,QAASA,8BAA6B,EAAG,CACvC,GAAIC,CAAAA,mBAAJ,CAAA,CAKA,IAAIC,eAAiBC,iBAAAD,eAChBE,wBAAL,CAIEC,kBAAA,EAJF,CACED,uBADF,CAC4B,CAAA,CAK5BE,oBAAA,CAAoBC,SAApB,CAA+BL,cAA/B,CAZA,CADuC,CAgBzCM,QAASA,mBAAkB,EAAG,CAC5B,IAAIC,YAAcN,iBAAlB,CAIIO,KAAOP,iBAAAO,KACX;GAAIP,iBAAJ,GAA0BO,IAA1B,CAEEP,iBAAA,CAAoB,IAFtB,KAIO,CACL,IAAIQ,iBAAmBR,iBAAAS,SACvBT,kBAAA,CAAoBQ,gBAAAD,KAApB,CAA4CA,IAC5CA,KAAAE,SAAA,CAAgBD,gBAHX,CAMPF,WAAAC,KAAA,CAAmBD,WAAAG,SAAnB,CAA0C,IAGtCC,iBAAAA,CAAWJ,WAAAI,SACXX,KAAAA,CAAiBO,WAAAP,eACjBY,YAAAA,CAAgBL,WAAAK,cACpB,KAAIC,sBAAwBC,oBAA5B,CACIC,uBAAyBC,qBAC7BF,qBAAA,CAAuBF,WACvBI,sBAAA,CAAwBhB,IAExB,IAAI,CACF,IAAAiB;AAAuBN,gBAAA,EADrB,CAAJ,OAEU,CACRG,oBACA,CADuBD,qBACvB,CAAAG,qBAAA,CAAwBD,sBAFhB,CAOV,GAAoC,UAApC,GAAI,MAAOE,qBAAX,CAaE,GAZIC,oBAYA,CAZmB,CACrBP,SAAUM,oBADW,CAErBL,cAAeA,WAFM,CAGrBZ,eAAgBA,IAHK,CAIrBQ,KAAM,IAJe,CAKrBE,SAAU,IALW,CAYnB,CAAsB,IAAtB,GAAAT,iBAAJ,CAEEA,iBAAA,CAAoBiB,oBAAAV,KAApB,CAA4CU,oBAAAR,SAA5C,CAAwEQ,oBAF1E,KAGO,CACDC,gBAAAA,CAAwB,IACxBC,YAAAA,CAAOnB,iBACX,GAAG,CACD,GAAImB,WAAApB,eAAJ,EAA2BA,IAA3B,CAA2C,CAGzCmB,gBAAA;AAAwBC,WACxB,MAJyC,CAM3CA,WAAA,CAAOA,WAAAZ,KAPN,CAAH,MAQSY,WART,GAQkBnB,iBARlB,CAU8B,KAA9B,GAAIkB,gBAAJ,CAGEA,gBAHF,CAG0BlB,iBAH1B,CAIWkB,gBAJX,GAIqClB,iBAJrC,GAMEA,iBACA,CADoBiB,oBACpB,CAAApB,6BAAA,EAPF,CAUIY,KAAAA,CAAWS,gBAAAT,SACfA,KAAAF,KAAA,CAAgBW,gBAAAT,SAAhB,CAAiDQ,oBACjDA,qBAAAV,KAAA,CAAwBW,gBACxBD,qBAAAR,SAAA,CAA4BA,IA1BvB,CApDmB,CAmF9BW,QAASA,mBAAkB,EAAG,CAC5B,GAE2B,EAF3B,GAEAC,qBAFA,EAEsD,IAFtD,GAEgCrB,iBAFhC;AA1IsBsB,CA0ItB,GAE8DtB,iBAAAW,cAF9D,CAEqH,CACnHb,mBAAA,CAAsB,CAAA,CACtB,IAAI,CACF,EACEO,mBAAA,EADF,OAIsB,IAJtB,GAIAL,iBAJA,EA/IkBsB,CA+IlB,GAI8BtB,iBAAAW,cAJ9B,CADE,CAAJ,OAMU,CACRb,mBACA,CADsB,CAAA,CACtB,CAA0B,IAA1B,GAAIE,iBAAJ,CAEEH,6BAAA,EAFF,CAIEI,uBAJF,CAI4B,CAAA,CANpB,CARyG,CAHzF,CAuB9BG,QAASA,UAAS,CAACmB,UAAD,CAAa,CAO7BzB,mBAAA,CAAsB,CAAA,CACtB,KAAI0B,mBAAqBC,iBACzBA,kBAAA,CAAoBF,UACpB,IAAI,CACF,GAAIA,UAAJ,CAEE,IAAA,CAA6B,IAA7B,GAAOvB,iBAAP,CAAA,CAAuF,CAKrF,IAAI0B,YAAc9B,OAAA+B,aAAA,EAClB,IAAI3B,iBAAAD,eAAJ;AAAwC2B,WAAxC,EACE,EACErB,mBAAA,EADF,OAE+B,IAF/B,GAESL,iBAFT,EAEuCA,iBAAAD,eAFvC,EAE2E2B,WAF3E,CADF,KAMA,MAZqF,CAFzF,IAkBE,IAA0B,IAA1B,GAAI1B,iBAAJ,EACE,EAIEK,mBAAA,EAJF,OAK+B,IAL/B,GAKSL,iBALT,EAKuC,CAAC4B,iBAAA,EALxC,CADF,CAnBA,CAAJ,OA4BU,CACR9B,mBASA,CATsB,CAAA,CAStB,CARA2B,iBAQA,CARoBD,kBAQpB,CAP0B,IAA1B,GAAIxB,iBAAJ,CAEEH,6BAAA,EAFF,CAIEI,uBAJF,CAI4B,CAAA,CAG5B,CAAAmB,kBAAA,EAVQ,CAtCmB,CAvK/BS,MAAAC,eAAA,CAAsBlC,OAAtB,CAA+B,YAA/B,CAA6C,CAAEmC,MAAO,CAAA,CAAT,CAA7C,CA4BA,KAAI/B,kBAAoB,IAAxB,CAEIyB;AAAoB,CAAA,CAFxB,CAMIZ,qBAzBiBmB,CAmBrB,CAOIX,sBAAyB,EAP7B,CAQIN,sBAAyB,EAR7B,CAWIjB,oBAAsB,CAAA,CAX1B,CAaIG,wBAA0B,CAAA,CAb9B,CA+YIgC,UAAYC,IA/YhB,CAqZIC,gBAAwC,UAAtB,GAAA,MAAOC,WAAP,CAAmCA,UAAnC,CAAgDC,IAAAA,EArZtE,CAsZIC,kBAA4C,UAAxB,GAAA,MAAOC,aAAP,CAAqCA,YAArC,CAAoDF,IAAAA,EAtZ5E,CA0ZIG,2BAA8D,UAAjC,GAAA,MAAOC,sBAAP,CAA8CA,qBAA9C,CAAsEJ,IAAAA,EA1ZvG,CA2ZIK,0BAA4D,UAAhC,GAAA,MAAOC,qBAAP,CAA6CA,oBAA7C,CAAoEN,IAAAA,EA3ZpG,CAmaIO,KAnaJ,CAoaIC,YApaJ,CAqaIC;AAAmCA,QAAS,CAACpC,QAAD,CAAW,CAEzDkC,KAAA,CAAQJ,0BAAA,CAA2B,QAAS,CAACO,SAAD,CAAY,CAEtDT,iBAAA,CAAkBO,YAAlB,CACAnC,SAAA,CAASqC,SAAT,CAHsD,CAAhD,CAKRF,aAAA,CAAeV,eAAA,CAAgB,QAAS,EAAG,CAEzCO,yBAAA,CAA0BE,KAA1B,CACAlC,SAAA,CAASd,OAAA+B,aAAA,EAAT,CAHyC,CAA5B,CAVaqB,GAUb,CAP0C,CAc3D,IApaqD,QAoarD,GApa8B,MAAOC,YAoarC,EApa4F,UAoa5F,GApaiE,MAAOA,YAAAC,IAoaxE,CAA6B,CAC3B,IAAIC,YAAcF,WAClBrD,QAAA+B,aAAA,CAAuByB,QAAS,EAAG,CACjC,MAAOD,YAAAD,IAAA,EAD0B,CAFR,CAA7B,IAMEtD,QAAA+B,aAAA,CAAuByB,QAAS,EAAG,CACjC,MAAOnB,UAAAiB,IAAA,EAD0B,CAKrC,KAIIG,YAAc,IACI,YAAtB,GAAI,MAAOC,OAAX;AACED,WADF,CACgBC,MADhB,CAE6B,WAF7B,GAEW,MAAO7D,OAFlB,GAGE4D,WAHF,CAGgB5D,MAHhB,CAMA,IAAI4D,WAAJ,EAAmBA,WAAAE,WAAnB,CAA2C,CAErCC,WAAAA,CAAaH,WAAAE,WACjB,KAAApD,oBAAsBqD,WAAA,CAAW,CAAX,CACtB,KAAAtD,mBAAqBsD,WAAA,CAAW,CAAX,CACrB,KAAA5B,kBAAoB4B,WAAA,CAAW,CAAX,CACpB5D,QAAA+B,aAAA,CAAuB6B,WAAA,CAAW,CAAX,CANkB,CAA3C,IAOO,IAGW,WAHX,GAGP,MAAOF,OAHA,EAKmB,UALnB,GAKP,MAAOG,eALA,CAK+B,CAGpC,IAAIC,UAAY,IAAhB,CACIC,eAAiBA,QAAS,CAACpC,UAAD,CAAa,CACzC,GAAkB,IAAlB,GAAImC,SAAJ,CACE,GAAI,CACFA,SAAA,CAAUnC,UAAV,CADE,CAAJ,OAEU,CACRmC,SAAA,CAAY,IADJ,CAJ6B,CAS3CvD,oBAAA;AAAsBA,QAAS,CAACyD,EAAD,CAAKC,EAAL,CAAS,CACpB,IAAlB,GAAIH,SAAJ,CAEEtB,UAAA,CAAWjC,mBAAX,CAAgC,CAAhC,CAAmCyD,EAAnC,CAFF,EAIEF,SACA,CADYE,EACZ,CAAAxB,UAAA,CAAWuB,cAAX,CAA2B,CAA3B,CAA8B,CAAA,CAA9B,CALF,CADsC,CASxCzD,mBAAA,CAAqBA,QAAS,EAAG,CAC/BwD,SAAA,CAAY,IADmB,CAGjC9B,kBAAA,CAAoBA,QAAS,EAAG,CAC9B,MAAO,CAAA,CADuB,CAzBI,CAL/B,IAiCA,CACkB,WAAvB,GAAI,MAAOkC,QAAX,GAE4C,UAG1C,GAHI,MAAOtB,2BAGX,EAFEsB,OAAAC,MAAA,CAAc,yIAAd,CAEF,CAAyC,UAAzC,GAAI,MAAOrB,0BAAX,EACEoB,OAAAC,MAAA,CAAc,wIAAd,CANJ,CAUA;IAAIC,sBAAwB,IAA5B,CACIC,wBAA0B,CAAA,CAD9B,CAEIC,YAAe,EAFnB,CAIIC,0BAA4B,CAAA,CAJhC,CAMIC,uBAAyB,CAAA,CAN7B,CAQIC,cAAgB,CARpB,CAYIC,kBAAoB,EAZxB,CAaIC,gBAAkB,EAEtB3C,kBAAA,CAAoBA,QAAS,EAAG,CAC9B,MAAOyC,cAAP,EAAwBzE,OAAA+B,aAAA,EADM,CAK5B6C,YAAAA,CAAU,IAAIf,cAClB,KAAIgB,KAAOD,WAAAE,MACXF,YAAAG,MAAAC,UAAA,CAA0BC,QAAS,CAACC,KAAD,CAAQ,CACzCb,uBAAA,CAA0B,CAAA,CAEtBc,MAAAA,CAAwBf,qBAC5B,KAAIgB,gBAAkBd,WACtBF,sBAAA,CAAwB,IACxBE,YAAA,CAAe,EAEf,KAAIxC;AAAc9B,OAAA+B,aAAA,EAAlB,CAEIJ,WAAa,CAAA,CACjB,IAAmC,CAAnC,EAAI8C,aAAJ,CAAoB3C,WAApB,CAGE,GAAyB,EAAzB,GAAIsD,eAAJ,EAA8BA,eAA9B,EAAiDtD,WAAjD,CAGEH,UAAA,CAAa,CAAA,CAHf,KAIO,CAEA4C,yBAAL,GAEEA,yBACA,CAD4B,CAAA,CAC5B,CAAArB,gCAAA,CAAiCmC,aAAjC,CAHF,CAMAjB,sBAAA,CAAwBe,KACxBb,YAAA,CAAcc,eACd,OAVK,CAcT,GAA8B,IAA9B,GAAID,KAAJ,CAAoC,CAClCX,sBAAA,CAAyB,CAAA,CACzB,IAAI,CACFW,KAAA,CAAsBxD,UAAtB,CADE,CAAJ,OAEU,CACR6C,sBAAA,CAAyB,CAAA,CADjB,CAJwB,CAhCK,CA0C3C,KAAIa,cAAgBA,QAAS,CAACC,OAAD,CAAU,CACrC,GAA8B,IAA9B,GAAIlB,qBAAJ,CAAoC,CASlClB,gCAAA,CAAiCmC,aAAjC,CAOF;IAAIE,cAAgBD,OAAhBC,CAA0Bd,aAA1Bc,CAA0CZ,eAC1CY,cAAJ,CAAoBZ,eAApB,EAAuCD,iBAAvC,CAA2DC,eAA3D,EACsB,CAYpB,CAZIY,aAYJ,GATEA,aASF,CATkB,CASlB,EAAAZ,eAAA,CAAkBY,aAAA,CAAgBb,iBAAhB,CAAoCA,iBAApC,CAAwDa,aAb5E,EAeEb,iBAfF,CAesBa,aAEtBd,cAAA,CAAgBa,OAAhB,CAA0BX,eACrBN,wBAAL,GACEA,uBACA,CAD0B,CAAA,CAC1B,CAAAQ,IAAAW,YAAA,CAAiB/C,IAAAA,EAAjB,CAFF,CAnCoC,CAApC,IAYE8B,0BAAA,CAA4B,CAAA,CAbO,CA0CvChE,oBAAA,CAAsBA,QAAS,CAACO,QAAD,CAAW2E,eAAX,CAA4B,CACzDrB,qBAAA,CAAwBtD,QACxBwD;WAAA,CAAcmB,eACVjB,uBAAJ,EAAgD,CAAhD,CAA8BiB,eAA9B,CAEEZ,IAAAW,YAAA,CAAiB/C,IAAAA,EAAjB,CAFF,CAGY8B,yBAHZ,GAQEA,yBACA,CAD4B,CAAA,CAC5B,CAAArB,gCAAA,CAAiCmC,aAAjC,CATF,CAHyD,CAgB3D/E,mBAAA,CAAqBA,QAAS,EAAG,CAC/B8D,qBAAA,CAAwB,IACxBC,wBAAA,CAA0B,CAAA,CAC1BC,YAAA,CAAe,EAHgB,CArI5B,CA4IPtE,OAAA0F,2BAAA,CAlpBwBhE,CAmpBxB1B,QAAA2F,8BAAA,CAlpB2BC,CAmpB3B5F,QAAA6F,wBAAA,CAlpBqBzD,CAmpBrBpC,QAAA8F,sBAAA,CAjpBmBC,CAkpBnB/F,QAAAgG,qBAAA,CAnpBkBC,CAopBlBjG,QAAAkG,yBAAA;AAncAA,QAAiC,CAACnF,aAAD,CAAgBoF,YAAhB,CAA8B,CAC7D,OAAQpF,aAAR,EACE,KAtNoBW,CAsNpB,CACA,KAtNuBkE,CAsNvB,CACA,KAtNiBxD,CAsNjB,CACA,KAtNc6D,CAsNd,CACA,KAtNeF,CAsNf,CACE,KACF,SACEhF,aAAA,CA3NeqB,CAmNnB,CAWA,IAAIpB,sBAAwBC,oBAA5B,CACImF,uBAAyB3E,qBAC7BR,qBAAA,CAAuBF,aACvBU,sBAAA,CAAwBzB,OAAA+B,aAAA,EAExB,IAAI,CACF,MAAOoE,aAAA,EADL,CAAJ,OAEU,CACRlF,oBAIA,CAJuBD,qBAIvB,CAHAS,qBAGA,CAHwB2E,sBAGxB,CAAA5E,kBAAA,EALQ,CAnBmD,CAoc/DxB,QAAAqG,cAAA,CAxaAA,QAAsB,CAACF,YAAD,CAAe,CAEnC,OAAQlF,oBAAR,EACE,KAnPoBS,CAmPpB,CACA,KAnPuBkE,CAmPvB,CACA,KAnPiBxD,CAmPjB,CAEE,IAAArB;AArPeqB,CAsPf,MACF,SAEErB,aAAA,CAAgBE,oBATpB,CAaA,IAAID,sBAAwBC,oBAA5B,CACImF,uBAAyB3E,qBAC7BR,qBAAA,CAAuBF,aACvBU,sBAAA,CAAwBzB,OAAA+B,aAAA,EAExB,IAAI,CACF,MAAOoE,aAAA,EADL,CAAJ,OAEU,CACRlF,oBAIA,CAJuBD,qBAIvB,CAHAS,qBAGA,CAHwB2E,sBAGxB,CAAA5E,kBAAA,EALQ,CAtByB,CAyarCxB,QAAAsG,0BAAA,CAvXAA,QAAkC,CAACxF,QAAD,CAAWyF,kBAAX,CAA+B,CAC/D,IAAIC,UAAuC,EAA3B,GAAA/E,qBAAA,CAA+BA,qBAA/B;AAAuDzB,OAAA+B,aAAA,EAGvE,IAAkC,QAAlC,GAAI,MAAOwE,mBAAX,EAAqE,IAArE,GAA8CA,kBAA9C,EAAmH,QAAnH,GAA6E,MAAOA,mBAAAE,QAApF,CAEEtG,kBAAA,CAAiBqG,SAAjB,CAA6BD,kBAAAE,QAF/B,KAIE,QAAQxF,oBAAR,EACE,KA3SkBS,CA2SlB,CACEvB,kBAAA,CAAiBqG,SAAjB,CAhS0BE,EAiS1B,MACF,MA7SqBd,CA6SrB,CACEzF,kBAAA,CAAiBqG,SAAjB,CAjSqBG,GAkSrB,MACF,MA7SaZ,CA6Sb,CACE5F,kBAAA,CAAiBqG,SAAjB,CAzSgBI,UA0ShB,MACF,MAjTYX,CAiTZ,CACE9F,kBAAA,CAAiBqG,SAAjB,CArSmBK,GAsSnB,MAEF,SACE1G,kBAAA,CAAiBqG,SAAjB,CA1SsBM,GA2R1B,CAmBEC,QAAAA,CAAU,CACZjG,SAAUA,QADE,CAEZC,cAAeE,oBAFH;AAGZd,eAAgBA,kBAHJ,CAIZQ,KAAM,IAJM,CAKZE,SAAU,IALE,CAWd,IAA0B,IAA1B,GAAIT,iBAAJ,CAEEA,iBACA,CADoB2G,QAAApG,KACpB,CADmCoG,QAAAlG,SACnC,CADsDkG,QACtD,CAAA9G,6BAAA,EAHF,KAIO,CACDU,SAAAA,CAAO,IACX,KAAIY,KAAOnB,iBACX,GAAG,CACD,GAAImB,IAAApB,eAAJ,CAA0BA,kBAA1B,CAA0C,CAExCQ,SAAA,CAAOY,IACP,MAHwC,CAK1CA,IAAA,CAAOA,IAAAZ,KANN,CAAH,MAOSY,IAPT,GAOkBnB,iBAPlB,CASa,KAAb,GAAIO,SAAJ,CAGEA,SAHF,CAGSP,iBAHT,CAIWO,SAJX,GAIoBP,iBAJpB,GAMEA,iBACA,CADoB2G,QACpB,CAAA9G,6BAAA,EAPF,CAUIY,mBAAAA,CAAWF,SAAAE,SACfA;kBAAAF,KAAA,CAAgBA,SAAAE,SAAhB,CAAgCkG,QAChCA,SAAApG,KAAA,CAAeA,SACfoG,SAAAlG,SAAA,CAAmBA,kBAzBd,CA4BP,MAAOkG,SAtEwD,CAwXjE/G,QAAAgH,wBAAA,CAhSAA,QAAgC,CAACC,YAAD,CAAe,CAC7C,IAAItG,KAAOsG,YAAAtG,KACX,IAAa,IAAb,GAAIA,IAAJ,CAAA,CAKA,GAAIA,IAAJ,GAAasG,YAAb,CAEE7G,iBAAA,CAAoB,IAFtB,KAGO,CAED6G,YAAJ,GAAqB7G,iBAArB,GACEA,iBADF,CACsBO,IADtB,CAGA,KAAIE,SAAWoG,YAAApG,SACfA,SAAAF,KAAA,CAAgBA,IAChBA,KAAAE,SAAA,CAAgBA,QAPX,CAUPoG,YAAAtG,KAAA,CAAoBsG,YAAApG,SAApB,CAA4C,IAlB5C,CAF6C,CAiS/Cb,QAAAkH,sBAAA,CA5YAA,QAA8B,CAACpG,QAAD,CAAW,CACvC,IAAIqG;AAAsBlG,oBAC1B,OAAO,SAAS,EAAG,CAEjB,IAAID,sBAAwBC,oBAA5B,CACImF,uBAAyB3E,qBAC7BR,qBAAA,CAAuBkG,mBACvB1F,sBAAA,CAAwBzB,OAAA+B,aAAA,EAExB,IAAI,CACF,MAAOjB,SAAAsG,MAAA,CAAe,IAAf,CAAqBC,SAArB,CADL,CAAJ,OAEU,CACRpG,oBAEA,CAFuBD,qBAEvB,CADAS,qBACA,CADwB2E,sBACxB,CAAA5E,kBAAA,EAHQ,CATO,CAFoB,CA6YzCxB,QAAAsH,iCAAA,CA3QAA,QAAyC,EAAG,CAC1C,MAAOrG,qBADmC,CA4Q5CjB,QAAAuH,qBAAA,CAxQAA,QAA6B,EAAG,CAC9B,MAAO,CAAC1F,iBAAR;CAAoD,IAApD,GAA8BzB,iBAA9B,EAA4DA,iBAAAD,eAA5D,CAA+FgB,qBAA/F,EAAwHa,iBAAA,EAAxH,CAD8B,CAyQhChC,QAAAwH,2BAAA,CA/SAA,QAAmC,EAAG,CAEV,IAA1B,GAAIpH,iBAAJ,EACEH,6BAAA,EAHkC,CAgTtCD,QAAAyH,wBAAA,CApTAA,QAAgC,EAAG,EAqTnCzH,QAAA0H,8BAAA,CA1SAA,QAAsC,EAAG,CACvC,MAAOtH,kBADgC,CAhY3B,CAAX,CAAD,EAhBkH;",
"sources":["node_modules/scheduler/cjs/scheduler.development.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$scheduler$cjs$scheduler_development\"] = function(global,require,module,exports) {\nvar process = require('process');\n/** @license React v0.13.6\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar enableSchedulerDebugging = false;\n\n/* eslint-disable no-var */\n\n// TODO: Use symbols?\nvar ImmediatePriority = 1;\nvar UserBlockingPriority = 2;\nvar NormalPriority = 3;\nvar LowPriority = 4;\nvar IdlePriority = 5;\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar maxSigned31BitInt = 1073741823;\n\n// Times out immediately\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\nvar USER_BLOCKING_PRIORITY = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\nvar LOW_PRIORITY_TIMEOUT = 10000;\n// Never times out\nvar IDLE_PRIORITY = maxSigned31BitInt;\n\n// Callbacks are stored as a circular, doubly linked list.\nvar firstCallbackNode = null;\n\nvar currentDidTimeout = false;\n// Pausing the scheduler is useful for debugging.\nvar isSchedulerPaused = false;\n\nvar currentPriorityLevel = NormalPriority;\nvar currentEventStartTime = -1;\nvar currentExpirationTime = -1;\n\n// This is set when a callback is being executed, to prevent re-entrancy.\nvar isExecutingCallback = false;\n\nvar isHostCallbackScheduled = false;\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nfunction ensureHostCallbackIsScheduled() {\n  if (isExecutingCallback) {\n    // Don't schedule work yet; wait until the next time we yield.\n    return;\n  }\n  // Schedule the host callback using the earliest expiration in the list.\n  var expirationTime = firstCallbackNode.expirationTime;\n  if (!isHostCallbackScheduled) {\n    isHostCallbackScheduled = true;\n  } else {\n    // Cancel the existing host callback.\n    cancelHostCallback();\n  }\n  requestHostCallback(flushWork, expirationTime);\n}\n\nfunction flushFirstCallback() {\n  var flushedNode = firstCallbackNode;\n\n  // Remove the node from the list before calling the callback. That way the\n  // list is in a consistent state even if the callback throws.\n  var next = firstCallbackNode.next;\n  if (firstCallbackNode === next) {\n    // This is the last callback in the list.\n    firstCallbackNode = null;\n    next = null;\n  } else {\n    var lastCallbackNode = firstCallbackNode.previous;\n    firstCallbackNode = lastCallbackNode.next = next;\n    next.previous = lastCallbackNode;\n  }\n\n  flushedNode.next = flushedNode.previous = null;\n\n  // Now it's safe to call the callback.\n  var callback = flushedNode.callback;\n  var expirationTime = flushedNode.expirationTime;\n  var priorityLevel = flushedNode.priorityLevel;\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousExpirationTime = currentExpirationTime;\n  currentPriorityLevel = priorityLevel;\n  currentExpirationTime = expirationTime;\n  var continuationCallback;\n  try {\n    continuationCallback = callback();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentExpirationTime = previousExpirationTime;\n  }\n\n  // A callback may return a continuation. The continuation should be scheduled\n  // with the same priority and expiration as the just-finished callback.\n  if (typeof continuationCallback === 'function') {\n    var continuationNode = {\n      callback: continuationCallback,\n      priorityLevel: priorityLevel,\n      expirationTime: expirationTime,\n      next: null,\n      previous: null\n    };\n\n    // Insert the new callback into the list, sorted by its expiration. This is\n    // almost the same as the code in `scheduleCallback`, except the callback\n    // is inserted into the list *before* callbacks of equal expiration instead\n    // of after.\n    if (firstCallbackNode === null) {\n      // This is the first callback in the list.\n      firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;\n    } else {\n      var nextAfterContinuation = null;\n      var node = firstCallbackNode;\n      do {\n        if (node.expirationTime >= expirationTime) {\n          // This callback expires at or after the continuation. We will insert\n          // the continuation *before* this callback.\n          nextAfterContinuation = node;\n          break;\n        }\n        node = node.next;\n      } while (node !== firstCallbackNode);\n\n      if (nextAfterContinuation === null) {\n        // No equal or lower priority callback was found, which means the new\n        // callback is the lowest priority callback in the list.\n        nextAfterContinuation = firstCallbackNode;\n      } else if (nextAfterContinuation === firstCallbackNode) {\n        // The new callback is the highest priority callback in the list.\n        firstCallbackNode = continuationNode;\n        ensureHostCallbackIsScheduled();\n      }\n\n      var previous = nextAfterContinuation.previous;\n      previous.next = nextAfterContinuation.previous = continuationNode;\n      continuationNode.next = nextAfterContinuation;\n      continuationNode.previous = previous;\n    }\n  }\n}\n\nfunction flushImmediateWork() {\n  if (\n  // Confirm we've exited the outer most event handler\n  currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {\n    isExecutingCallback = true;\n    try {\n      do {\n        flushFirstCallback();\n      } while (\n      // Keep flushing until there are no more immediate callbacks\n      firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);\n    } finally {\n      isExecutingCallback = false;\n      if (firstCallbackNode !== null) {\n        // There's still work remaining. Request another callback.\n        ensureHostCallbackIsScheduled();\n      } else {\n        isHostCallbackScheduled = false;\n      }\n    }\n  }\n}\n\nfunction flushWork(didTimeout) {\n  // Exit right away if we're currently paused\n\n  if (enableSchedulerDebugging && isSchedulerPaused) {\n    return;\n  }\n\n  isExecutingCallback = true;\n  var previousDidTimeout = currentDidTimeout;\n  currentDidTimeout = didTimeout;\n  try {\n    if (didTimeout) {\n      // Flush all the expired callbacks without yielding.\n      while (firstCallbackNode !== null && !(enableSchedulerDebugging && isSchedulerPaused)) {\n        // TODO Wrap in feature flag\n        // Read the current time. Flush all the callbacks that expire at or\n        // earlier than that time. Then read the current time again and repeat.\n        // This optimizes for as few performance.now calls as possible.\n        var currentTime = exports.unstable_now();\n        if (firstCallbackNode.expirationTime <= currentTime) {\n          do {\n            flushFirstCallback();\n          } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused));\n          continue;\n        }\n        break;\n      }\n    } else {\n      // Keep flushing callbacks until we run out of time in the frame.\n      if (firstCallbackNode !== null) {\n        do {\n          if (enableSchedulerDebugging && isSchedulerPaused) {\n            break;\n          }\n          flushFirstCallback();\n        } while (firstCallbackNode !== null && !shouldYieldToHost());\n      }\n    }\n  } finally {\n    isExecutingCallback = false;\n    currentDidTimeout = previousDidTimeout;\n    if (firstCallbackNode !== null) {\n      // There's still work remaining. Request another callback.\n      ensureHostCallbackIsScheduled();\n    } else {\n      isHostCallbackScheduled = false;\n    }\n    // Before exiting, flush all the immediate work that was scheduled.\n    flushImmediateWork();\n  }\n}\n\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n    case LowPriority:\n    case IdlePriority:\n      break;\n    default:\n      priorityLevel = NormalPriority;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousEventStartTime = currentEventStartTime;\n  currentPriorityLevel = priorityLevel;\n  currentEventStartTime = exports.unstable_now();\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentEventStartTime = previousEventStartTime;\n\n    // Before exiting, flush all the immediate work that was scheduled.\n    flushImmediateWork();\n  }\n}\n\nfunction unstable_next(eventHandler) {\n  var priorityLevel = void 0;\n  switch (currentPriorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n      // Shift down to normal priority\n      priorityLevel = NormalPriority;\n      break;\n    default:\n      // Anything lower than normal priority should remain at the current level.\n      priorityLevel = currentPriorityLevel;\n      break;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousEventStartTime = currentEventStartTime;\n  currentPriorityLevel = priorityLevel;\n  currentEventStartTime = exports.unstable_now();\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentEventStartTime = previousEventStartTime;\n\n    // Before exiting, flush all the immediate work that was scheduled.\n    flushImmediateWork();\n  }\n}\n\nfunction unstable_wrapCallback(callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    // This is a fork of runWithPriority, inlined for performance.\n    var previousPriorityLevel = currentPriorityLevel;\n    var previousEventStartTime = currentEventStartTime;\n    currentPriorityLevel = parentPriorityLevel;\n    currentEventStartTime = exports.unstable_now();\n\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n      currentEventStartTime = previousEventStartTime;\n      flushImmediateWork();\n    }\n  };\n}\n\nfunction unstable_scheduleCallback(callback, deprecated_options) {\n  var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();\n\n  var expirationTime;\n  if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {\n    // FIXME: Remove this branch once we lift expiration times out of React.\n    expirationTime = startTime + deprecated_options.timeout;\n  } else {\n    switch (currentPriorityLevel) {\n      case ImmediatePriority:\n        expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;\n        break;\n      case UserBlockingPriority:\n        expirationTime = startTime + USER_BLOCKING_PRIORITY;\n        break;\n      case IdlePriority:\n        expirationTime = startTime + IDLE_PRIORITY;\n        break;\n      case LowPriority:\n        expirationTime = startTime + LOW_PRIORITY_TIMEOUT;\n        break;\n      case NormalPriority:\n      default:\n        expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;\n    }\n  }\n\n  var newNode = {\n    callback: callback,\n    priorityLevel: currentPriorityLevel,\n    expirationTime: expirationTime,\n    next: null,\n    previous: null\n  };\n\n  // Insert the new callback into the list, ordered first by expiration, then\n  // by insertion. So the new callback is inserted any other callback with\n  // equal expiration.\n  if (firstCallbackNode === null) {\n    // This is the first callback in the list.\n    firstCallbackNode = newNode.next = newNode.previous = newNode;\n    ensureHostCallbackIsScheduled();\n  } else {\n    var next = null;\n    var node = firstCallbackNode;\n    do {\n      if (node.expirationTime > expirationTime) {\n        // The new callback expires before this one.\n        next = node;\n        break;\n      }\n      node = node.next;\n    } while (node !== firstCallbackNode);\n\n    if (next === null) {\n      // No callback with a later expiration was found, which means the new\n      // callback has the latest expiration in the list.\n      next = firstCallbackNode;\n    } else if (next === firstCallbackNode) {\n      // The new callback has the earliest expiration in the entire list.\n      firstCallbackNode = newNode;\n      ensureHostCallbackIsScheduled();\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newNode;\n    newNode.next = next;\n    newNode.previous = previous;\n  }\n\n  return newNode;\n}\n\nfunction unstable_pauseExecution() {\n  isSchedulerPaused = true;\n}\n\nfunction unstable_continueExecution() {\n  isSchedulerPaused = false;\n  if (firstCallbackNode !== null) {\n    ensureHostCallbackIsScheduled();\n  }\n}\n\nfunction unstable_getFirstCallbackNode() {\n  return firstCallbackNode;\n}\n\nfunction unstable_cancelCallback(callbackNode) {\n  var next = callbackNode.next;\n  if (next === null) {\n    // Already cancelled.\n    return;\n  }\n\n  if (next === callbackNode) {\n    // This is the only scheduled callback. Clear the list.\n    firstCallbackNode = null;\n  } else {\n    // Remove the callback from its position in the list.\n    if (callbackNode === firstCallbackNode) {\n      firstCallbackNode = next;\n    }\n    var previous = callbackNode.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n\n  callbackNode.next = callbackNode.previous = null;\n}\n\nfunction unstable_getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\n\nfunction unstable_shouldYield() {\n  return !currentDidTimeout && (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime || shouldYieldToHost());\n}\n\n// The remaining code is essentially a polyfill for requestIdleCallback. It\n// works by scheduling a requestAnimationFrame, storing the time for the start\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\n// Within the postMessage handler do as much work as possible until time + frame\n// rate. By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated. We want to be using a\n// consistent implementation.\nvar localDate = Date;\n\n// This initialization code may run even on server environments if a component\n// just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n// have setTimeout or clearTimeout. However, we always expect them to be defined\n// on the client. https://github.com/facebook/react/pull/13088\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n// We don't expect either of these to necessarily be defined, but we will error\n// later if they are missing on the client.\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\n// requestAnimationFrame does not run when the tab is in the background. If\n// we're backgrounded we prefer for that work to happen so that the page\n// continues to load in the background. So we also schedule a 'setTimeout' as\n// a fallback.\n// TODO: Need a better heuristic for backgrounded work.\nvar ANIMATION_FRAME_TIMEOUT = 100;\nvar rAFID;\nvar rAFTimeoutID;\nvar requestAnimationFrameWithTimeout = function (callback) {\n  // schedule rAF and also a setTimeout\n  rAFID = localRequestAnimationFrame(function (timestamp) {\n    // cancel the setTimeout\n    localClearTimeout(rAFTimeoutID);\n    callback(timestamp);\n  });\n  rAFTimeoutID = localSetTimeout(function () {\n    // cancel the requestAnimationFrame\n    localCancelAnimationFrame(rAFID);\n    callback(exports.unstable_now());\n  }, ANIMATION_FRAME_TIMEOUT);\n};\n\nif (hasNativePerformanceNow) {\n  var Performance = performance;\n  exports.unstable_now = function () {\n    return Performance.now();\n  };\n} else {\n  exports.unstable_now = function () {\n    return localDate.now();\n  };\n}\n\nvar requestHostCallback;\nvar cancelHostCallback;\nvar shouldYieldToHost;\n\nvar globalValue = null;\nif (typeof window !== 'undefined') {\n  globalValue = window;\n} else if (typeof global !== 'undefined') {\n  globalValue = global;\n}\n\nif (globalValue && globalValue._schedMock) {\n  // Dynamic injection, only for testing purposes.\n  var globalImpl = globalValue._schedMock;\n  requestHostCallback = globalImpl[0];\n  cancelHostCallback = globalImpl[1];\n  shouldYieldToHost = globalImpl[2];\n  exports.unstable_now = globalImpl[3];\n} else if (\n// If Scheduler runs in a non-DOM environment, it falls back to a naive\n// implementation using setTimeout.\ntypeof window === 'undefined' ||\n// Check if MessageChannel is supported, too.\ntypeof MessageChannel !== 'function') {\n  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\n  // fallback to a naive implementation.\n  var _callback = null;\n  var _flushCallback = function (didTimeout) {\n    if (_callback !== null) {\n      try {\n        _callback(didTimeout);\n      } finally {\n        _callback = null;\n      }\n    }\n  };\n  requestHostCallback = function (cb, ms) {\n    if (_callback !== null) {\n      // Protect against re-entrancy.\n      setTimeout(requestHostCallback, 0, cb);\n    } else {\n      _callback = cb;\n      setTimeout(_flushCallback, 0, false);\n    }\n  };\n  cancelHostCallback = function () {\n    _callback = null;\n  };\n  shouldYieldToHost = function () {\n    return false;\n  };\n} else {\n  if (typeof console !== 'undefined') {\n    // TODO: Remove fb.me link\n    if (typeof localRequestAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n    if (typeof localCancelAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n  }\n\n  var scheduledHostCallback = null;\n  var isMessageEventScheduled = false;\n  var timeoutTime = -1;\n\n  var isAnimationFrameScheduled = false;\n\n  var isFlushingHostCallback = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  shouldYieldToHost = function () {\n    return frameDeadline <= exports.unstable_now();\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = function (event) {\n    isMessageEventScheduled = false;\n\n    var prevScheduledCallback = scheduledHostCallback;\n    var prevTimeoutTime = timeoutTime;\n    scheduledHostCallback = null;\n    timeoutTime = -1;\n\n    var currentTime = exports.unstable_now();\n\n    var didTimeout = false;\n    if (frameDeadline - currentTime <= 0) {\n      // There's no time left in this idle period. Check if the callback has\n      // a timeout and whether it's been exceeded.\n      if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {\n        // Exceeded the timeout. Invoke the callback even though there's no\n        // time left.\n        didTimeout = true;\n      } else {\n        // No timeout.\n        if (!isAnimationFrameScheduled) {\n          // Schedule another animation callback so we retry later.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n        // Exit without invoking the callback.\n        scheduledHostCallback = prevScheduledCallback;\n        timeoutTime = prevTimeoutTime;\n        return;\n      }\n    }\n\n    if (prevScheduledCallback !== null) {\n      isFlushingHostCallback = true;\n      try {\n        prevScheduledCallback(didTimeout);\n      } finally {\n        isFlushingHostCallback = false;\n      }\n    }\n  };\n\n  var animationTick = function (rafTime) {\n    if (scheduledHostCallback !== null) {\n      // Eagerly schedule the next animation callback at the beginning of the\n      // frame. If the scheduler queue is not empty at the end of the frame, it\n      // will continue flushing inside that callback. If the queue *is* empty,\n      // then it will exit immediately. Posting the callback at the start of the\n      // frame ensures it's fired within the earliest possible frame. If we\n      // waited until the end of the frame to post the callback, we risk the\n      // browser skipping a frame and not firing the callback until the frame\n      // after that.\n      requestAnimationFrameWithTimeout(animationTick);\n    } else {\n      // No pending work. Exit.\n      isAnimationFrameScheduled = false;\n      return;\n    }\n\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If the calculated frame time gets lower than 8, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isMessageEventScheduled) {\n      isMessageEventScheduled = true;\n      port.postMessage(undefined);\n    }\n  };\n\n  requestHostCallback = function (callback, absoluteTimeout) {\n    scheduledHostCallback = callback;\n    timeoutTime = absoluteTimeout;\n    if (isFlushingHostCallback || absoluteTimeout < 0) {\n      // Don't wait for the next frame. Continue working ASAP, in a new event.\n      port.postMessage(undefined);\n    } else if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrameWithTimeout(animationTick);\n    }\n  };\n\n  cancelHostCallback = function () {\n    scheduledHostCallback = null;\n    isMessageEventScheduled = false;\n    timeoutTime = -1;\n  };\n}\n\nexports.unstable_ImmediatePriority = ImmediatePriority;\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\nexports.unstable_NormalPriority = NormalPriority;\nexports.unstable_IdlePriority = IdlePriority;\nexports.unstable_LowPriority = LowPriority;\nexports.unstable_runWithPriority = unstable_runWithPriority;\nexports.unstable_next = unstable_next;\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\nexports.unstable_cancelCallback = unstable_cancelCallback;\nexports.unstable_wrapCallback = unstable_wrapCallback;\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\nexports.unstable_shouldYield = unstable_shouldYield;\nexports.unstable_continueExecution = unstable_continueExecution;\nexports.unstable_pauseExecution = unstable_pauseExecution;\nexports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n  })();\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","ensureHostCallbackIsScheduled","isExecutingCallback","expirationTime","firstCallbackNode","isHostCallbackScheduled","cancelHostCallback","requestHostCallback","flushWork","flushFirstCallback","flushedNode","next","lastCallbackNode","previous","callback","priorityLevel","previousPriorityLevel","currentPriorityLevel","previousExpirationTime","currentExpirationTime","continuationCallback","continuationNode","nextAfterContinuation","node","flushImmediateWork","currentEventStartTime","ImmediatePriority","didTimeout","previousDidTimeout","currentDidTimeout","currentTime","unstable_now","shouldYieldToHost","Object","defineProperty","value","NormalPriority","localDate","Date","localSetTimeout","setTimeout","undefined","localClearTimeout","clearTimeout","localRequestAnimationFrame","requestAnimationFrame","localCancelAnimationFrame","cancelAnimationFrame","rAFID","rAFTimeoutID","requestAnimationFrameWithTimeout","timestamp","ANIMATION_FRAME_TIMEOUT","performance","now","Performance","exports.unstable_now","globalValue","window","_schedMock","globalImpl","MessageChannel","_callback","_flushCallback","cb","ms","console","error","scheduledHostCallback","isMessageEventScheduled","timeoutTime","isAnimationFrameScheduled","isFlushingHostCallback","frameDeadline","previousFrameTime","activeFrameTime","channel","port","port2","port1","onmessage","channel.port1.onmessage","event","prevScheduledCallback","prevTimeoutTime","animationTick","rafTime","nextFrameTime","postMessage","absoluteTimeout","unstable_ImmediatePriority","unstable_UserBlockingPriority","UserBlockingPriority","unstable_NormalPriority","unstable_IdlePriority","IdlePriority","unstable_LowPriority","LowPriority","unstable_runWithPriority","eventHandler","previousEventStartTime","unstable_next","unstable_scheduleCallback","deprecated_options","startTime","timeout","IMMEDIATE_PRIORITY_TIMEOUT","USER_BLOCKING_PRIORITY","maxSigned31BitInt","LOW_PRIORITY_TIMEOUT","NORMAL_PRIORITY_TIMEOUT","newNode","unstable_cancelCallback","callbackNode","unstable_wrapCallback","parentPriorityLevel","apply","arguments","unstable_getCurrentPriorityLevel","unstable_shouldYield","unstable_continueExecution","unstable_pauseExecution","unstable_getFirstCallbackNode"]
}
