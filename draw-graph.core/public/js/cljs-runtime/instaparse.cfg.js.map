{"version":3,"sources":["instaparse/cfg.cljc"],"mappings":";;;;;;;;;AAcA;;;;;;;;AAAA,AAAeA;AASf;;;;;;;;AAAA,AAAMC,AAOHC,AAAEC;AAPL,AAQE,AAAAC,AAAMJ;AAAN,AAAA,AAAA,AAAAK,AAAA,AAAAD;AACO,AAACG,AAAUL;;AADlB,AAAA,AAAAG,AAAA,AAAAD;AAEQ,AAACI,AAAON;;AAFhB,AAAA,AAAAG,AAAA,AAAAD;AAGW,AAAID;AAAe,AAACI,AAAUL;;AAAG,AAACM,AAAON;;;AAHpD,AAAA,AAAA,AAAAI,AAAA,AAAA,AAAAF;;;;;;AAKF;;;AAAA,AAAMK,AAEHC,AAAYC;AAFf,AAIW,AAACC,AAAWF;;AAEvB,AAAKG,AAAqB,AAAA,AAAA,AAACJ;AAC3B,AAAKK,AAAqB,AAAA,AAAA,AAACL;AAC3B,AAAKM,AAAqB,AAAA,AAAA,AAACN;AAC3B,AAAKO,AAAqB,AAAA,AAAA,AAACP;AAC3B,AAAA,AAAKQ;AAEL,AAAKC,AAAG,AAAA,AAAA,AAACT;AAET,AAAKU,AAAe,AAACC,AAAK,AAAA,AAACC;AAE3B,AAAKC,AACH,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAACC,AAES,AAACC,AAAS,AAACC,AAAIN,AACA,AAACO,AAAK,AAAA,AAACL,AACpB,AAACI,AAAI,AAAA,AAACjB,AAAa,AAAA,AAACa,AAAoB,AAAA,AAACb,AAClC,AAACiB,AAAI,AAACE,AAAOV,AACR,AAACW,AAAK,AAACH,AAAI,AAAA,AAACJ,AACD,AAACM,AAAOV,AACxB,AAACQ,AAAI,AAACE,AAAOT,AACR,AAACU,AAAK,AAACH,AAAI,AAAA,AAACJ,AACD,AAACM,AAAOT,AACxB,AAACW,AAAI,AAAA,AAACrB,AACD,AAAA,AAACA,AACD,AAAA,AAACA,AACD,AAAA,AAACA,AAChB,AAACiB,AAAI,AAACI,AAAI,AAAA,AAACR,AACD,AAAA,AAACA,AACNF,AACA,AAACC,AAAK,AAAA,AAACC,AACPF,AACA,AAAA,AAACE,AACD,AAACD,AAAK,AAACS,AAAI,AAAA,AAACR,AACD,AAACI,AAAI,AAAA,AAACJ,AAAoB,AAACQ,AAAI,AAAA,AAACrB,AAAY,AAAA,AAACA,AAAa,AAAA,AAACa,AAC7E,AAACI,AACC,AAACK,AAAI,AAAA,AAACT,AACN,AAACM,AACC,AAAA,AAAA,AAAClB,AACK,AAACgB,AAAI,AAACL,AAAK,AAAA,AAACZ,AACPW,AACA,AAAA,AAACE,AACDF,AACA,AAACC,AAAK,AAAA,AAACZ,AACT,AAACgB,AAAS,AAACK,AAAI,AAAA,AAACR,AAAS,AAAA,AAACA,AACjC,AAACI,AAAI,AAAA,AAACJ,AACD,AAACO,AACC,AAACH,AACCN,AACA,AAACC,AAAK,AAAA,AAACZ,AACPW,AACA,AAAA,AAACE,AACV,AAACI,AAAI,AAAA,AAACJ,AACD,AAACK,AACC,AAACD,AACCN,AACA,AAACC,AAAK,AAAA,AAACZ,AACPW,AACA,AAAA,AAACE,AACR,AAACI,AAAI,AAACL,AAAK,AAAA,AAACZ,AACPW,AACA,AAAA,AAACE,AACDF,AACA,AAACC,AAAK,AAAA,AAACZ,AACb,AAACiB,AAAI,AAACL,AAAK,AAAA,AAACZ,AACPW,AACA,AAAA,AAACE,AACDF,AACA,AAACC,AAAK,AAAA,AAACZ,AACb,AAACkB,AAAK,AAACD,AACCN,AACA,AAACU,AAAI,AAAA,AAACR,AAAY,AAAA,AAACA,AAAU,AAAA,AAACA,AAC9BF,AACL,AAACU,AACC,AAACF,AAAOd,AACR,AAACc,AAAOZ,AACV,AAACc,AACC,AAACF,AAAOb,AACR,AAACa,AAAOX,AACb,AAACa,AACC,AAACJ,AAAI,AAACL,AAAK,AAAA,AAACZ,AACPW,AACA,AAAA,AAACE,AACDF,AACA,AAACC,AAAK,AAAA,AAACZ,AACZ,AAACiB,AAAI,AAAA,AAACJ,AACDF,AACA,AAACC,AAAK,AAAA,AAACZ,AACb,AAACqB,AACC,AAACJ,AAAI,AAACL,AAAK,AAAA,AAACZ,AACPW,AACA,AAAA,AAACE,AACDF,AACA,AAACC,AAAK,AAAA,A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","names":["instaparse.cfg/*case-insensitive-literals*","instaparse.cfg/string+","s","ci-by-default?","G__53930","cljs.core._EQ_","js/Error","instaparse.combinators-source/string-ci","instaparse.combinators-source/string","instaparse.cfg/regex-doc","pattern-str","comment","cljs.core/re-pattern","instaparse.cfg/single-quoted-string","instaparse.cfg/single-quoted-regexp","instaparse.cfg/double-quoted-string","instaparse.cfg/double-quoted-regexp","instaparse.cfg/inside-comment","instaparse.cfg/ws","instaparse.cfg/opt-whitespace","instaparse.combinators-source/hide","instaparse.combinators-source/nt","instaparse.cfg/cfg","instaparse.reduction.apply_standard_reductions","instaparse.combinators-source/hide-tag","instaparse.combinators_source.cat","instaparse.combinators-source/plus","instaparse.combinators-source/regexp","instaparse.combinators-source/star","instaparse.combinators_source.alt","instaparse.combinators-source/neg","instaparse.cfg/tag","cljs.core/first","instaparse.cfg/contents","cljs.core/next","instaparse.cfg/content","cljs.core/fnext","instaparse.cfg/escape","sq","cljs.core/seq","v","temp__5733__auto__","c","G__53956","c2","cljs.core/second","cljs.core.drop","cljs.core.conj","instaparse.util.throw_runtime_exception","cljs.core.apply","cljs.core/str","instaparse.cfg/safe-read-string","cljs.tools.reader/read-string*","cljs.tools.reader.reader_types.string_push_back_reader","instaparse.cfg/process-string","stripped","cljs.core.subs","cljs.core/count","remove-escaped-single-quotes","final-string","instaparse.cfg/process-regexp","instaparse.cfg/build-rule","tree","G__53973","cljs.core/Keyword","vec__53980","cljs.core.nth","nt","alt-or-ord","cljs.core.keyword","G__53986","instaparse.combinators-source/alt","cljs.core.map","instaparse.combinators-source/ord","G__53987","instaparse.combinators-source/cat","instaparse.combinators-source/opt","G__53991","G__53992","G__53993","instaparse.combinators-source/look","G__53994","G__53995","instaparse.combinators-source/Epsilon","instaparse.cfg/seq-nt","parser","G__53998","cljs.core.mapcat","instaparse.cfg/check-grammar","grammar-map","valid-nts","cljs.core/set","cljs.core/keys","seq__54007","chunk__54008","count__54009","i__54010","temp__5735__auto__","cljs.core/chunked-seq?","c__4609__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core.distinct","cljs.core/vals","instaparse.cfg/build-parser","spec","output-format","rules","instaparse.gll/parse","instaparse.gll/Failure","sb__4720__auto__","goog.string/StringBuffer","*print-newline*-orig-val__54025","cljs.core/*print-newline*","*print-fn*-orig-val__54026","cljs.core/*print-fn*","*print-newline*-temp-val__54027","*print-fn*-temp-val__54028","x__4721__auto__","cljs.core.println","productions","start-production","cljs.core.into","instaparse.cfg/build-parser-from-combinators","instaparse.util.throw_illegal_argument_exception","var_args","args__4795__auto__","len__4789__auto__","i__4790__auto__","argseq__4796__auto__","cljs.core/IndexedSeq","instaparse.cfg/ebnf","p__54034","map__54035","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","seq54030","G__54031","self__4776__auto__","opts","*case-insensitive-literals*-orig-val__54041","*case-insensitive-literals*-temp-val__54042","*print-newline*-orig-val__54044","*print-fn*-orig-val__54045","*print-newline*-temp-val__54046","*print-fn*-temp-val__54047","cljs.core/ffirst"],"sourcesContent":["(ns instaparse.cfg\r\n  \"This is the context free grammar that recognizes context free grammars.\"\r\n  (:refer-clojure :exclude [cat])\r\n  (:require [instaparse.combinators-source :refer\r\n             [Epsilon opt plus star rep alt ord cat string-ci string\r\n              string-ci regexp nt look neg hide hide-tag]]\r\n            [instaparse.reduction :refer [apply-standard-reductions]]\r\n            [instaparse.gll :refer [parse]]\r\n            [instaparse.util :refer [throw-illegal-argument-exception\r\n                                     throw-runtime-exception]]\r\n            [clojure.string :as str]\r\n            #?(:cljs [cljs.tools.reader :as reader])\r\n            #?(:cljs [cljs.tools.reader.reader-types :as readers])))\r\n\r\n(def ^:dynamic *case-insensitive-literals*\r\n  \"Sets whether all string literal terminals in a built grammar\r\n  will be treated as case insensitive.\r\n\r\n  `true`: case-insensitive\r\n  `false`: case-sensitive\r\n  `:default`: case-sensitive for EBNF, case-insensitive for ABNF\"\r\n  :default)\r\n\r\n(defn string+\r\n  \"Returns a string combinator that may be case-insensntive, based\r\n  on (in priority order):\r\n\r\n  1) the value of `*case-insensitive-literals*`, if it has been\r\n  overridden to a boolean\r\n  2) the supplied `ci-by-default?` parameter\"\r\n  [s ci-by-default?]\r\n  (case *case-insensitive-literals*\r\n    true (string-ci s)\r\n    false (string s)\r\n    :default (if ci-by-default? (string-ci s) (string s))))\r\n\r\n(defn regex-doc\r\n  \"Adds a comment to a Clojure regex, or no-op in ClojureScript\"\r\n  [pattern-str comment]\r\n  #?(:clj (re-pattern (str pattern-str \"(?x) #\" comment))\r\n     :cljs (re-pattern pattern-str)))\r\n\r\n(def single-quoted-string (regex-doc #\"'[^'\\\\]*(?:\\\\.[^'\\\\]*)*'\" \"Single-quoted string\"))\r\n(def single-quoted-regexp (regex-doc #\"#'[^'\\\\]*(?:\\\\.[^'\\\\]*)*'\" \"Single-quoted regexp\"))\r\n(def double-quoted-string (regex-doc #\"\\\"[^\\\"\\\\]*(?:\\\\.[^\\\"\\\\]*)*\\\"\" \"Double-quoted string\"))\r\n(def double-quoted-regexp (regex-doc #\"#\\\"[^\\\"\\\\]*(?:\\\\.[^\\\"\\\\]*)*\\\"\" \"Double-quoted regexp\"))\r\n(def inside-comment #?(:clj #\"(?s)(?:(?!(?:\\(\\*|\\*\\))).)*(?x) #Comment text\"\r\n                       :cljs #\"(?:(?!(?:\\(\\*|\\*\\)))[\\s\\S])*\"))\r\n(def ws (regex-doc \"[,\\\\s]*\" \"optional whitespace\"))\r\n\r\n(def opt-whitespace (hide (nt :opt-whitespace)))\r\n\r\n(def cfg \r\n  (apply-standard-reductions \r\n    :hiccup    ; use the hiccup output format \r\n    {:rules (hide-tag (cat opt-whitespace\r\n                           (plus (nt :rule))))\r\n     :comment (cat (string \"(*\") (nt :inside-comment) (string \"*)\"))\r\n     :inside-comment (cat (regexp inside-comment)\r\n                          (star (cat (nt :comment)\r\n                                     (regexp inside-comment))))\r\n     :opt-whitespace (cat (regexp ws)\r\n                          (star (cat (nt :comment)\r\n                                     (regexp ws))))\r\n     :rule-separator (alt (string \":\")\r\n                          (string \":=\")\r\n                          (string \"::=\")\r\n                          (string \"=\"))\r\n     :rule (cat (alt (nt :nt)\r\n                     (nt :hide-nt))\r\n                opt-whitespace\r\n                (hide (nt :rule-separator))\r\n                opt-whitespace\r\n                (nt :alt-or-ord)\r\n                (hide (alt (nt :opt-whitespace)\r\n                           (cat (nt :opt-whitespace) (alt (string \";\") (string \".\")) (nt :opt-whitespace)))))          \r\n     :nt (cat\r\n           (neg (nt :epsilon))\r\n           (regexp\r\n             (regex-doc \"[^, \\\\r\\\\t\\\\n<>(){}\\\\[\\\\]+*?:=|'\\\"#&!;./]+\" \"Non-terminal\")))\r\n          :hide-nt (cat (hide (string \"<\"))\r\n                        opt-whitespace\r\n                        (nt :nt)\r\n                        opt-whitespace\r\n                        (hide (string \">\")))\r\n          :alt-or-ord (hide-tag (alt (nt :alt) (nt :ord)))\r\n          :alt (cat (nt :cat)                           \r\n                    (star\r\n                      (cat\r\n                        opt-whitespace\r\n                        (hide (string \"|\"))\r\n                        opt-whitespace\r\n                        (nt :cat))))\r\n          :ord (cat (nt :cat)\r\n                    (plus\r\n                      (cat\r\n                        opt-whitespace\r\n                        (hide (string \"/\"))\r\n                        opt-whitespace\r\n                        (nt :cat))))\r\n          :paren (cat (hide (string \"(\"))\r\n                      opt-whitespace\r\n                      (nt :alt-or-ord)\r\n                      opt-whitespace\r\n                      (hide (string \")\")))\r\n          :hide (cat (hide (string \"<\"))\r\n                     opt-whitespace\t\r\n                     (nt :alt-or-ord)\r\n                     opt-whitespace\r\n                     (hide (string \">\")))\r\n          :cat (plus (cat\r\n                       opt-whitespace\r\n                       (alt (nt :factor) (nt :look) (nt :neg))\r\n                       opt-whitespace))\r\n          :string (alt\r\n                    (regexp single-quoted-string)\r\n                    (regexp double-quoted-string))\r\n          :regexp (alt\r\n                    (regexp single-quoted-regexp)\r\n                    (regexp double-quoted-regexp))\r\n          :opt (alt\r\n                 (cat (hide (string \"[\"))\r\n                      opt-whitespace\r\n                      (nt :alt-or-ord)\r\n                      opt-whitespace\r\n                      (hide (string \"]\")))\r\n                 (cat (nt :factor)\r\n                      opt-whitespace\r\n                      (hide (string \"?\"))))\r\n          :star (alt\r\n                  (cat (hide (string \"{\"))\r\n                       opt-whitespace\r\n                       (nt :alt-or-ord)\r\n                       opt-whitespace\r\n                       (hide (string \"}\")))\r\n                  (cat (nt :factor)\r\n                       opt-whitespace\r\n                       (hide (string \"*\"))))\r\n          :plus (cat (nt :factor)\r\n                     opt-whitespace\r\n                     (hide (string \"+\")))\r\n          :look (cat (hide (string \"&\"))\r\n                     opt-whitespace\r\n                     (nt :factor))\r\n          :neg (cat (hide (string \"!\"))\r\n                    opt-whitespace\r\n                    (nt :factor))\r\n          :epsilon (alt (string \"Epsilon\")\r\n                        (string \"epsilon\")\r\n                        (string \"EPSILON\")\r\n                        (string \"eps\")\r\n                        (string \"\\u03b5\"))\r\n          :factor (hide-tag (alt (nt :nt)\r\n                                 (nt :string)\r\n                                 (nt :regexp)\r\n                                 (nt :opt)     \r\n                                 (nt :star)\r\n                                 (nt :plus)\r\n                                 (nt :paren)\r\n                                 (nt :hide)\r\n                                 (nt :epsilon)))\r\n     ;; extra entrypoint to be used by the ebnf combinator\r\n     :rules-or-parser (hide-tag (alt (nt :rules) (nt :alt-or-ord)))}))\r\n\r\n; Internally, we're converting the grammar into a hiccup parse tree\r\n; Here's how you extract the relevant information\r\n(def tag first)\r\n(def contents next)\r\n(def content fnext)\r\n\r\n;;;; Helper functions for reading strings and regexes\r\n\r\n(defn escape\r\n  \"Converts escaped single-quotes to unescaped, and unescaped double-quotes to escaped\"\r\n  [s]\r\n  (loop [sq (seq s), v []]\r\n    (if-let [c (first sq)]\r\n      (case c\r\n        \\\\ (if-let [c2 (second sq)]\r\n             (if (= c2 \\')\r\n               (recur (drop 2 sq) (conj v c2))\r\n               (recur (drop 2 sq) (conj v c c2)))\r\n             (throw-runtime-exception\r\n               \"Encountered backslash character at end of string: \" s))\r\n        \\\" (recur (next sq) (conj v \\\\ \\\"))\r\n        (recur (next sq) (conj v c)))\r\n      (apply str v))))                     \r\n\r\n;(defn safe-read-string [s]\r\n;  (binding [*read-eval* false]\r\n;    (read-string s)))\r\n\r\n#?(:clj\r\n   (defn wrap-reader [reader]\r\n     (let [{major :major minor :minor} *clojure-version*]\r\n       (if (and (<= major 1) (<= minor 6))\r\n         reader\r\n         (fn [r s] (reader r s {} (java.util.LinkedList.)))))))\r\n\r\n#?(:clj\r\n   (let [string-reader (wrap-reader\r\n                         (clojure.lang.LispReader$StringReader.))]\r\n     (defn safe-read-string\r\n       \"Expects a double-quote at the end of the string\"\r\n       [s]\r\n       (with-in-str s (string-reader *in* nil))))\r\n\r\n   :cljs\r\n   (defn safe-read-string [s]\r\n     (reader/read-string* (readers/string-push-back-reader s) nil nil nil)))\r\n\r\n; I think re-pattern is sufficient, but here's how to do it without.\r\n;(let [regexp-reader (clojure.lang.LispReader$RegexReader.)]\r\n;  (defn safe-read-regexp\r\n;    \"Expects a double-quote at the end of the string\"\r\n;    [s]\r\n;    (with-in-str s (regexp-reader *in* nil))))\r\n\r\n(defn process-string\r\n  \"Converts single quoted string to double-quoted\"\r\n  [s]\r\n  (let [stripped\r\n        (subs s 1 (dec (count s)))\r\n        remove-escaped-single-quotes\r\n        (escape stripped)\r\n        final-string\r\n        (safe-read-string (str remove-escaped-single-quotes \\\"))]            \r\n\r\n    final-string))\r\n\r\n(defn process-regexp\r\n  \"Converts single quoted regexp to double-quoted\"\r\n  [s]\r\n  ;(println (with-out-str (pr s)))\r\n  (let [stripped\r\n        (subs s 2 (dec (count s)))\r\n        remove-escaped-single-quotes\r\n        (escape stripped)\r\n        final-string\r\n        (re-pattern remove-escaped-single-quotes)]\r\n;        (safe-read-regexp (str remove-escaped-single-quotes \\\"))]\r\n        \r\n    final-string))\r\n\r\n;;; Now we need to convert the grammar's parse tree into combinators\r\n\r\n(defn build-rule\r\n  \"Convert one parsed rule from the grammar into combinators\"\r\n  [tree]\r\n  (case (tag tree)\r\n    :rule (let [[nt alt-or-ord] (contents tree)]\r\n            (if (= (tag nt) :hide-nt)\r\n              [(keyword (content (content nt)))\r\n               (hide-tag (build-rule alt-or-ord))]\r\n              [(keyword (content nt))\r\n               (build-rule alt-or-ord)]))\r\n    :nt (nt (keyword (content tree)))\r\n    :alt (apply alt (map build-rule (contents tree)))\r\n    :ord (apply ord (map build-rule (contents tree)))\r\n    :paren (recur (content tree))\r\n    :hide (hide (build-rule (content tree)))\r\n    :cat (apply cat (map build-rule (contents tree)))\r\n    :string (string+ (process-string (content tree)) false)\r\n    :regexp (regexp (process-regexp (content tree)))\r\n    :opt (opt (build-rule (content tree)))\r\n    :star (star (build-rule (content tree)))\r\n    :plus (plus (build-rule (content tree)))\r\n    :look (look (build-rule (content tree)))\r\n    :neg (neg (build-rule (content tree)))\r\n    :epsilon Epsilon))\r\n\r\n(defn seq-nt\r\n  \"Returns a sequence of all non-terminals in a parser built from combinators.\"\r\n  [parser]\r\n  (case (:tag parser)\r\n    :nt [(:keyword parser)]\r\n    (:string :string-ci :char :regexp :epsilon) []\r\n    (:opt :plus :star :look :neg :rep) (recur (:parser parser))\r\n    (:alt :cat) (mapcat seq-nt (:parsers parser))\r\n    :ord (mapcat seq-nt \r\n                 [(:parser1 parser) (:parser2 parser)])))                 \r\n    \r\n(defn check-grammar\r\n  \"Throw error if grammar uses any invalid non-terminals in its productions\"\r\n  [grammar-map]\r\n  (let [valid-nts (set (keys grammar-map))]\r\n    (doseq [nt (distinct (mapcat seq-nt (vals grammar-map)))]\r\n      (when-not (valid-nts nt)\r\n        (throw-runtime-exception\r\n          (subs (str nt) 1)\r\n          \" occurs on the right-hand side of your grammar, but not on the left\"))))\r\n  grammar-map)\r\n          \r\n(defn build-parser [spec output-format]\r\n  (let [rules (parse cfg :rules spec false)]\r\n    (if (instance? instaparse.gll.Failure rules)\r\n      (throw-runtime-exception\r\n        \"Error parsing grammar specification:\\n\"\r\n        (with-out-str (println rules)))\r\n      (let [productions (map build-rule rules)\r\n            start-production (first (first productions))] \r\n        {:grammar (check-grammar (apply-standard-reductions output-format (into {} productions)))\r\n         :start-production start-production\r\n         :output-format output-format}))))\r\n\r\n(defn build-parser-from-combinators [grammar-map output-format start-production]\r\n  (if (nil? start-production)\r\n    (throw-illegal-argument-exception\r\n      \"When you build a parser from a map of parser combinators, you must provide a start production using the :start keyword argument.\")\r\n    {:grammar (check-grammar (apply-standard-reductions output-format grammar-map))\r\n     :start-production start-production\r\n     :output-format output-format}))\r\n\r\n(defn ebnf\r\n  \"Takes an EBNF grammar specification string and returns the combinator version.\r\nIf you give it the right-hand side of a rule, it will return the combinator equivalent.\r\nIf you give it a series of rules, it will give you back a grammar map.   \r\nUseful for combining with other combinators.\"\r\n  [spec & {:as opts}]\r\n  (binding [*case-insensitive-literals* (:string-ci opts :default)]\r\n    (let [rules (parse cfg :rules-or-parser spec false)]\r\n      (cond\r\n        (instance? instaparse.gll.Failure rules)\r\n        (throw-runtime-exception\r\n          \"Error parsing grammar specification:\\n\"\r\n          (with-out-str (println rules)))\r\n        (= :rule (ffirst rules))\r\n        (into {} (map build-rule rules))\r\n\r\n        :else (build-rule (first rules))))))\r\n"]}