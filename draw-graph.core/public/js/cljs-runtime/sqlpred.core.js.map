{"version":3,"sources":["sqlpred/core.cljc"],"mappings":"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","names":["sqlpred.core/err","error-string","js/Error","sqlpred.core/whitespace","instaparse.core/parser","sqlpred.core/filter-grammar","instaparse.core.parser","sqlpred.core/filter-parser","sqlpred.core/drop-first-last","s","cljs.core.apply","cljs.core/str","cljs.core/rest","cljs.core.drop_last","sqlpred.core/filter-transform","parsed","keywordize-keys?","G__55417","G__55418","instaparse.core/transform","args","clojure.string/trim","arg","cljs.core.keyword","cljs.core.map","cljs.core/second","cljs.core.into","sqlpred.core/filter-group","transformed","t1","p1__55423#","cljs.core.partition_by","cljs.core._EQ_","p1__55425#","cljs.core.filter","cljs.core.not_EQ_","p1__55427#","sqlpred.core/submap?","sub","m","cljs.core/select-keys","cljs.core/keys","sqlpred.core/not-submap?","cljs.core/complement","sqlpred.core/parse-num","e55437","n","cljs.reader.read_string","e","sqlpred.core/equality-match?","k","v","not?","skip?","item","and__4174__auto__","cljs.core/contains?","cljs.core.get","sqlpred.core/inequality-match?","op","v-item","G__55438","sqlpred.core/multi-equality?","vs","cljs.core/every?","cljs.core/true?","p1__55443#","cljs.core/some","p1__55444#","sqlpred.core/match-anything?","clause","p1__55451#","sqlpred.core/clause-matches?","term","val","sqlpred.core/and-statements?","ands","cljs.core.reduce","a","c","cljs.core/not","cljs.core/reduced","sqlpred.core/or-statements?","ors","var_args","args__4795__auto__","len__4789__auto__","i__4790__auto__","argseq__4796__auto__","cljs.core/IndexedSeq","sqlpred.core/sql-pred","p__55475","map__55476","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","seq55470","G__55471","cljs.core/first","cljs.core/next","self__4776__auto__","statement","skip-missing?","terms","cljs.core.partial"],"sourcesContent":["(ns sqlpred.core\n  (:require [clojure.string                       :as str]\n            [loom.graph                           :as loom]\n            #?(:clj [instaparse.core :as insta :refer [defparser]]\n               :cljs [instaparse.core :as insta :refer-macros [defparser]])))\n\n\n(defn- err\n  \"Creates an exception object with error-string.\"\n  [error-string]\n  #?(:clj (Exception. ^String error-string)\n     :cljs (js/Error. error-string)))\n\n\n(def ^{:private true} whitespace\n  (insta/parser\n    \"whitespace = #'\\\\s+'\"))\n\n\n(def ^{:private true} filter-grammar\n  (str\n   \"S = Clause (Conjunction Clause)*\n   Conjunction = ' and ' | ' or '\n   Clause = term Op-S value | term Op-M list\n   term = Word\n   Op-S = '='|'not ='|'>'|'>='|'<'|'<='\n   Op-M = ' in ' | ' not in '\n   value = Word | QuotedWord\n   list = <'('> value (<','> value)* <')'>\n   <Word> = #'(^(?!\\\\()[a-zA-Z0-9-\\\\.]*)'\n   QuotedWord = #\\\"'([^']*?)'\\\"\"))\n\n\n(defparser ^{:private true} filter-parser\n  filter-grammar\n  :auto-whitespace whitespace)\n\n\n(defn drop-first-last [s]\n  (apply str (rest (drop-last s))))\n\n\n(defn- filter-transform [parsed keywordize-keys?]\n  (insta/transform\n   {:S (fn [& args] args)\n    :Conjunction str/trim\n    :Op-S (fn [arg] [:op (str/trim arg)])\n    :Op-M (fn [arg] [:op (str/trim arg)])\n    :term (fn [arg] [:term (if keywordize-keys? (keyword arg) arg)])\n    :list (fn [& args] [:value (map second args)])\n    :QuotedWord (fn [arg] (drop-first-last arg))\n    :value (fn [arg] [:value (str/trim arg)])\n    :Clause (fn [& args] (into {} args))}\n   parsed))\n\n\n(defn- filter-group [transformed]\n  (let [t1 (->> transformed\n                (partition-by #(= \"or\" %))\n                (filter #(not= '(\"or\") %)))]\n    (map (fn [s] (filter #(not= \"and\" %) s)) t1)))\n\n\n(defn- submap?\n  \"Checks whether m contains all entries in sub.\"\n  [sub m]\n  (= sub (select-keys m (keys sub))))\n\n\n(def ^{:private true} not-submap? (complement submap?))\n\n\n(defn- parse-num [s]\n  (if (number? s) s\n      (try\n        (let [n #?(:clj (clojure.edn/read-string s)\n                   :cljs (cljs.reader/read-string s))]\n          (if (number? n) n (throw (err (str \"Could not convert \" s \" to a number.\")))))\n        #? (:clj (catch\n                     Exception\n                     e\n                   (throw (err (str \"Could not convert \" s \" to a number.\"))))\n            :cljs (catch\n                      js/Error\n                      e\n                    (throw (err (str \"Could not convert \" s \" to a number.\"))))))))\n\n\n(defn- equality-match?\n  \"takes a term key and term value and assesses whether the key and value\n   is a submap of item.\"\n  [k v not? skip? item]\n  (if (and skip? (not (contains? item k)))\n    true              ;; return true is item doesn't contain key and skip is on\n    (let [v (if (number? (get item k)) (parse-num v) v)]  ;; convert to number if necessary\n      (if not?\n        (not-submap? {k v} item)\n        (submap? {k v} item)))))\n\n\n(defn- inequality-match?\n  \"takes a term key, an op and term value and assessing whether the value of the\n   key in the item matches the condition.\"\n  [k op v skip? item]\n  (if (and skip? (not (contains? item k)))\n    true              ;; skip. return true\n    (let [v (parse-num v)\n          v-item (parse-num (get item k))]\n      (when (not (number? v-item)) (throw (err \"internal oops!\")))\n      (case op\n        \">\" (> v-item v)\n        \"<\" (< v-item v)\n        \">=\" (>= v-item v)\n        \"<=\" (<= v-item v)\n        (throw (err (str op \" is not a valid comparison operator.\")))))))\n\n\n(defn- multi-equality?\n  [k vs not? skip? item]\n  (if (and skip? (not (contains? item k)))\n    true               ;; skip. return true\n    (if not?\n      (every? true? (map #(equality-match? k % true skip? item) vs))\n      (some? (some true? (map #(equality-match? k % false skip? item) vs))))))\n\n\n(defn- match-anything? [clause item]\n  \"If the value of the item is the special char then matching always succeeds.\"\n  (some #(= (get item (:term clause)) %)\n        [\"<all>\"]))\n\n\n(defn- clause-matches?\n  [clause skip? item]\n  (let [op   (:op clause)\n        term (:term clause)\n        val  (:value clause)]\n    (cond\n      (match-anything? clause item)    true\n      (= \"=\" op)       (equality-match? term val false skip? item)\n      (= \"not =\" op)   (equality-match? term val true skip? item)\n      (or (= \">\" op)\n          (= \"<\" op)\n          (= \">=\" op)\n          (= \"<=\" op)) (inequality-match? term op val skip? item)\n      (= \"in\" op)      (multi-equality? term val false skip? item)\n      (= \"not in\" op)  (multi-equality? term val true skip? item)\n      :else (throw (err (str op \" is not a valid comparison operator.\"))))))\n\n\n(defn- and-statements?\n  [ands skip? item]\n  (reduce\n   (fn [a c]\n     (if (not a)\n       (reduced false)\n       (clause-matches? c skip? item)))\n   true\n   ands))\n\n\n(defn- or-statements?\n  [ors skip? item]\n  (reduce\n   (fn [a c]\n     (if a\n       (reduced true)\n       (and-statements? c skip? item)))\n   false\n   ors))\n\n\n(defn sql-pred\n  [statement & {:keys [keywordize-keys? skip-missing?]\n                :or {keywordize-keys? false skip-missing? false}}]\n  (let [terms (-> statement\n                  filter-parser\n                  (filter-transform keywordize-keys?)\n                  filter-group)]\n    (partial or-statements? terms skip-missing?)))\n"]}