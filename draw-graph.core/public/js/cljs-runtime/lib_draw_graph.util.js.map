{"version":3,"sources":["lib_draw_graph/util.cljc"],"mappings":"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","names":["lib-draw-graph.util/err","error-string","js/Error","var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","lib-draw-graph.util/deep-merge","seq35351","self__4718__auto__","cljs.core/seq","maps","cljs.core/every?","cljs.core/map?","cljs.core.apply.cljs$core$IFn$_invoke$arity$3","cljs.core/merge-with","cljs.core/last","lib-draw-graph.util/update-keys","m","update?","key-fn","down","x","p","cljs.core/map-entry?","vec__35365","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","k","v","cljs.core/first","f","cljs.core/coll?","cljs.core/seq?","p1__35363#","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core.into.cljs$core$IFn$_invoke$arity$2","cljs.core/empty","p1__35364#","lib-draw-graph.util/parse-int","s","e35383","n","cljs.reader.read_string.cljs$core$IFn$_invoke$arity$1","cljs.core/integer?","e","lib-draw-graph.util/parse-float","e35390","cljs.core/float?","lib-draw-graph.util/predecessors-not-self","g","predec","loom.graph/predecessors*","p1__35403#","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","lib-draw-graph.util/successors-not-self","succs","loom.graph/successors*","p1__35404#","lib-draw-graph.util/root?","cljs.core/empty?","lib-draw-graph.util/roots","p1__35412#","loom.graph/nodes"],"sourcesContent":["(ns ^{:doc \"Common utilities.\"\n      :author \"Jude Payne\"}\n  lib-draw-graph.util\n  (:require\n        [loom.graph           :as loom.graph]))\n\n\n(defn err\n  \"Creates an exception object with error-string.\"\n  [error-string]\n  #?(:clj (Exception. ^String error-string)\n     :cljs (js/Error. error-string)))\n\n\n(defn deep-merge\n  \"Like merge, but merges maps recursively.\"\n  [& maps]\n  (if (every? map? maps)\n    (apply merge-with deep-merge maps)\n    (last maps)))\n\n\n(defn update-keys\n  \"Walks a nested map m recursively updating all keys with the supplied\n   key-fn where the supplied predicate update? fn for the key is true.\n   key-fn should have one parameter; the key.\n   update? should accept two parameters; the key and the parent key.\"\n  [m update? key-fn]\n  (let [down (fn f [x p]\n               (cond\n                 (map-entry? x)   (let [[k v] x]\n                                    (if (nil? v) nil   ;;prunes where v is nil\n                                        (first {(f k p)\n                                                (if (coll? v)\n                                                  (f v k)\n                                                  v)})))\n                 \n                 (seq? x)         (map #(f % p) x)\n\n                 (coll? x)        (into (empty x) (map #(f % p) x))\n\n                 :else            (if (update? x p) (key-fn x) x)))]\n     (down m nil)))\n\n\n\n(defn parse-int [s]\n  (try\n    (let [n #?(:clj (Integer/parseInt s)\n               :cljs (cljs.reader/read-string s))]\n      (if (integer? n) n (throw (err (str s \" should be an integer.\")))))\n    #? (:clj (catch Exception e (throw (err (str s \" should be an integer.\"))))\n        :cljs (catch js/Error e (throw (err (str s \" should be an integer.\")))))))\n\n\n(defn parse-float [s]\n  (try\n    (let [n #?(:clj (Float/parseFloat s)\n               :cljs (cljs.reader/read-string s))]\n      (if (float? n) n (throw (err (str s \" should be a floating point number.\")))))\n    #? (:clj (catch Exception e (throw (err (str s \" should be a floating point number.\"))))\n        :cljs (catch js/Error e (throw (err (str s \" should be a floating point number.\")))))))\n\n\n;; -----------------------------\n;; Loom.graph section\n\n\n(defn predecessors-not-self\n  \"Returns predecessors not including self\"\n  [g n]\n  (let [predec (loom.graph/predecessors* g n)]\n    (filter #(not (= n %)) predec)))\n\n\n(defn successors-not-self\n  \"Returns successors not including self\"\n  [g n]\n  (let [succs (loom.graph/successors* g n)]\n    (filter #(not (= n %)) succs)))\n\n\n(defn root?\n  \"Predicate for whether the node in the graph is a root.\"\n  [g n]\n  (empty? (predecessors-not-self g n)))\n\n\n(defn roots\n  \"Returns the roots from the graph.\"\n  [g]\n  (filter #(root? g %) (loom.graph/nodes g)))\n\n\n\n"]}