{"version":3,"sources":["lib_draw_graph/util.cljc"],"mappings":"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","names":["lib-draw-graph.util/err","error-string","js/Error","var_args","args__4795__auto__","len__4789__auto__","i__4790__auto__","argseq__4796__auto__","cljs.core/IndexedSeq","lib-draw-graph.util/deep-merge","seq36767","self__4777__auto__","cljs.core/seq","maps","cljs.core/every?","cljs.core/map?","cljs.core.apply","cljs.core/merge-with","cljs.core/last","lib-draw-graph.util/update-keys","m","update?","key-fn","down","x","p","cljs.core/map-entry?","vec__36779","cljs.core.nth","k","v","cljs.core/first","f","cljs.core/coll?","cljs.core/seq?","p1__36776#","cljs.core.map","cljs.core.into","cljs.core/empty","p1__36777#","lib-draw-graph.util/parse-int","s","e36791","n","cljs.reader.read_string","cljs.core/integer?","e","lib-draw-graph.util/parse-float","e36792","cljs.core/float?","lib-draw-graph.util/multigraph?","g","lib-draw-graph.util/predecessors-not-self","predec","loom.graph/predecessors*","p1__36793#","cljs.core.filter","cljs.core._EQ_","lib-draw-graph.util/successors-not-self","succs","loom.graph/successors*","p1__36800#","lib-draw-graph.util/root?","cljs.core/empty?","lib-draw-graph.util/roots","p1__36801#","loom.graph/nodes"],"sourcesContent":["(ns ^{:doc \"Common utilities.\"\n      :author \"Jude Payne\"}\n  lib-draw-graph.util\n  (:require\n        [loom.graph           :as loom.graph]\n        [extra-loom.multigraph :as multigraph]))\n\n\n(defn err\n  \"Creates an exception object with error-string.\"\n  [error-string]\n  #?(:clj (Exception. ^String error-string)\n     :cljs (js/Error. error-string)))\n\n\n(defn deep-merge\n  \"Like merge, but merges maps recursively.\"\n  [& maps]\n  (if (every? map? maps)\n    (apply merge-with deep-merge maps)\n    (last maps)))\n\n\n(defn update-keys\n  \"Walks a nested map m recursively updating all keys with the supplied\n   key-fn where the supplied predicate update? fn for the key is true.\n   key-fn should have one parameter; the key.\n   update? should accept two parameters; the key and the parent key.\"\n  [m update? key-fn]\n  (let [down (fn f [x p]\n               (cond\n                 (map-entry? x)   (let [[k v] x]\n                                    (if (nil? v) nil   ;;prunes where v is nil\n                                        (first {(f k p)\n                                                (if (coll? v)\n                                                  (f v k)\n                                                  v)})))\n                 \n                 (seq? x)         (map #(f % p) x)\n\n                 (coll? x)        (into (empty x) (map #(f % p) x))\n\n                 :else            (if (update? x p) (key-fn x) x)))]\n     (down m nil)))\n\n\n\n(defn parse-int [s]\n  (try\n    (let [n #?(:clj (Integer/parseInt s)\n               :cljs (cljs.reader/read-string s))]\n      (if (integer? n) n (throw (err (str s \" should be an integer.\")))))\n    #? (:clj (catch Exception e (throw (err (str s \" should be an integer.\"))))\n        :cljs (catch js/Error e (throw (err (str s \" should be an integer.\")))))))\n\n\n(defn parse-float [s]\n  (try\n    (let [n #?(:clj (Float/parseFloat s)\n               :cljs (cljs.reader/read-string s))]\n      (if (float? n) n (throw (err (str s \" should be a floating point number.\")))))\n    #? (:clj (catch Exception e (throw (err (str s \" should be a floating point number.\"))))\n        :cljs (catch js/Error e (throw (err (str s \" should be a floating point number.\")))))))\n\n\n;; -----------------------------\n;; Loom.graph section\n\n;; tell the difference between a Loom graph and an Extra-Loom graph\n\n(defn multigraph?\n  \"Is the graph an extra-loom graph (which has different edge attrs)?\"\n  [g]\n  )\n\n\n\n(defn predecessors-not-self\n  \"Returns predecessors not including self\"\n  [g n]\n  (let [predec (loom.graph/predecessors* g n)]\n    (filter #(not (= n %)) predec)))\n\n\n(defn successors-not-self\n  \"Returns successors not including self\"\n  [g n]\n  (let [succs (loom.graph/successors* g n)]\n    (filter #(not (= n %)) succs)))\n\n\n(defn root?\n  \"Predicate for whether the node in the graph is a root.\"\n  [g n]\n  (empty? (predecessors-not-self g n)))\n\n\n(defn roots\n  \"Returns the roots from the graph.\"\n  [g]\n  (filter #(root? g %) (loom.graph/nodes g)))\n\n\n\n"]}