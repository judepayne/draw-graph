{"version":3,"sources":["lib_draw_graph/util.cljc"],"mappings":";;;AAOA;;;AAAA,AAAMA,AAEHC;AAFH,AAIW,AAAAC,AAAWD;;AAGtB,AAAA;;;AAAA,AAAAE,AAAMM;AAAN,AAAA,AAAAL,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAAE;;AAAA,AAAA,AAAAA,AAAA;;;;AAAA;;;;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA,AAAA,AAAAI,AAAA,AAAAJ,AAAA,AAAA,AAAA,AAAA;AAAA,AAAA,AAAAK,AAAAF;;;AAAA,AAAA,AAAA,AAAA,AAAME,AAEDI;AAFL,AAGE,AAAI,AAACC,AAAOC,AAAKF;AACf,AAACG,AAAMC,AAAWR,AAAWI;;AAC7B,AAACK,AAAKL;;;;AALV,AAAA,AAAA,AAAMJ;;AAAN;AAAA,AAAA,AAAA,AAAAC,AAAMD;AAAN,AAAA,AAAAE,AAAA;AAAA,AAAA,AAAAA,AAAA,AAAAC,AAAAF;;;AAAA,AAQA;;;;;;AAAA,AAAMS,AAKHC,AAAEC,AAAQC;AALb,AAME,AAAMC,AAAK,AAAOC,AAAEC;AAAT,AACE,AACE,AAACC,AAAWF;AAAK,AAAAG,AAAYH;AAAZ,AAAAI,AAAAD,AAAA,AAAA,AAAOE;AAAP,AAAAD,AAAAD,AAAA,AAAA,AAASG;AAAT,AACE,AAAI,AAAA,AAAMA;AAAV;;AACI,AAAA,AAACC,AAAO,AAACC,AAAEH,AAAEJ,AACL,AAAI,AAACQ,AAAMH,AACT,AAACE,AAAEF,AAAED,AACLC;;;AANnC,AAQE,AAACI,AAAKV;AAAW,AAAA,AAAAW,AAACC;AAAD,AAAM,AAAAD,AAACH,AAAIP;AAAGD;;AARjC,AAUE,AAACS,AAAMT;AAAU,AAACa,AAAK,AAACC,AAAMd,AAAG,AAAA,AAAAe,AAACH;AAAD,AAAM,AAAAG,AAACP,AAAIP;AAAGD;;AAVjD,AAYmB,AAAI,AAACH,AAAAA,AAAAA,AAAQG,AAAAA,AAAEC,AAAAA;AAAG,AAACH,AAAAA,AAAAA,AAAOE,AAAAA;;AAAGA;;;;;;;AAb7D,AAcG,AAAA,AAACD,AAAKH;;AAOX;;;AAAA,AAAMoB,AAEHC,AAAEC;AAFL,AAGE,AAAMC,AAAO,AAACC,AAAyBH,AAAEC;AAAzC,AACE,AAAA,AAACI;AAADD;AAAA,AAAS,AAAK,AAAAA,AAACE,AAAEL;;AAAMC;;AAG3B;;;AAAA,AAAMK,AAEHP,AAAEC;AAFL,AAGE,AAAMO,AAAM,AAACC,AAAuBT,AAAEC;AAAtC,AACE,AAAA,AAACI;AAADK;AAAA,AAAS,AAAK,AAAAA,AAACJ,AAAEL;;AAAMO;;AAG3B;;;AAAA,AAAMG,AAEHX,AAAEC;AAFL,AAGE,AAACW,AAAO,AAACb,AAAsBC,AAAEC;;AAGnC;;;AAAA,AAAMY,AAEHb;AAFH,AAGE,AAAA,AAAAc,AAACT;AAAD,AAAS,AAAAS,AAACH,AAAMX;AAAK,AAACe,AAAiBf","names":["lib-draw-graph.util/err","error-string","js/Error","var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","lib-draw-graph.util/deep-merge","seq35366","self__4718__auto__","cljs.core/seq","maps","cljs.core/every?","cljs.core/map?","cljs.core.apply.cljs$core$IFn$_invoke$arity$3","cljs.core/merge-with","cljs.core/last","lib-draw-graph.util/update-keys","m","update?","key-fn","down","x","p","cljs.core/map-entry?","vec__35376","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","k","v","cljs.core/first","f","cljs.core/coll?","cljs.core/seq?","p1__35370#","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core.into.cljs$core$IFn$_invoke$arity$2","cljs.core/empty","p1__35371#","lib-draw-graph.util/predecessors-not-self","g","n","predec","loom.graph/predecessors*","p1__35398#","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","lib-draw-graph.util/successors-not-self","succs","loom.graph/successors*","p1__35411#","lib-draw-graph.util/root?","cljs.core/empty?","lib-draw-graph.util/roots","p1__35435#","loom.graph/nodes"],"sourcesContent":["(ns ^{:doc \"Common utilities.\"\n      :author \"Jude Payne\"}\n  lib-draw-graph.util\n  (:require\n        [loom.graph           :as loom.graph]))\n\n\n(defn err\n  \"Creates an exception object with error-string.\"\n  [error-string]\n  #?(:clj (Exception. ^String error-string)\n     :cljs (js/Error. error-string)))\n\n\n(defn deep-merge\n  \"Like merge, but merges maps recursively.\"\n  [& maps]\n  (if (every? map? maps)\n    (apply merge-with deep-merge maps)\n    (last maps)))\n\n\n(defn update-keys\n  \"Walks a nested map m recursively updating all keys with the supplied\n   key-fn where the supplied predicate update? fn for the key is true.\n   key-fn should have one parameter; the key.\n   update? should accept two parameters; the key and the parent key.\"\n  [m update? key-fn]\n  (let [down (fn f [x p]\n               (cond\n                 (map-entry? x)   (let [[k v] x]\n                                    (if (nil? v) nil   ;;prunes where v is nil\n                                        (first {(f k p)\n                                                (if (coll? v)\n                                                  (f v k)\n                                                  v)})))\n                 \n                 (seq? x)         (map #(f % p) x)\n\n                 (coll? x)        (into (empty x) (map #(f % p) x))\n\n                 :else            (if (update? x p) (key-fn x) x)))]\n     (down m nil)))\n\n\n;; -----------------------------\n;; Loom.graph section\n\n\n(defn predecessors-not-self\n  \"Returns predecessors not including self\"\n  [g n]\n  (let [predec (loom.graph/predecessors* g n)]\n    (filter #(not (= n %)) predec)))\n\n\n(defn successors-not-self\n  \"Returns successors not including self\"\n  [g n]\n  (let [succs (loom.graph/successors* g n)]\n    (filter #(not (= n %)) succs)))\n\n\n(defn root?\n  \"Predicate for whether the node in the graph is a root.\"\n  [g n]\n  (empty? (predecessors-not-self g n)))\n\n\n(defn roots\n  \"Returns the roots from the graph.\"\n  [g]\n  (filter #(root? g %) (loom.graph/nodes g)))\n\n\n\n"]}