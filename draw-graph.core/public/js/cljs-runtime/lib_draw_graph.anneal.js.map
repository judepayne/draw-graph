{"version":3,"sources":["lib_draw_graph/anneal.cljc"],"mappings":"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","names":["lib-draw-graph.anneal/max-move-default","lib-draw-graph.anneal/PEN","lib-draw-graph.anneal/shrink-bias-default","lib-draw-graph.anneal/job-env","cljs.core.atom.cljs$core$IFn$_invoke$arity$1","var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","lib-draw-graph.anneal/annealing","p__36160","map__36161","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$3","seq36146","G__36147","cljs.core/first","cljs.core/next","G__36148","G__36149","G__36150","G__36151","G__36152","G__36153","G__36154","self__4717__auto__","initial","max-iter","min-cost","constraints","neighbor-fn","cost-fn","p-fn","temp-fn","dims","terminate-early?","x-retard","y-retard","max-move","shrink-bias","cost","last-cost","cljs.core/reset!","cljs.core/count","state","k","and__4120__auto__","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/rem","cljs.core/deref","lc","del-cost","t","G__36167","next-state","next-cost","cljs.core.rand.cljs$core$IFn$_invoke$arity$0","lib-draw-graph.anneal/random-move","small-move-prob","small-move","mm","cljs.core/rand-int","lib-draw-graph.anneal/vary-rect","rect","dim","cljs.core/rand-nth","delta","G__36179","cljs.core/Keyword","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","cljs.core/quot","lib-draw-graph.anneal/state->boundary","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","item","lib-draw-graph.anneal/state->objects","cljs.core/not","lib-draw-graph.anneal/neighbor-fn","r","vary-bdry?","next","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","p1__36191#","cljs.core.remove.cljs$core$IFn$_invoke$arity$2","lib-draw-graph.anneal/find-first","pred","coll","p1__36202#","cljs.core/some","lib-draw-graph.anneal/->varied","m","path","name","item-or-items","cljs.core.get_in.cljs$core$IFn$_invoke$arity$2","cljs.core/sequential?","n","lib-draw-graph.anneal/passes-constraints?","nm","prev-item","cljs.core/rest","sep","bdry","bdry?","cljs.core/second","objects","other-objects","p1__36217#","test","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","p__36231","vec__36232","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","a","v","G__36235","js/Error","lib-draw-graph.geometry/bigger?","p1__36221#","cljs.core/every?","lib-draw-graph.geometry/inside?","p1__36223#","cljs.core/not-any?","lib-draw-graph.geometry/overlaps?","p1__36224#","G__36259","lib-draw-graph.anneal/cost-fn","boundary","cljs.core/empty?","lib-draw-graph.util/err","bounded-area","lib-draw-graph.geometry/area","c","valid-move?","penalty","lib-draw-graph.anneal/temp-fn","lib-draw-graph.anneal/p-fn","c0","c1","diff","G__36281","Math/exp"],"sourcesContent":["(ns ^{:doc \"Simulated annealing for cluster layout.\"\n      :author \"Jude Payne\"}\n  lib-draw-graph.anneal\n  (:require [lib-draw-graph.geometry :refer [overlaps? inside? bigger? area]]\n            [lib-draw-graph.util     :as util]))\n\n\n#?(:clj (import [java.lang Math]))\n\n\n;; Annealing constants\n\n(def ^:const max-move-default 14)         ;; default move amount +/- dim can be changed by\n(def ^:const PEN 1000000)                ;; Penalty cost amount\n(def ^:const shrink-bias-default nil)\n\n\n(def job-env (atom {}))  ;; a global var for an annealing job\n\n\n;; From Clojure data analysis cookbook\n(defn annealing\n\n  ([initial          ;; the initial state of the system\n    max-iter         ;; maximum numbers of iterations\n    min-cost         ;; the target minimum cost of the system\n    constraints      ;; constraints that a new state must satisfy\n    neighbor-fn      ;; the 'next-step' function\n    cost-fn          ;; the cost function\n    p-fn             ;; the probability of a move function\n    temp-fn          ;; the temperature of the system\n    & {:keys [dims terminate-early? x-retard y-retard max-move shrink-bias]\n       :or {dims [:x :y :w :h] terminate-early? false\n            x-retard nil y-retard nil\n            max-move max-move-default\n            shrink-bias shrink-bias-default}}]\n   (let [cost (cost-fn constraints initial)\n         last-cost (atom cost)]\n     (reset! job-env {:obj-count (count (:objects initial))\n                      :shrink-bias shrink-bias})\n     (loop [state initial\n            cost cost\n            k 1]\n       ;; check every 500 reps that cost has changed more than 0.01%\n       (if (and (= 0 (rem k 500))\n                terminate-early?\n                (> 0.00005 (let [lc @last-cost\n                              del-cost (/ (- lc cost) cost)]\n                            (reset! last-cost cost)\n                            del-cost)))\n          state\n\n         ;; if it hasn't, loop the annealing function\n         (if (and (< k max-iter)\n                  (> cost min-cost))\n           (let [t (temp-fn (/ k max-iter))\n                 next-state (neighbor-fn state dims x-retard y-retard max-move)\n                 next-cost (cost-fn constraints state next-state)]\n             (if (> (p-fn cost next-cost t) (rand))\n               (recur (:next-state next-state) next-cost (inc k))\n               (recur state cost (inc k))))\n           state))))))\n\n\n(defn random-move\n  [max-move]\n  \"Returns a random +/- amount less than max-move. Every so often, we\n   throw in small amounts to help fine tuning at the end of annealing.\"\n  (let [small-move-prob 3      ;; i.e. 1 in n chance\n        small-move 5\n        mm (if (> (inc (rand-int small-move-prob)) (dec small-move-prob))\n             small-move\n             max-move)]\n    (- (rand-int (* 2 mm)) mm)))\n\n\n(defn- vary-rect\n  \"When a rectangle/ polygon is defined with a point, width and height\n  (as opposed to two points), when varying the x or y of the point, it\n  is necessary to adjust the width or height as well to be consistent\n  with a rectangle/ polygon specified as two x,y points.\"\n  [rect dims x-retard y-retard max-move]\n  (let [dim (rand-nth dims)\n        delta (random-move max-move)]\n    (case dim\n      :x (if (and x-retard (not (zero? x-retard)))\n           (-> rect\n               (assoc :x (+ (:x rect) (quot delta x-retard))) \n               (assoc :w (- (:w rect) (quot delta x-retard))))\n           (-> rect\n               (assoc :x (+ (:x rect) delta)) \n               (assoc :w (- (:w rect) delta))))\n      :y (if (and y-retard (not (zero? y-retard)))\n           (-> rect\n               (assoc :y (+ (:y rect) (quot delta y-retard)))\n               (assoc :h (- (:h rect) (quot delta y-retard))))\n           (-> rect\n               (assoc :y (+ (:y rect) delta))\n               (assoc :h (- (:h rect) delta))))\n      :w (if (and x-retard (not (zero? x-retard)))\n           (-> rect\n               (assoc :w (+ (:w rect) (quot delta x-retard))))\n           (-> rect\n               (assoc :w (+ (:w rect) delta))))\n      (if (and y-retard (not (zero? y-retard)))\n        (-> rect (assoc :h (+ (:h rect) (quot delta y-retard))))\n        (-> rect (assoc :h (+ (:h rect) delta)))))))\n\n\n(defn state->boundary [state]\n  (first (filter (fn [item] (:boundary item)) state)))\n\n\n(defn state->objects [state]\n  (filter (fn [item] (not (:boundary item))) state))\n\n\n(defn neighbor-fn\n;; this function will change when boundaries can move it\n  \"Varies a random item from state and returns the new state\n  after checking that the new state passes constraints.\"\n  [state dims x-retard y-retard max-move]\n  (let [r (let [shrink-bias (:shrink-bias @job-env)]\n            (if shrink-bias\n              (rand-int shrink-bias)\n              nil))\n        vary-bdry? (= 0 r)\n        item (if vary-bdry? (:boundary state) (rand-nth (:objects state)))\n        next (vary-rect item dims x-retard y-retard max-move)\n        next-state (if vary-bdry?\n                     (assoc state :boundary next)\n                     (assoc state :objects (conj (remove #(= item %) (:objects state)) next)))]\n    {:path [:next-state (if vary-bdry? :boundary :objects)]\n     :name (:name next)\n     :next-state next-state}))\n\n\n(defn find-first\n  [pred coll]\n  (some #(when (pred %) %) coll))\n\n\n(defn ->varied\n  \"returns the varied item when passed a neighbor-fn output map\"\n  [m path name]\n  (let [item-or-items (get-in m path)]\n    (if (sequential? item-or-items)\n      (find-first (fn [n] (= name (:name n))) item-or-items)\n      item-or-items)))\n\n\n(defn- passes-constraints?\n  \"Checks that the new (proposed) state item satisfies constraints.\"\n  [constraints state next-state]\n  (let [path (:path next-state)\n        nm (:name next-state)\n        item (->varied next-state path nm)\n        prev-item (->varied state (rest path) nm)\n        sep (:collision constraints)\n        bdry (get-in next-state [:next-state :boundary])\n        bdry? (if (= :boundary (second path)) true false)\n        objects (get-in next-state [:next-state :objects])\n        other-objects (remove #(= (:name %) nm) objects)\n        test (reduce\n              (fn [a [k v]]\n                (and a\n                     (case k\n                       :grow      (if v (if bdry?\n                                          (not (bigger? prev-item item))\n                                          (bigger? prev-item item))\n                                      true)\n                       :boundary  (if v (if bdry?\n                                          (every? #(inside? bdry %) objects)\n                                          (inside? bdry item))\n                                      true)\n                       :collision (if (and sep (not bdry?)) (not-any? #(overlaps? sep item %) other-objects) true)\n                       :obstacles (if (and v sep) (not-any? #(overlaps? sep item %) v) true))))\n              true\n              constraints)]\n    test))\n\n\n(defn cost-fn\n  \"Calculates cost, which is total bounded area minus sum of current areas.\n  For the initial call to calculate the system's cost, requires only constraints and state.\n  Subsequent calls require the state, next-state and k, the key of the entry that has\n  changed between them.\"\n  ([constraints state]\n   (let [boundary (:boundary state)]\n     (if (empty? boundary)\n       (throw (util/err \"no boundary condition!\"))\n       (let [bounded-area (area boundary)]\n         (- bounded-area (reduce (fn [a c] (+ a (area c))) 0 (:objects state)))))))\n\n  ([constraints state next-state]\n   (let [bounded-area (area (-> next-state :next-state :boundary))\n         cost (- bounded-area (reduce (fn [a c] (+ a (area c))) 0 (-> next-state :next-state :objects)))\n         valid-move? (passes-constraints? constraints state next-state)\n         penalty (if valid-move? 0 PEN)\n;         z (println (-> next-state :next-state :boundary :name) (:name next-state) \" \" valid-move? penalty)\n         ]\n     (+ cost penalty))))\n\n\n(defn temp-fn\n  \"the temperature. r should be between 0 and 1\"\n  [r]\n  (- 1.0 (float r)))\n\n\n(defn p-fn  \"the probability of a move function, using Boltzmann\"\n  [c0 c1 t]\n  (let [diff (- c1 c0)]\n    (if (< c1 c0)\n      1\n      (Math/exp (* -1 (/ diff t))))))\n"]}