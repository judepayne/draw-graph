{"version":3,"sources":["tool_belt/core.cljc"],"mappings":"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","names":["tool-belt.core/in?","coll","elm","p1__54032#","cljs.core/some","cljs.core._EQ_","tool-belt.core/not-in?","cljs.core/complement","var_args","args__4795__auto__","len__4789__auto__","i__4790__auto__","argseq__4796__auto__","cljs.core/IndexedSeq","tool-belt.core/apply-to-if","seq54037","G__54038","cljs.core/first","cljs.core/next","G__54039","G__54040","self__4776__auto__","m","test","f","args","cljs.core.apply","tool-belt.core/join","colls","cljs.core.reduce","cljs.core/concat","tool-belt.core/deep-merge","seq54048","self__4777__auto__","cljs.core/seq","maps","cljs.core/every?","cljs.core/map?","cljs.core/merge-with","cljs.core/sequential?","tool-belt.core/deep-merge-with","seq54050","G__54051","tool-belt.core/update-in-all","seq54060","G__54061","G__54062","G__54063","ks","up","vec__54064","seq__54065","first__54066","k","p__54067","vec__54069","cljs.core.nth","acc","kz","v","cljs.core.assoc","cljs.core.get","p__54072","vec__54073","temp__5733__auto__","tool-belt.core/update-in-all-if","seq54086","G__54087","G__54088","G__54089","G__54090","tool-belt.core/dissoc-in","vec__54102","seq__54103","first__54104","p__54106","vec__54107","p__54115","vec__54117","tool-belt.core/dissoc-in-when","pred","vec__54145","seq__54146","first__54147","p__54153","vec__54155","p__54167","vec__54170","p__54175","vec__54176","tool-belt.core/dissoc-in-clean","cljs.core/butlast","tgt","cljs.core.get_in","res","cljs.core.dissoc","cljs.core/last","cljs.core/empty?","tool-belt.core/prewalk","parent","state","state-fn","replace-fn","form","nxt-s","nxt-f","clojure.walk/walk","cljs.core.partial","pw","cljs.core/identity","tool-belt.core/vec?","x","cljs.core/map-entry?","tool-belt.core/with-path","cljs.core.conj","cljs.core/key","cljs.core.merge"],"sourcesContent":["(ns tool-belt.core\n  (:require [clojure.walk       :as w]))\n\n;; A personal utility library for Clojure/script with lots of useful and reuseable functions.\n\n(defn in? \n  \"true if coll contains elm\"\n  [coll elm]  \n  (some #(= elm %) coll))\n\n\n(def not-in?\n  \"true if coll does not contains elm\"\n  (complement in?))\n\n\n(defn apply-to-if\n  [m test f & args]\n  \"Applies f to m and m if test is true. For conditional steps in threaded -> chains.\"\n  (if test\n    (apply f m args)\n    m))\n\n\n(defn join\n  \"Concat a collection of colls.\"\n  [colls] (reduce concat colls))\n\n\n(defn deep-merge\n  \"Merges maps recursively down.\"\n  [& maps]\n  (apply\n   (fn m [& maps]\n     (cond\n       (every? map? maps)        (apply merge-with m maps)\n       (every? sequential? maps) (reduce concat [] maps)\n      :else  maps))\n   maps))\n\n\n(defn deep-merge-with\n  \"Like merge-with, but merges maps recursively, applying the given fn\n  only when there's a non-map at a particular level.\"\n  [f & maps]\n  (apply\n   (fn m [& maps]\n     (if (every? map? maps)\n       (apply merge-with m maps)\n       (apply f maps)))\n   maps))\n\n\n(defn update-in-all\n  \"Like update-in but when special key :all is supplied in the ks vector,\n  all map-entries at that level will be accepted.\"\n  [m ks f & args]\n  (let [up (fn up [m ks f args]\n             (let [[k & ks] ks]\n               (if ks\n                 (if (= k :all)\n                   (reduce (fn [acc [kz v]] (assoc acc kz (up v ks f args))) {} m)\n                   (assoc m k (up (get m k) ks f args)))\n                 (if (= k :all)\n                   (reduce (fn [acc [kz v]] (assoc acc kz (apply f v args))) {} m)\n                   (if-let [v (get m k)]\n                     (assoc m k (apply f (get m k) args))\n                     m)))))]\n       (up m ks f args)))\n\n\n(defn update-in-all-if\n  \"Like update-in-all but only if test is true.\"\n  [m test ks f & args]\n  (if test\n    (apply update-in-all m ks f args)\n    m))\n\n\n(defn dissoc-in\n  \"Dissocs at the ks vector in a nested map.\n  Supplying special key :all in the last position in ks will dissoc all entries.\n  Supplying :all in another possible will cause all map-entries at that level to be recursed into.\"\n  [m ks]\n  (let [up (fn up [m ks]\n             (let [[k & ks] ks]\n               (if ks\n                 (if (= k :all)\n                   (reduce (fn [acc [kz v]] (assoc acc kz (up v ks))) {} m)\n                   (assoc m k (up (get m k) ks)))\n                 (if (= k :all)\n                   {}\n                   (reduce (fn [acc [kz v]]  (if (= k kz) acc (assoc acc kz v))) {} m)))))]\n       (up m ks)))\n\n\n(defn dissoc-in-when\n  \"Like dissoc-in, but items are dissoc'd only when (pred value-of-entry) is true.\"\n  [m ks pred]\n  (let [up (fn up [m ks]\n             (let [[k & ks] ks]\n               (if ks\n                 (if (= k :all)\n                   (reduce (fn [acc [kz v]] (assoc acc kz (up v ks))) {} m)\n                   (assoc m k (up (get m k) ks)))\n                 (if (= k :all)\n                   (reduce (fn [acc [kz v]]\n                             (if (pred v) acc (assoc acc kz v))) {} m)\n                   (reduce (fn [acc [kz v]]\n                             (if (and (= k kz) (pred v)) acc (assoc acc kz v))) {} m)))))]\n       (up m ks)))\n\n\n;; Performance could be improved by building into dissoc-in\n(defn dissoc-in-clean\n  \"Likes dissoc-in but when the result of the dissoc leaves in empty collection in\n  the nested map, removes that map-entry that it is in, so cleaning the map from\n  empty nested collections like ..:b {:a #{} :b 1}...  [:a #{}] would be removed.\"\n  [m ks]\n  (let [k (butlast ks)\n        tgt (get-in m k)\n        res (dissoc tgt (last ks))]\n    (if (empty? res)\n      (dissoc-in m k)\n      (dissoc-in m ks))))\n\n\n(defn prewalk\n  \"Like clojure.walk/prewalk but stateful.\n   parent is the parent of the form. state is recursed down through the form,\n   at each level updated by the state-fn (which must accept previous state, the\n   parent form and the current form. replace-fn accepts the current state and form.\"\n  ([parent state state-fn replace-fn form]\n   (letfn [(pw [parent state form]\n             (let [nxt-s (state-fn state parent form)\n                   nxt-f (replace-fn nxt-s form)]\n               (w/walk (partial pw form nxt-s) identity nxt-f)))]\n     (pw parent state form))))\n\n\n(defn vec? [x]\n  \"Is x a vector?\"\n  (and (sequential? x) (not (map-entry? x))))\n\n\n(defn with-path\n  \"Decorates every level of a nested form with it's path added in a :$path key.\"\n  [form]\n  (prewalk nil\n           []\n           ;; state function\n           (fn [state parent form]\n             (cond\n               (map-entry? form)                    (conj state (key form))\n               \n               (and (or (map? form) (vec? form))\n                    (vec? parent))\n               (conj state (.indexOf parent form))\n               \n               :else state))\n           ;; replace function\n           (fn [state form]\n             (if (map? form) (merge {:$path state} form) form))\n\n           form))\n\n"]}