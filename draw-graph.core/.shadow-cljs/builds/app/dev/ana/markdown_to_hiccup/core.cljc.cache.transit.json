["^ ","~:output",["^ ","~:js","goog.provide('markdown_to_hiccup.core');\ngoog.require('cljs.core');\ngoog.require('clojure.string');\ngoog.require('cljs.spec.alpha');\ngoog.require('markdown_to_hiccup.decode');\ngoog.require('hickory.core');\ngoog.require('markdown.core');\ncljs.spec.alpha.def_impl(new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"markdown\",\"markdown-to-hiccup.core/markdown\",1289845536),new cljs.core.Symbol(\"cljs.core\",\"string?\",\"cljs.core/string?\",-2072921719,null),cljs.core.string_QMARK_);\ncljs.spec.alpha.def_impl(new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"hiccup\",\"markdown-to-hiccup.core/hiccup\",1147350639),new cljs.core.Symbol(\"cljs.core\",\"vector?\",\"cljs.core/vector?\",-1550392028,null),cljs.core.vector_QMARK_);\ncljs.spec.alpha.def_impl(new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"options\",\"markdown-to-hiccup.core/options\",439665020),cljs.core.list(new cljs.core.Symbol(\"cljs.spec.alpha\",\"keys\",\"cljs.spec.alpha/keys\",1109346032,null),new cljs.core.Keyword(null,\"opt-un\",\"opt-un\",883442496),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"encode?\",\"markdown-to-hiccup.core/encode?\",-1516433262)], null)),cljs.spec.alpha.map_spec_impl(cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,\"req-un\",\"req-un\",1074571008),new cljs.core.Keyword(null,\"opt-un\",\"opt-un\",883442496),new cljs.core.Keyword(null,\"gfn\",\"gfn\",791517474),new cljs.core.Keyword(null,\"pred-exprs\",\"pred-exprs\",1792271395),new cljs.core.Keyword(null,\"keys-pred\",\"keys-pred\",858984739),new cljs.core.Keyword(null,\"opt-keys\",\"opt-keys\",1262688261),new cljs.core.Keyword(null,\"req-specs\",\"req-specs\",553962313),new cljs.core.Keyword(null,\"req\",\"req\",-326448303),new cljs.core.Keyword(null,\"req-keys\",\"req-keys\",514319221),new cljs.core.Keyword(null,\"opt-specs\",\"opt-specs\",-384905450),new cljs.core.Keyword(null,\"pred-forms\",\"pred-forms\",172611832),new cljs.core.Keyword(null,\"opt\",\"opt\",-794706369)],[null,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"encode?\",\"markdown-to-hiccup.core/encode?\",-1516433262)], null),null,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [(function (G__36631){\nreturn cljs.core.map_QMARK_(G__36631);\n})], null),(function (G__36631){\nreturn cljs.core.map_QMARK_(G__36631);\n}),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"encode?\",\"encode?\",-640109139)], null),cljs.core.PersistentVector.EMPTY,null,cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"encode?\",\"markdown-to-hiccup.core/encode?\",-1516433262)], null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(new cljs.core.Symbol(\"cljs.core\",\"fn\",\"cljs.core/fn\",-1065745098,null),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"%\",\"%\",-950237169,null)], null),cljs.core.list(new cljs.core.Symbol(\"cljs.core\",\"map?\",\"cljs.core/map?\",-1390345523,null),new cljs.core.Symbol(null,\"%\",\"%\",-950237169,null)))], null),null])));\ncljs.spec.alpha.def_impl(new cljs.core.Symbol(\"markdown-to-hiccup.core\",\"md->hiccup\",\"markdown-to-hiccup.core/md->hiccup\",1623858518,null),cljs.core.list(new cljs.core.Symbol(\"cljs.spec.alpha\",\"fspec\",\"cljs.spec.alpha/fspec\",-1289128341,null),new cljs.core.Keyword(null,\"args\",\"args\",1315556576),cljs.core.list(new cljs.core.Symbol(\"cljs.spec.alpha\",\"cat\",\"cljs.spec.alpha/cat\",-1471398329,null),new cljs.core.Keyword(null,\"md-str\",\"md-str\",-1726634417),new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"markdown\",\"markdown-to-hiccup.core/markdown\",1289845536),new cljs.core.Keyword(null,\"params\",\"params\",710516235),new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"options\",\"markdown-to-hiccup.core/options\",439665020)),new cljs.core.Keyword(null,\"ret\",\"ret\",-468222814),new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"hiccup\",\"markdown-to-hiccup.core/hiccup\",1147350639)),cljs.spec.alpha.fspec_impl(cljs.spec.alpha.spec_impl.cljs$core$IFn$_invoke$arity$4(cljs.core.list(new cljs.core.Symbol(\"cljs.spec.alpha\",\"cat\",\"cljs.spec.alpha/cat\",-1471398329,null),new cljs.core.Keyword(null,\"md-str\",\"md-str\",-1726634417),new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"markdown\",\"markdown-to-hiccup.core/markdown\",1289845536),new cljs.core.Keyword(null,\"params\",\"params\",710516235),new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"options\",\"markdown-to-hiccup.core/options\",439665020)),cljs.spec.alpha.cat_impl(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"md-str\",\"md-str\",-1726634417),new cljs.core.Keyword(null,\"params\",\"params\",710516235)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"markdown\",\"markdown-to-hiccup.core/markdown\",1289845536),new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"options\",\"markdown-to-hiccup.core/options\",439665020)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"markdown\",\"markdown-to-hiccup.core/markdown\",1289845536),new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"options\",\"markdown-to-hiccup.core/options\",439665020)], null)),null,null),cljs.core.list(new cljs.core.Symbol(\"cljs.spec.alpha\",\"cat\",\"cljs.spec.alpha/cat\",-1471398329,null),new cljs.core.Keyword(null,\"md-str\",\"md-str\",-1726634417),new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"markdown\",\"markdown-to-hiccup.core/markdown\",1289845536),new cljs.core.Keyword(null,\"params\",\"params\",710516235),new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"options\",\"markdown-to-hiccup.core/options\",439665020)),cljs.spec.alpha.spec_impl.cljs$core$IFn$_invoke$arity$4(new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"hiccup\",\"markdown-to-hiccup.core/hiccup\",1147350639),new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"hiccup\",\"markdown-to-hiccup.core/hiccup\",1147350639),null,null),new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"hiccup\",\"markdown-to-hiccup.core/hiccup\",1147350639),null,null,null));\n/**\n * Accepts a markdown string and returns a hiccup data structure converted from that markdown.\n *   Also accepts an optional params map. Use the :encode? boolean key to specify whether\n *   or not you want html escape characters to be encoded. Example:\n *  (md->hiccup \"#Title\" {:encode? true})\n */\nmarkdown_to_hiccup.core.md__GT_hiccup = (function markdown_to_hiccup$core$md__GT_hiccup(var_args){\nvar G__36666 = arguments.length;\nswitch (G__36666) {\ncase 2:\nreturn markdown_to_hiccup.core.md__GT_hiccup.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 1:\nreturn markdown_to_hiccup.core.md__GT_hiccup.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nmarkdown_to_hiccup.core.md__GT_hiccup.cljs$core$IFn$_invoke$arity$2 = (function (md_str,params){\nvar valid_md = ((cljs.spec.alpha._STAR_compile_asserts_STAR_)?(cljs.core.truth_(cljs.core.deref(new cljs.core.Var(function(){return cljs.spec.alpha._STAR_runtime_asserts_STAR_;},new cljs.core.Symbol(\"cljs.spec.alpha\",\"*runtime-asserts*\",\"cljs.spec.alpha/*runtime-asserts*\",-1060443587,null),cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,\"private\",\"private\",-558947994),new cljs.core.Keyword(null,\"ns\",\"ns\",441598760),new cljs.core.Keyword(null,\"name\",\"name\",1843675177),new cljs.core.Keyword(null,\"file\",\"file\",-1269645878),new cljs.core.Keyword(null,\"end-column\",\"end-column\",1425389514),new cljs.core.Keyword(null,\"column\",\"column\",2078222095),new cljs.core.Keyword(null,\"dynamic\",\"dynamic\",704819571),new cljs.core.Keyword(null,\"line\",\"line\",212345235),new cljs.core.Keyword(null,\"end-line\",\"end-line\",1837326455),new cljs.core.Keyword(null,\"arglists\",\"arglists\",1661989754),new cljs.core.Keyword(null,\"doc\",\"doc\",1913296891),new cljs.core.Keyword(null,\"test\",\"test\",577538877)],[true,new cljs.core.Symbol(null,\"cljs.spec.alpha\",\"cljs.spec.alpha\",505122844,null),new cljs.core.Symbol(null,\"*runtime-asserts*\",\"*runtime-asserts*\",1632801956,null),\"cljs/spec/alpha.cljs\",20,1,true,1477,1479,cljs.core.List.EMPTY,null,((cljs.spec.alpha._STAR_runtime_asserts_STAR_)?cljs.spec.alpha._STAR_runtime_asserts_STAR_.cljs$lang$test:null)]))))?cljs.spec.alpha.assert_STAR_(new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"markdown\",\"markdown-to-hiccup.core/markdown\",1289845536),md_str):md_str):md_str);\nvar encode_QMARK_ = new cljs.core.Keyword(null,\"encode?\",\"encode?\",-640109139).cljs$core$IFn$_invoke$arity$1(((cljs.spec.alpha._STAR_compile_asserts_STAR_)?(cljs.core.truth_(cljs.core.deref(new cljs.core.Var(function(){return cljs.spec.alpha._STAR_runtime_asserts_STAR_;},new cljs.core.Symbol(\"cljs.spec.alpha\",\"*runtime-asserts*\",\"cljs.spec.alpha/*runtime-asserts*\",-1060443587,null),cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,\"private\",\"private\",-558947994),new cljs.core.Keyword(null,\"ns\",\"ns\",441598760),new cljs.core.Keyword(null,\"name\",\"name\",1843675177),new cljs.core.Keyword(null,\"file\",\"file\",-1269645878),new cljs.core.Keyword(null,\"end-column\",\"end-column\",1425389514),new cljs.core.Keyword(null,\"column\",\"column\",2078222095),new cljs.core.Keyword(null,\"dynamic\",\"dynamic\",704819571),new cljs.core.Keyword(null,\"line\",\"line\",212345235),new cljs.core.Keyword(null,\"end-line\",\"end-line\",1837326455),new cljs.core.Keyword(null,\"arglists\",\"arglists\",1661989754),new cljs.core.Keyword(null,\"doc\",\"doc\",1913296891),new cljs.core.Keyword(null,\"test\",\"test\",577538877)],[true,new cljs.core.Symbol(null,\"cljs.spec.alpha\",\"cljs.spec.alpha\",505122844,null),new cljs.core.Symbol(null,\"*runtime-asserts*\",\"*runtime-asserts*\",1632801956,null),\"cljs/spec/alpha.cljs\",20,1,true,1477,1479,cljs.core.List.EMPTY,null,((cljs.spec.alpha._STAR_runtime_asserts_STAR_)?cljs.spec.alpha._STAR_runtime_asserts_STAR_.cljs$lang$test:null)]))))?cljs.spec.alpha.assert_STAR_(new cljs.core.Keyword(\"markdown-to-hiccup.core\",\"options\",\"markdown-to-hiccup.core/options\",439665020),params):params):params));\nvar html = markdown.core.md__GT_html(valid_md);\nvar dom = hickory.core.parse(html);\nvar hiccup = cljs.core.first(hickory.core.as_hiccup(dom));\nif(cljs.core.truth_(encode_QMARK_)){\nreturn hiccup;\n} else {\nreturn (markdown_to_hiccup.decode.decode.cljs$core$IFn$_invoke$arity$1 ? markdown_to_hiccup.decode.decode.cljs$core$IFn$_invoke$arity$1(hiccup) : markdown_to_hiccup.decode.decode.call(null,hiccup));\n}\n});\n\nmarkdown_to_hiccup.core.md__GT_hiccup.cljs$core$IFn$_invoke$arity$1 = (function (md_str){\nreturn markdown_to_hiccup.core.md__GT_hiccup.cljs$core$IFn$_invoke$arity$2(md_str,new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"encode?\",\"encode?\",-640109139),false], null));\n});\n\nmarkdown_to_hiccup.core.md__GT_hiccup.cljs$lang$maxFixedArity = 2;\n\n/**\n * Deprecated. Please use hiccup-in for better access to nested hiccup.\n *   Accepts a hiccup data structure and a keyword representing\n *   an html element tag (e.g. :body) and returns the first nested\n *   hiccup vector identified by the keyword.\n */\nmarkdown_to_hiccup.core.hicc_in = (function markdown_to_hiccup$core$hicc_in(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___36715 = arguments.length;\nvar i__4731__auto___36716 = (0);\nwhile(true){\nif((i__4731__auto___36716 < len__4730__auto___36715)){\nargs__4736__auto__.push((arguments[i__4731__auto___36716]));\n\nvar G__36717 = (i__4731__auto___36716 + (1));\ni__4731__auto___36716 = G__36717;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((1) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((1)),(0),null)):null);\nreturn markdown_to_hiccup.core.hicc_in.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4737__auto__);\n});\n\nmarkdown_to_hiccup.core.hicc_in.cljs$core$IFn$_invoke$arity$variadic = (function (hiccup,kws){\nwhile(true){\nvar kw = cljs.core.first(kws);\nvar root = cljs.core.first(hiccup);\nif((kw == null)){\nreturn hiccup;\n} else {\nif(cljs.core.empty_QMARK_(hiccup)){\nreturn cljs.core.PersistentVector.EMPTY;\n} else {\nif(cljs.core.map_QMARK_(root)){\nvar G__36718 = cljs.core.rest(hiccup);\nvar G__36719 = kws;\nhiccup = G__36718;\nkws = G__36719;\ncontinue;\n} else {\nif(cljs.core.vector_QMARK_(root)){\nvar branch_result = cljs.core.apply.cljs$core$IFn$_invoke$arity$3(markdown_to_hiccup.core.hicc_in,root,kws);\nif(cljs.core.empty_QMARK_(branch_result)){\nvar G__36722 = cljs.core.rest(hiccup);\nvar G__36723 = kws;\nhiccup = G__36722;\nkws = G__36723;\ncontinue;\n} else {\nreturn branch_result;\n}\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(root,kw)){\nvar G__36724 = hiccup;\nvar G__36725 = cljs.core.rest(kws);\nhiccup = G__36724;\nkws = G__36725;\ncontinue;\n} else {\nvar G__36726 = cljs.core.rest(hiccup);\nvar G__36728 = kws;\nhiccup = G__36726;\nkws = G__36728;\ncontinue;\n\n}\n}\n}\n}\n}\nbreak;\n}\n});\n\nmarkdown_to_hiccup.core.hicc_in.cljs$lang$maxFixedArity = (1);\n\n/** @this {Function} */\nmarkdown_to_hiccup.core.hicc_in.cljs$lang$applyTo = (function (seq36667){\nvar G__36668 = cljs.core.first(seq36667);\nvar seq36667__$1 = cljs.core.next(seq36667);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__36668,seq36667__$1);\n});\n\nmarkdown_to_hiccup.core.keywords_QMARK_ = (function markdown_to_hiccup$core$keywords_QMARK_(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___36731 = arguments.length;\nvar i__4731__auto___36732 = (0);\nwhile(true){\nif((i__4731__auto___36732 < len__4730__auto___36731)){\nargs__4736__auto__.push((arguments[i__4731__auto___36732]));\n\nvar G__36733 = (i__4731__auto___36732 + (1));\ni__4731__auto___36732 = G__36733;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((0) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((0)),(0),null)):null);\nreturn markdown_to_hiccup.core.keywords_QMARK_.cljs$core$IFn$_invoke$arity$variadic(argseq__4737__auto__);\n});\n\nmarkdown_to_hiccup.core.keywords_QMARK_.cljs$core$IFn$_invoke$arity$variadic = (function (args){\nreturn cljs.core.every_QMARK_(cljs.core.keyword_QMARK_,args);\n});\n\nmarkdown_to_hiccup.core.keywords_QMARK_.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\nmarkdown_to_hiccup.core.keywords_QMARK_.cljs$lang$applyTo = (function (seq36675){\nvar self__4718__auto__ = this;\nreturn self__4718__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq36675));\n});\n\n/**\n * Accepts a list of [keyword count] pairs, and subtracts the count\n * of the first pair. If that count becomes negative, dec-front returns\n * the rest of the list. Otherwise, it returns the list with the new\n * count value for the first pair.\n */\nmarkdown_to_hiccup.core.dec_front = (function markdown_to_hiccup$core$dec_front(kw_pairs){\nvar vec__36676 = cljs.core.first(kw_pairs);\nvar kw = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__36676,(0),null);\nvar count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__36676,(1),null);\nvar new_count = (count - (1));\nvar new_pair = new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [kw,new_count], null);\nif((new_count < (0))){\nreturn cljs.core.rest(kw_pairs);\n} else {\nreturn cljs.core.cons(new_pair,cljs.core.rest(kw_pairs));\n}\n});\n/**\n * Accepts a list of keywords and numbers. Any place in which\n *   a number does not separate keywords, a zero will be inserted.\n *   Returns the arg list as a sequence of keyword -> number pairs\n *   nested as lists.\n */\nmarkdown_to_hiccup.core.num_partition = (function markdown_to_hiccup$core$num_partition(args){\nvar arglist = args;\nvar ret_vec = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nvar curr_arg = cljs.core.first(arglist);\nvar prev_arg = cljs.core.peek(ret_vec);\nif((curr_arg == null)){\nif((prev_arg instanceof cljs.core.Keyword)){\nreturn cljs.core.partition.cljs$core$IFn$_invoke$arity$2((2),cljs.core.conj.cljs$core$IFn$_invoke$arity$2(ret_vec,(0)));\n} else {\nreturn cljs.core.partition.cljs$core$IFn$_invoke$arity$2((2),ret_vec);\n}\n} else {\nif(markdown_to_hiccup.core.keywords_QMARK_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([curr_arg,prev_arg], 0))){\nvar G__36737 = cljs.core.rest(arglist);\nvar G__36738 = cljs.core.conj.cljs$core$IFn$_invoke$arity$variadic(ret_vec,(0),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([curr_arg], 0));\narglist = G__36737;\nret_vec = G__36738;\ncontinue;\n} else {\nvar G__36739 = cljs.core.rest(arglist);\nvar G__36740 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(ret_vec,curr_arg);\narglist = G__36739;\nret_vec = G__36740;\ncontinue;\n\n}\n}\nbreak;\n}\n});\nmarkdown_to_hiccup.core.same_length_QMARK_ = (function markdown_to_hiccup$core$same_length_QMARK_(coll_a,coll_b){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(coll_a),cljs.core.count(coll_b));\n});\n/**\n * Recursive helper function for hiccup-in.\n */\nmarkdown_to_hiccup.core.get_nested_hiccup = (function markdown_to_hiccup$core$get_nested_hiccup(hiccup,kw_pairs){\nwhile(true){\nvar vec__36679 = cljs.core.first(kw_pairs);\nvar kw = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__36679,(0),null);\nvar nth_kw = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__36679,(1),null);\nvar front = cljs.core.first(hiccup);\nvar remaining = cljs.core.rest(hiccup);\nif(cljs.core.empty_QMARK_(hiccup)){\nreturn cljs.core.PersistentVector.EMPTY;\n} else {\nif((kw == null)){\nreturn hiccup;\n} else {\nif(cljs.core.map_QMARK_(front)){\nvar G__36745 = remaining;\nvar G__36746 = kw_pairs;\nhiccup = G__36745;\nkw_pairs = G__36746;\ncontinue;\n} else {\nif(cljs.core.vector_QMARK_(front)){\nvar branch_result = (markdown_to_hiccup.core.get_nested_hiccup.cljs$core$IFn$_invoke$arity$2 ? markdown_to_hiccup.core.get_nested_hiccup.cljs$core$IFn$_invoke$arity$2(front,kw_pairs) : markdown_to_hiccup.core.get_nested_hiccup.call(null,front,kw_pairs));\nif(cljs.core.empty_QMARK_(branch_result)){\nvar nested_front = cljs.core.first(front);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(nested_front,kw)){\nvar G__36747 = remaining;\nvar G__36748 = markdown_to_hiccup.core.dec_front(kw_pairs);\nhiccup = G__36747;\nkw_pairs = G__36748;\ncontinue;\n} else {\nvar G__36749 = remaining;\nvar G__36750 = kw_pairs;\nhiccup = G__36749;\nkw_pairs = G__36750;\ncontinue;\n}\n} else {\nreturn branch_result;\n}\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(front,kw)){\nvar new_pairs = markdown_to_hiccup.core.dec_front(kw_pairs);\nif(cljs.core.empty_QMARK_(new_pairs)){\nreturn hiccup;\n} else {\nvar G__36754 = remaining;\nvar G__36755 = new_pairs;\nhiccup = G__36754;\nkw_pairs = G__36755;\ncontinue;\n\n}\n} else {\nvar G__36756 = remaining;\nvar G__36757 = kw_pairs;\nhiccup = G__36756;\nkw_pairs = G__36757;\ncontinue;\n\n}\n}\n}\n}\n}\nbreak;\n}\n});\n/**\n * Accepts a hiccup data structure and any series of args in keyword, index order.\n * Each keyword represents a hiccup element, and the paired index is which element at that level hiccup-in will look in.\n * If no number proceeds a keyword, hiccup-in will find the first element with that keyword.\n * Returns the nested hiccup vector identified by the keywords.\n * Example: (hiccup-in hiccup :html :body :div 0 :h1 2 :p)\n */\nmarkdown_to_hiccup.core.hiccup_in = (function markdown_to_hiccup$core$hiccup_in(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___36758 = arguments.length;\nvar i__4731__auto___36759 = (0);\nwhile(true){\nif((i__4731__auto___36759 < len__4730__auto___36758)){\nargs__4736__auto__.push((arguments[i__4731__auto___36759]));\n\nvar G__36760 = (i__4731__auto___36759 + (1));\ni__4731__auto___36759 = G__36760;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((1) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((1)),(0),null)):null);\nreturn markdown_to_hiccup.core.hiccup_in.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4737__auto__);\n});\n\nmarkdown_to_hiccup.core.hiccup_in.cljs$core$IFn$_invoke$arity$variadic = (function (hiccup,kw_pairs){\nvar pathway = markdown_to_hiccup.core.num_partition(kw_pairs);\nreturn markdown_to_hiccup.core.get_nested_hiccup(hiccup,pathway);\n});\n\nmarkdown_to_hiccup.core.hiccup_in.cljs$lang$maxFixedArity = (1);\n\n/** @this {Function} */\nmarkdown_to_hiccup.core.hiccup_in.cljs$lang$applyTo = (function (seq36690){\nvar G__36691 = cljs.core.first(seq36690);\nvar seq36690__$1 = cljs.core.next(seq36690);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__36691,seq36690__$1);\n});\n\n/**\n * Accepts hiccup and returns the same hiccup only\n * without the :html, :head, and :body elements. Useful\n * if you want to nest your markdown hiccup in existing\n * hiccup data structures.\n */\nmarkdown_to_hiccup.core.component = (function markdown_to_hiccup$core$component(hiccup){\nvar body = markdown_to_hiccup.core.hiccup_in.cljs$core$IFn$_invoke$arity$variadic(hiccup,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"body\",\"body\",-2049205669)], 0));\nreturn cljs.core.vec(cljs.core.cons(new cljs.core.Keyword(null,\"div\",\"div\",1057191632),cljs.core.rest(body)));\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","markdown_to_hiccup/core.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",28],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$create-react-class","~$module$node_modules$create_react_class$index","~$react-dom","~$module$node_modules$react_dom$index","~$clojure.spec.alpha","~$cljs.spec.alpha"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$markdown-to-hiccup.core","~:op","~:ns","~:imports",null,"~:requires",["^ ","^D","^E","~$markdown.core","^O","~$cljs.core","^P","~$goog","^Q","~$spec","^E","~$markdown-to-hiccup.decode","^S","~$str","~$clojure.string","^U","^U","~$hickory.core","^V","^E","^E","~$d","^S"],"~:seen",["^H",["~:require"]],"~:uses",["^ ","~$parse","^V","~$as-hiccup","^V","~$md->html","^O"],"~:require-macros",["^ ","^P","^P","^D","^E","^R","^E","^E","^E"],"~:form",["~#list",["~$ns","^J",["^13",["^X",["^U","~:as","^T"],["^D","^15","^R"],["^S","^15","~$d"],["^V","~:refer",["^Z","^["]],["^O","^16",["^10"]]]]]],"~:flags",["^ ","^X",["^H",[]]],"~:js-deps",["^ "],"~:deps",["^Q","^P","^U","^E","^S","^V","^O"]],"^L","^J","~:resource-id",["~:shadow.build.classpath/resource","markdown_to_hiccup/core.cljc"],"~:compiled-at",1560836392942,"~:resource-name","markdown_to_hiccup/core.cljc","~:warnings",[],"~:source","(ns markdown-to-hiccup.core\n  (:require [clojure.string :as str]\n            [clojure.spec.alpha :as spec]\n            [markdown-to-hiccup.decode :as d]\n            [hickory.core :refer [parse as-hiccup]]\n            [markdown.core :refer #?(:clj  [md-to-html-string]\n                                     :cljs [md->html])]))\n\n(spec/def ::markdown string?)\n(spec/def ::hiccup vector?)\n(spec/def ::options (spec/keys :opt-un [::encode?]))\n(spec/fdef md->hiccup\n           :args (spec/cat :md-str ::markdown\n                           :params ::options)\n           :ret ::hiccup)\n(defn md->hiccup\n  \"Accepts a markdown string and returns a hiccup data structure converted from that markdown.\n  Also accepts an optional params map. Use the :encode? boolean key to specify whether\n  or not you want html escape characters to be encoded. Example:\n    (md->hiccup \\\"#Title\\\" {:encode? true})\"\n  ([md-str params]\n   (let [valid-md (spec/assert ::markdown md-str)\n         encode? (:encode? (spec/assert ::options params))\n         html #?(:clj  (md-to-html-string valid-md)\n                 :cljs (md->html valid-md))\n         dom  (parse html)\n         hiccup (first (as-hiccup dom))]\n     (if encode?\n       hiccup ;; by default encoded by hickory\n       (d/decode hiccup))))\n  ([md-str]\n   (md->hiccup md-str {:encode? false})))\n   \n(defn hicc-in\n  \"Deprecated. Please use hiccup-in for better access to nested hiccup.\n  Accepts a hiccup data structure and a keyword representing\n  an html element tag (e.g. :body) and returns the first nested\n  hiccup vector identified by the keyword.\"\n  [hiccup & kws]\n  (let [kw   (first kws)\n        root (first hiccup)]\n    (cond\n      (nil? kw)              hiccup\n      (empty? hiccup)        []\n      (map? root)            (recur (rest hiccup) kws)\n      (vector? root)         (let [branch-result (apply hicc-in root kws)]\n                               (if (empty? branch-result)\n                                 (recur (rest hiccup) kws)\n                                 branch-result))\n      (= root kw)            (recur hiccup (rest kws))\n      :else                  (recur (rest hiccup) kws))))\n\n(defn- keywords?\n  [& args]\n  (every? keyword? args))\n\n(defn- dec-front\n  \"Accepts a list of [keyword count] pairs, and subtracts the count\n   of the first pair. If that count becomes negative, dec-front returns\n   the rest of the list. Otherwise, it returns the list with the new\n   count value for the first pair.\"\n  [kw-pairs]\n  (let [[kw count] (first kw-pairs)\n        new-count  (dec count)\n        new-pair   [kw new-count]]\n    (if (neg? new-count)\n      (rest kw-pairs)\n      (cons new-pair (rest kw-pairs)))))\n\n(defn- num-partition\n  \"Accepts a list of keywords and numbers. Any place in which\n  a number does not separate keywords, a zero will be inserted.\n  Returns the arg list as a sequence of keyword -> number pairs\n  nested as lists.\"\n  [args]\n  (loop [arglist    args\n         ret-vec   []]\n    (let [curr-arg (first arglist)\n          prev-arg (peek ret-vec)]\n      (cond\n        ;; base case\n        (nil? curr-arg)            (if (keyword? prev-arg)\n                                     (partition 2 (conj ret-vec 0))\n                                     (partition 2 ret-vec))\n        ;; recursive cases\n        (keywords? curr-arg\n                   prev-arg)       (recur (rest arglist)\n                                          (conj ret-vec 0 curr-arg))\n\n        :else                      (recur (rest arglist)\n                                          (conj ret-vec curr-arg))))))\n\n\n(defn- same-length?\n  [coll-a coll-b]\n  (= (count coll-a)\n     (count coll-b)))\n\n(defn- get-nested-hiccup\n  \"Recursive helper function for hiccup-in.\"\n  [hiccup kw-pairs]\n  (let [[kw nth-kw]   (first kw-pairs)\n        front         (first hiccup)\n        remaining     (rest hiccup)]\n    (cond\n      (empty? hiccup)        []\n      (nil? kw)              hiccup\n      (map? front)           (recur remaining kw-pairs)\n      (vector? front)        (let [branch-result (get-nested-hiccup front kw-pairs)]\n                               (if (empty? branch-result)\n                                 (let [nested-front (first front)]\n                                   (if (= nested-front kw) ;; the child recurse did find a match, but we need to update our kw-pair list if the first element had a match\n                                    (recur remaining (dec-front kw-pairs))\n                                    (recur remaining kw-pairs)))\n                                 branch-result))\n      (= front kw)           (let [new-pairs (dec-front kw-pairs)]\n                               (cond\n                                 (empty? new-pairs)                  hiccup                         ;; no keywords left, return what we have found\n                                 :else                               (recur remaining new-pairs)))  ;; prceed to the next instance of the keyword\n      :else                  (recur remaining kw-pairs))))\n\n\n\n(defn hiccup-in\n  \"Accepts a hiccup data structure and any series of args in keyword, index order.\n   Each keyword represents a hiccup element, and the paired index is which element at that level hiccup-in will look in.\n   If no number proceeds a keyword, hiccup-in will find the first element with that keyword.\n   Returns the nested hiccup vector identified by the keywords.\n   Example: (hiccup-in hiccup :html :body :div 0 :h1 2 :p)\"\n  [hiccup & kw-pairs]\n   (let [pathway (num-partition kw-pairs)]\n     (get-nested-hiccup hiccup pathway)))\n\n(defn component\n  \"Accepts hiccup and returns the same hiccup only\n   without the :html, :head, and :body elements. Useful\n   if you want to nest your markdown hiccup in existing\n   hiccup data structures.\"\n  [hiccup]\n  (let [body (hiccup-in hiccup :body)]\n    (vec (cons :div (rest body)))))\n\n#?(:clj\n  (defn file->hiccup\n  \"Generates a valid hiccup data structure from markdown\n   contained in the .md file located at file-path\"\n  [file-path]\n  (let [contents (slurp file-path)]\n    (md->hiccup contents))))\n","~:reader-features",["^H",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["cljs.spec.alpha/def-impl","cljs.core/string?","cljs.core/vector?","cljs.spec.alpha/map-spec-impl","G__36631","cljs.core/map?","cljs.spec.alpha/fspec-impl","cljs.spec.alpha.spec_impl.cljs$core$IFn$_invoke$arity$4","cljs.spec.alpha/cat-impl","var_args","G__36666","markdown-to-hiccup.core/md->hiccup","js/Error","md-str","params","valid-md","cljs.spec.alpha/*compile-asserts*","cljs.core/deref","cljs.spec.alpha/*runtime-asserts*","cljs.spec.alpha/assert*","encode?","html","markdown.core/md->html","dom","hickory.core/parse","hiccup","cljs.core/first","hickory.core/as-hiccup","markdown-to-hiccup.decode/decode","markdown_to_hiccup.core.md__GT_hiccup.cljs$core$IFn$_invoke$arity$2","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","markdown-to-hiccup.core/hicc-in","seq36667","G__36668","cljs.core/next","self__4717__auto__","kws","kw","root","cljs.core/empty?","cljs.core/rest","branch-result","cljs.core.apply.cljs$core$IFn$_invoke$arity$3","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","markdown-to-hiccup.core/keywords?","seq36675","self__4718__auto__","cljs.core/seq","args","cljs.core/every?","cljs.core/keyword?","markdown-to-hiccup.core/dec-front","kw-pairs","vec__36676","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","count","new-count","new-pair","cljs.core/cons","markdown-to-hiccup.core/num-partition","arglist","ret-vec","curr-arg","prev-arg","cljs.core/peek","cljs.core/Keyword","cljs.core.partition.cljs$core$IFn$_invoke$arity$2","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","markdown_to_hiccup.core.keywords_QMARK_.cljs$core$IFn$_invoke$arity$variadic","cljs.core.conj.cljs$core$IFn$_invoke$arity$variadic","markdown-to-hiccup.core/same-length?","coll-a","coll-b","cljs.core/count","markdown-to-hiccup.core/get-nested-hiccup","vec__36679","nth-kw","front","remaining","nested-front","new-pairs","markdown-to-hiccup.core/hiccup-in","seq36690","G__36691","pathway","markdown-to-hiccup.core/component","body","markdown_to_hiccup.core.hiccup_in.cljs$core$IFn$_invoke$arity$variadic","cljs.core/vec"]]],"~:cache-keys",["~#cmap",[["~:macro","^P"],[1559826623000],["^1;","cljs/spec/gen/alpha.cljs"],[1559826623000,"~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^H",[]],"~:deps-syms",["^Q","^P","~$goog.Uri"]]],["^1;","goog/math/math.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","~$goog.array","~$goog.asserts"]]],["^1;","goog/array/array.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^1O"]]],["^1;","goog/debug/error.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q"]]],["^1;","markdown/transformers.cljc"],[1547313541000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^P","^U","~$markdown.links","~$markdown.lists","~$markdown.tables","~$markdown.common"]]],["^1;","goog/dom/nodetype.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q"]]],["^1;","markdown/common.cljc"],[1547313541000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^P","^U"]]],["^1H","~$cljs.spec.gen.alpha"],[1559826623000],["^1;","markdown/core.cljs"],[1547313541000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^P","^1S","^1P","~$markdown.transformers"]]],["^1;","goog/object/object.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q"]]],"~:SHADOW-TIMESTAMP",[1560546091000,1559826623000],["^1;","goog/math/long.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^1O","~$goog.reflect"]]],["^1;","hickory/core.cljs"],[1547313541000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^P","~$hickory.utils","~$clojure.zip","~$goog.string"]]],["^1;","goog/string/internal.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q"]]],["^1;","goog/functions/functions.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q"]]],["^1;","clojure/walk.cljs"],[1559826623000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^P"]]],["^1;","goog/structs/map.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^1H","^E"],[1559826623000],["^1;","goog/asserts/asserts.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1;","goog/uri/uri.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^1N","^1O","^1Z","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1;","markdown/tables.cljc"],[1547313541000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^P","^U"]]],["^1;","hickory/utils.cljc"],[1547313541000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^P","^U","^1Z"]]],["^1;","cljs/spec/alpha.cljs"],[1559826623000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^P","~$goog.object","~$clojure.walk","^1T","^U"]]],["^1;","goog/base.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",[]]],["^1;","markdown_to_hiccup/decode.cljc"],[1547313542000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^P","^1Z"]]],["^1;","goog/structs/structs.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^1N","^28"]]],["^1;","markdown/lists.cljc"],[1547313541000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^P","^U","^1S"]]],["^1;","clojure/string.cljs"],[1559826623000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^P","^1Z","~$goog.string.StringBuffer"]]],["^1;","goog/string/string.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","~$goog.string.internal"]]],["^1;","goog/reflect/reflect.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q"]]],["^1;","clojure/zip.cljs"],[1559826623000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^P"]]],["^1;","goog/string/stringbuffer.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q"]]],["^1;","goog/iter/iter.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^1N","^1O","~$goog.functions","~$goog.math"]]],["^1;","cljs/core.cljs"],[1559826623000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["~$goog.math.Long","~$goog.math.Integer","^1Z","^28","^1N","^1M","^2:"]]],["^1;","goog/math/integer.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q"]]],["^1;","markdown/links.cljc"],[1547313541000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^P","^U","^1S"]]],["^1;","goog/uri/utils.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^1N","^1O","^1Z"]]],["^1;","markdown_to_hiccup/core.cljc"],[1547313542000,"^1I",["^ ","^1J",null,"^1K",["^H",[]],"^1L",["^Q","^P","^U","^E","^S","^V","^O"]]]]],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","markdown_to_hiccup/core.cljc","^7",1,"^8",5,"^9",1,"^:",28],"^;",["^ ","^<","^=","^>","^?","^@","^A","^B","^C","^D","^E"],"^F",null,"^G",["^H",[]],"^I","^J","^M",null,"^N",["^ ","^D","^E","^O","^O","^P","^P","^Q","^Q","^R","^E","^S","^S","^T","^U","^U","^U","^V","^V","^E","^E","~$d","^S"],"^W",["^H",["^X"]],"~:shadow/js-access-global",["^H",["Error"]],"^Y",["^ ","^Z","^V","^[","^V","^10","^O"],"~:defs",["^ ","~$num-partition",["^ ","~:protocol-inline",null,"^5",["^ ","^6","markdown_to_hiccup/core.cljc","^7",70,"^8",8,"^9",70,"^:",21,"~:private",true,"~:arglists",["^13",["~$quote",["^13",[["~$args"]]]]],"~:doc","Accepts a list of keywords and numbers. Any place in which\n  a number does not separate keywords, a zero will be inserted.\n  Returns the arg list as a sequence of keyword -> number pairs\n  nested as lists."],"^2E",true,"^I","~$markdown-to-hiccup.core/num-partition","^6","markdown_to_hiccup/core.cljc","^:",21,"~:method-params",["^13",[["^2H"]]],"~:protocol-impl",null,"~:arglists-meta",["^13",[null,null]],"^8",1,"~:variadic?",false,"^7",70,"~:ret-tag","~$any","^9",70,"~:max-fixed-arity",1,"~:fn-var",true,"^2F",["^13",["^2G",["^13",[["^2H"]]]]],"^2I","Accepts a list of keywords and numbers. Any place in which\n  a number does not separate keywords, a zero will be inserted.\n  Returns the arg list as a sequence of keyword -> number pairs\n  nested as lists."],"~$keywords?",["^ ","^2D",null,"^5",["^ ","^6","markdown_to_hiccup/core.cljc","^7",53,"^8",8,"^9",53,"^:",17,"^2E",true,"^2F",["^13",["^2G",["^13",[["~$&","^2H"]]]]],"~:top-fn",["^ ","^2N",true,"~:fixed-arity",0,"^2Q",0,"^2K",[["^13",["^2H"]]],"^2F",["^13",[["~$&","^2H"]]],"^2M",["^13",[null]]]],"^2E",true,"^I","~$markdown-to-hiccup.core/keywords?","^6","markdown_to_hiccup/core.cljc","^:",17,"^2T",["^ ","^2N",true,"^2U",0,"^2Q",0,"^2K",[["^13",["^2H"]]],"^2F",["^13",[["~$&","^2H"]]],"^2M",["^13",[null]]],"^2K",[["^13",["^2H"]]],"^2L",null,"^2U",0,"^2M",["^13",[null]],"^8",1,"^2N",true,"~:methods",[["^ ","^2U",0,"^2N",true,"~:tag","~$boolean"]],"^7",53,"^2O","^2P","^9",53,"^2Q",0,"^2R",true,"^2F",["^13",[["~$&","^2H"]]]],"~$same-length?",["^ ","^2D",null,"^5",["^ ","^6","markdown_to_hiccup/core.cljc","^7",94,"^8",8,"^9",94,"^:",20,"^2E",true,"^2F",["^13",["^2G",["^13",[["~$coll-a","~$coll-b"]]]]]],"^2E",true,"^I","~$markdown-to-hiccup.core/same-length?","^6","markdown_to_hiccup/core.cljc","^:",20,"^2K",["^13",[["^2[","^30"]]],"^2L",null,"^2M",["^13",[null,null]],"^8",1,"^2N",false,"^7",94,"^2O","^2Y","^9",94,"^2Q",2,"^2R",true,"^2F",["^13",["^2G",["^13",[["^2[","^30"]]]]]],"~$dec-front",["^ ","^2D",null,"^5",["^ ","^6","markdown_to_hiccup/core.cljc","^7",57,"^8",8,"^9",57,"^:",17,"^2E",true,"^2F",["^13",["^2G",["^13",[["~$kw-pairs"]]]]],"^2I","Accepts a list of [keyword count] pairs, and subtracts the count\n   of the first pair. If that count becomes negative, dec-front returns\n   the rest of the list. Otherwise, it returns the list with the new\n   count value for the first pair."],"^2E",true,"^I","~$markdown-to-hiccup.core/dec-front","^6","markdown_to_hiccup/core.cljc","^:",17,"^2K",["^13",[["^33"]]],"^2L",null,"^2M",["^13",[null,null]],"^8",1,"^2N",false,"^7",57,"^2O",["^H",["~$seq","~$clj"]],"^9",57,"^2Q",1,"^2R",true,"^2F",["^13",["^2G",["^13",[["^33"]]]]],"^2I","Accepts a list of [keyword count] pairs, and subtracts the count\n   of the first pair. If that count becomes negative, dec-front returns\n   the rest of the list. Otherwise, it returns the list with the new\n   count value for the first pair."],"~$md->hiccup",["^ ","^2D",null,"^5",["^ ","^6","markdown_to_hiccup/core.cljc","^7",16,"^8",7,"^9",16,"^:",17,"^2F",["^13",["^2G",["^13",[["~$md-str","~$params"],["^38"]]]]],"^2I","Accepts a markdown string and returns a hiccup data structure converted from that markdown.\n  Also accepts an optional params map. Use the :encode? boolean key to specify whether\n  or not you want html escape characters to be encoded. Example:\n    (md->hiccup \"#Title\" {:encode? true})","^2T",["^ ","^2N",false,"^2U",2,"^2Q",2,"^2K",["^13",[["^38","^39"],["^38"]]],"^2F",["^13",[["^38","^39"],["^38"]]],"^2M",["^13",[null,null]]]],"^I","~$markdown-to-hiccup.core/md->hiccup","^6","markdown_to_hiccup/core.cljc","^:",17,"^2T",["^ ","^2N",false,"^2U",2,"^2Q",2,"^2K",["^13",[["^38","^39"],["^38"]]],"^2F",["^13",[["^38","^39"],["^38"]]],"^2M",["^13",[null,null]]],"^2K",["^13",[["^38","^39"],["^38"]]],"^2L",null,"^2U",2,"^2M",["^13",[null,null]],"^8",1,"^2N",false,"^2W",[["^ ","^2U",2,"^2N",false,"^2X",["^H",["^2P","~$clj-nil"]]],["^ ","^2U",1,"^2N",false,"^2X",["^H",["^2P","^3;"]]]],"^7",16,"^9",16,"^2Q",2,"^2R",true,"^2F",["^13",[["^38","^39"],["^38"]]],"^2I","Accepts a markdown string and returns a hiccup data structure converted from that markdown.\n  Also accepts an optional params map. Use the :encode? boolean key to specify whether\n  or not you want html escape characters to be encoded. Example:\n    (md->hiccup \"#Title\" {:encode? true})"],"~$hiccup-in",["^ ","^2D",null,"^5",["^ ","^6","markdown_to_hiccup/core.cljc","^7",124,"^8",7,"^9",124,"^:",16,"^2F",["^13",["^2G",["^13",[["~$hiccup","~$&","^33"]]]]],"^2I","Accepts a hiccup data structure and any series of args in keyword, index order.\n   Each keyword represents a hiccup element, and the paired index is which element at that level hiccup-in will look in.\n   If no number proceeds a keyword, hiccup-in will find the first element with that keyword.\n   Returns the nested hiccup vector identified by the keywords.\n   Example: (hiccup-in hiccup :html :body :div 0 :h1 2 :p)","^2T",["^ ","^2N",true,"^2U",1,"^2Q",1,"^2K",[["^13",["^3=","^33"]]],"^2F",["^13",[["^3=","~$&","^33"]]],"^2M",["^13",[null]]]],"^I","~$markdown-to-hiccup.core/hiccup-in","^6","markdown_to_hiccup/core.cljc","^:",16,"^2T",["^ ","^2N",true,"^2U",1,"^2Q",1,"^2K",[["^13",["^3=","^33"]]],"^2F",["^13",[["^3=","~$&","^33"]]],"^2M",["^13",[null]]],"^2K",[["^13",["^3=","^33"]]],"^2L",null,"^2U",1,"^2M",["^13",[null]],"^8",1,"^2N",true,"^2W",[["^ ","^2U",1,"^2N",true,"^2X",["^H",[null,"~$cljs.core/IVector","^2P"]]]],"^7",124,"^2O","^2P","^9",124,"^2Q",1,"^2R",true,"^2F",["^13",[["^3=","~$&","^33"]]],"^2I","Accepts a hiccup data structure and any series of args in keyword, index order.\n   Each keyword represents a hiccup element, and the paired index is which element at that level hiccup-in will look in.\n   If no number proceeds a keyword, hiccup-in will find the first element with that keyword.\n   Returns the nested hiccup vector identified by the keywords.\n   Example: (hiccup-in hiccup :html :body :div 0 :h1 2 :p)"],"~$component",["^ ","^2D",null,"^5",["^ ","^6","markdown_to_hiccup/core.cljc","^7",134,"^8",7,"^9",134,"^:",16,"^2F",["^13",["^2G",["^13",[["^3="]]]]],"^2I","Accepts hiccup and returns the same hiccup only\n   without the :html, :head, and :body elements. Useful\n   if you want to nest your markdown hiccup in existing\n   hiccup data structures."],"^I","~$markdown-to-hiccup.core/component","^6","markdown_to_hiccup/core.cljc","^:",16,"^2K",["^13",[["^3="]]],"^2L",null,"^2M",["^13",[null,null]],"^8",1,"^2N",false,"^7",134,"^2O",["^H",["^36","^3?","^2P","~$cljs.core/MetaFn","^3;"]],"^9",134,"^2Q",1,"^2R",true,"^2F",["^13",["^2G",["^13",[["^3="]]]]],"^2I","Accepts hiccup and returns the same hiccup only\n   without the :html, :head, and :body elements. Useful\n   if you want to nest your markdown hiccup in existing\n   hiccup data structures."],"~$hicc-in",["^ ","^2D",null,"^5",["^ ","^6","markdown_to_hiccup/core.cljc","^7",34,"^8",7,"^9",34,"^:",14,"^2F",["^13",["^2G",["^13",[["^3=","~$&","~$kws"]]]]],"^2I","Deprecated. Please use hiccup-in for better access to nested hiccup.\n  Accepts a hiccup data structure and a keyword representing\n  an html element tag (e.g. :body) and returns the first nested\n  hiccup vector identified by the keyword.","^2T",["^ ","^2N",true,"^2U",1,"^2Q",1,"^2K",[["^13",["^3=","^3D"]]],"^2F",["^13",[["^3=","~$&","^3D"]]],"^2M",["^13",[null]]]],"^I","~$markdown-to-hiccup.core/hicc-in","^6","markdown_to_hiccup/core.cljc","^:",14,"^2T",["^ ","^2N",true,"^2U",1,"^2Q",1,"^2K",[["^13",["^3=","^3D"]]],"^2F",["^13",[["^3=","~$&","^3D"]]],"^2M",["^13",[null]]],"^2K",[["^13",["^3=","^3D"]]],"^2L",null,"^2U",1,"^2M",["^13",[null]],"^8",1,"^2N",true,"^2W",[["^ ","^2U",1,"^2N",true,"^2X",["^H",[null,"^3?","^2P"]]]],"^7",34,"^2O","^2P","^9",34,"^2Q",1,"^2R",true,"^2F",["^13",[["^3=","~$&","^3D"]]],"^2I","Deprecated. Please use hiccup-in for better access to nested hiccup.\n  Accepts a hiccup data structure and a keyword representing\n  an html element tag (e.g. :body) and returns the first nested\n  hiccup vector identified by the keyword."],"~$get-nested-hiccup",["^ ","^2D",null,"^5",["^ ","^6","markdown_to_hiccup/core.cljc","^7",99,"^8",8,"^9",99,"^:",25,"^2E",true,"^2F",["^13",["^2G",["^13",[["^3=","^33"]]]]],"^2I","Recursive helper function for hiccup-in."],"^2E",true,"^I","~$markdown-to-hiccup.core/get-nested-hiccup","^6","markdown_to_hiccup/core.cljc","^:",25,"^2K",["^13",[["^3=","^33"]]],"^2L",null,"^2M",["^13",[null,null]],"^8",1,"^2N",false,"^7",99,"^2O",["^H",[null,"^3?","^2P"]],"^9",99,"^2Q",2,"^2R",true,"^2F",["^13",["^2G",["^13",[["^3=","^33"]]]]],"^2I","Recursive helper function for hiccup-in."]],"^11",["^ ","^P","^P","^D","^E","^R","^E","^E","^E"],"~:cljs.analyzer/constants",["^ ","^W",["^H",["~:args","~:req-un","~:markdown-to-hiccup.core/markdown","~:opt-un","~:ret","~:gfn","~:pred-exprs","~:keys-pred","~$*runtime-asserts*","~$cljs.core/vector?","~:opt-keys","^2E","~:else","~$cljs.spec.alpha/cat","^L","^I","~$cljs.core/string?","~:req-specs","^6","^:","~:params","~$cljs.spec.alpha/fspec","~:encode?","~$cljs.core/map?","~$%","~:md-str","~:markdown-to-hiccup.core/hiccup","^8","~:div","~$cljs.spec.alpha/keys","~:req","~:markdown-to-hiccup.core/encode?","~:dynamic","^7","~:req-keys","~$cljs.core/fn","^3:","~:opt-specs","^9","~:pred-forms","^2F","~:body","^2I","^E","~:markdown-to-hiccup.core/options","~$cljs.spec.alpha/*runtime-asserts*","~:test","~:opt"]],"~:order",["^3K","^3V","^41","^3R","^4<","^43","^3L","^45","^3J","^3N","^3O","^3P","^3S","^3W","^44","^47","^49","^4:","^4?","^3Z","^48","~$%","^3[","^3:","^3Y","^3I","^3U","^40","^3X","^3M","^4=","^2E","^L","^I","^6","^:","^8","^46","^7","^9","^2F","^2I","^4>","^E","^3Q","^3T","^4;","^42"]],"^17",["^ ","^X",["^H",[]]],"^18",["^ "],"^19",["^Q","^P","^U","^E","^S","^V","^O"]],"^L","^J","~:ns-specs",["^ ","^3K","^3V","^41","^3R","^4<",["^13",["^43","^3L",["^45"]]],"^3:",["^13",["^3Y","^3I",["^13",["^3U","^40","^3K","^3X","^4<"]],"^3M","^41"]]],"~:ns-speced-vars",["^3:"],"~:compiler-options",["^1G",[["^4C","~:static-fns"],true,["^4C","~:elide-asserts"],false,["^4C","~:optimize-constants"],null,["^4C","^1>"],null,["^4C","~:external-config"],null,["^4C","~:tooling-config"],null,["^4C","~:emit-constants"],null,["^4C","~:load-tests"],null,["^4C","~:infer-externs"],"~:auto",["^4C","^1@"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^4C","~:fn-invoke-direct"],null,["^4C","~:source-map"],"/dev/null"]]]