["^ ","~:output",["^ ","~:js","goog.provide('instaparse.transform');\ninstaparse.transform.map_preserving_meta = (function instaparse$transform$map_preserving_meta(f,l){\nreturn cljs.core.with_meta(cljs.core.map.cljs$core$IFn$_invoke$arity$2(f,l),cljs.core.meta(l));\n});\n/**\n * This variation of the merge-meta in gll does nothing if obj is not\n * something that can have a metamap attached.\n */\ninstaparse.transform.merge_meta = (function instaparse$transform$merge_meta(obj,metamap){\nif((((!((obj == null))))?(((((obj.cljs$lang$protocol_mask$partition0$ & (262144))) || ((cljs.core.PROTOCOL_SENTINEL === obj.cljs$core$IWithMeta$))))?true:(((!obj.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.IWithMeta,obj):false)):cljs.core.native_satisfies_QMARK_(cljs.core.IWithMeta,obj))){\nreturn instaparse.gll.merge_meta(obj,metamap);\n} else {\nreturn obj;\n}\n});\ninstaparse.transform.enlive_transform = (function instaparse$transform$enlive_transform(transform_map,parse_tree){\nvar transform = (function (){var G__29358 = new cljs.core.Keyword(null,\"tag\",\"tag\",-1290361223).cljs$core$IFn$_invoke$arity$1(parse_tree);\nreturn (transform_map.cljs$core$IFn$_invoke$arity$1 ? transform_map.cljs$core$IFn$_invoke$arity$1(G__29358) : transform_map.call(null,G__29358));\n})();\nif(cljs.core.truth_(transform)){\nreturn instaparse.transform.merge_meta(cljs.core.apply.cljs$core$IFn$_invoke$arity$2(transform,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(instaparse.transform.enlive_transform,transform_map),new cljs.core.Keyword(null,\"content\",\"content\",15833224).cljs$core$IFn$_invoke$arity$1(parse_tree))),cljs.core.meta(parse_tree));\n} else {\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"tag\",\"tag\",-1290361223).cljs$core$IFn$_invoke$arity$1(parse_tree))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(parse_tree,new cljs.core.Keyword(null,\"content\",\"content\",15833224),cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(instaparse.transform.enlive_transform,transform_map),new cljs.core.Keyword(null,\"content\",\"content\",15833224).cljs$core$IFn$_invoke$arity$1(parse_tree)));\n} else {\nreturn parse_tree;\n\n}\n}\n});\ninstaparse.transform.hiccup_transform = (function instaparse$transform$hiccup_transform(transform_map,parse_tree){\nif(((cljs.core.sequential_QMARK_(parse_tree)) && (cljs.core.seq(parse_tree)))){\nvar temp__5718__auto__ = (function (){var G__29364 = cljs.core.first(parse_tree);\nreturn (transform_map.cljs$core$IFn$_invoke$arity$1 ? transform_map.cljs$core$IFn$_invoke$arity$1(G__29364) : transform_map.call(null,G__29364));\n})();\nif(cljs.core.truth_(temp__5718__auto__)){\nvar transform = temp__5718__auto__;\nreturn instaparse.transform.merge_meta(cljs.core.apply.cljs$core$IFn$_invoke$arity$2(transform,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(instaparse.transform.hiccup_transform,transform_map),cljs.core.next(parse_tree))),cljs.core.meta(parse_tree));\n} else {\nreturn cljs.core.with_meta(cljs.core.into.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(parse_tree)], null),cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(instaparse.transform.hiccup_transform,transform_map),cljs.core.next(parse_tree))),cljs.core.meta(parse_tree));\n}\n} else {\nreturn parse_tree;\n}\n});\n/**\n * Takes a transform map and a parse tree (or seq of parse-trees).\n * A transform map is a mapping from tags to \n * functions that take a node's contents and return\n * a replacement for the node, i.e.,\n * {:node-tag (fn [child1 child2 ...] node-replacement),\n *  :another-node-tag (fn [child1 child2 ...] node-replacement)}\n */\ninstaparse.transform.transform = (function instaparse$transform$transform(transform_map,parse_tree){\nif(typeof parse_tree === 'string'){\nreturn parse_tree;\n} else {\nif(cljs.core.truth_((function (){var and__4120__auto__ = cljs.core.map_QMARK_(parse_tree);\nif(and__4120__auto__){\nreturn new cljs.core.Keyword(null,\"tag\",\"tag\",-1290361223).cljs$core$IFn$_invoke$arity$1(parse_tree);\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn instaparse.transform.enlive_transform(transform_map,parse_tree);\n} else {\nif(((cljs.core.vector_QMARK_(parse_tree)) && ((cljs.core.first(parse_tree) instanceof cljs.core.Keyword)))){\nreturn instaparse.transform.hiccup_transform(transform_map,parse_tree);\n} else {\nif(cljs.core.sequential_QMARK_(parse_tree)){\nreturn instaparse.transform.map_preserving_meta(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(instaparse.transform.transform,transform_map),parse_tree);\n} else {\nif((parse_tree instanceof instaparse.gll.Failure)){\nreturn parse_tree;\n} else {\nreturn instaparse.util.throw_illegal_argument_exception.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"Invalid parse-tree, not recognized as either enlive or hiccup format.\"], 0));\n\n}\n}\n}\n}\n}\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:doc","Functions to transform parse trees","~:file","instaparse/transform.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",25],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$create-react-class","~$module$node_modules$create_react_class$index","~$react-dom","~$module$node_modules$react_dom$index","~$clojure.spec.alpha","~$cljs.spec.alpha"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$instaparse.transform","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$instaparse.gll","^P","~$instaparse.util","^Q","~$cljs.core","^R","~$goog","^S"],"~:seen",["^I",["~:require"]],"~:uses",["^ ","~$throw-illegal-argument-exception","^Q"],"~:require-macros",["^ ","^R","^R","^P","^P"],"~:form",["~#list",["~$ns","^K","Functions to transform parse trees",["^Z",["^U",["^P"],["^Q","~:refer",["^W"]]]]]],"~:flags",["^ ","^U",["^I",[]]],"~:js-deps",["^ "],"~:deps",["^S","^R","^P","^Q"]],"^M","^K","~:resource-id",["~:shadow.build.classpath/resource","instaparse/transform.cljc"],"~:compiled-at",1560578450232,"~:resource-name","instaparse/transform.cljc","~:warnings",[],"~:source","(ns instaparse.transform\r\n  \"Functions to transform parse trees\"\r\n  (:require [instaparse.gll]\r\n            [instaparse.util :refer [throw-illegal-argument-exception]]))\r\n\r\n(defn map-preserving-meta [f l]\r\n  (with-meta (map f l) (meta l)))\r\n\r\n(defn merge-meta\r\n  \"This variation of the merge-meta in gll does nothing if obj is not\r\nsomething that can have a metamap attached.\"\r\n  [obj metamap]\r\n  (if #?(:clj (instance? clojure.lang.IObj obj)\r\n         :cljs (satisfies? IWithMeta obj))\r\n    (instaparse.gll/merge-meta obj metamap)\r\n    obj))\r\n\r\n(defn- enlive-transform\r\n  [transform-map parse-tree]\r\n  (let [transform (transform-map (:tag parse-tree))]\r\n    (cond\r\n      transform\r\n      (merge-meta \r\n        (apply transform (map (partial enlive-transform transform-map)\r\n                              (:content parse-tree)))\r\n        (meta parse-tree))\r\n      (:tag parse-tree)\r\n      (assoc parse-tree :content (map (partial enlive-transform transform-map)\r\n                                      (:content parse-tree)))\r\n      :else\r\n      parse-tree)))\r\n\r\n(defn- hiccup-transform\r\n  [transform-map parse-tree]\r\n  (if (and (sequential? parse-tree) (seq parse-tree))\r\n    (if-let [transform (transform-map (first parse-tree))]\r\n      (merge-meta\r\n        (apply transform (map (partial hiccup-transform transform-map)\r\n                              (next parse-tree)))\r\n        (meta parse-tree))\r\n      (with-meta \r\n        (into [(first parse-tree)]\r\n              (map (partial hiccup-transform transform-map) \r\n                   (next parse-tree)))\r\n        (meta parse-tree)))\r\n    parse-tree))\r\n\r\n(defn transform\r\n  \"Takes a transform map and a parse tree (or seq of parse-trees).\r\n   A transform map is a mapping from tags to \r\n   functions that take a node's contents and return\r\n   a replacement for the node, i.e.,\r\n   {:node-tag (fn [child1 child2 ...] node-replacement),\r\n    :another-node-tag (fn [child1 child2 ...] node-replacement)}\"\r\n  [transform-map parse-tree]\r\n  ; Detect what kind of tree this is\r\n  (cond\r\n    (string? parse-tree)\r\n    ; This is a leaf of the tree that should pass through unchanged\r\n    parse-tree\r\n\r\n    (and (map? parse-tree) (:tag parse-tree))\r\n    ; This is an enlive tree-seq\r\n    (enlive-transform transform-map parse-tree)\r\n    \r\n    (and (vector? parse-tree) (keyword? (first parse-tree)))\r\n    ; This is a hiccup tree-seq\r\n    (hiccup-transform transform-map parse-tree)\r\n    \r\n    (sequential? parse-tree)\r\n    ; This is either a sequence of parse results, or a tree\r\n    ; with a hidden root tag.\r\n    (map-preserving-meta (partial transform transform-map) parse-tree)\r\n    \r\n    (instance? instaparse.gll.Failure parse-tree)\r\n    ; pass failures through unchanged\r\n    parse-tree\r\n    \r\n    :else\r\n    (throw-illegal-argument-exception\r\n      \"Invalid parse-tree, not recognized as either enlive or hiccup format.\")))\r\n","~:reader-features",["^I",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings",";AAKA,AAAA,AAAMA,AAAqBC,AAAEC;AAA7B,AACE,AAACC,AAAU,AAACC,AAAIH,AAAEC,AAAG,AAACG,AAAKH;;AAE7B;;;;AAAA,AAAMI,AAGHC,AAAIC;AAHP,AAIE,AACa,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAC,AAAA,AAAA,AAAAA,AAAYC,AAAAA,AAAUJ,AAAAA,AAAAA,AAAAA,AAAAA,AAAAA;AACjC,AAACK,AAA0BL,AAAIC;;AAC/BD;;;AAEJ,AAAA,AAAOM,AACJC,AAAcC;AADjB,AAEE,AAAMC,AAAU,AAAAC,AAAe,AAAA,AAAMF;AAArB,AAAA,AAAAE,AAAAA,AAACH,AAAAA,AAAAA;;AAAjB,AACE,AACEE;AACA,AAACV,AACC,AAACY,AAAMF,AAAU,AAACZ,AAAI,AAACe,AAAQN,AAAiBC,AAC1B,AAAA,AAAUC,AAChC,AAACV,AAAKU;;AALV,AAME,AAAA,AAAMA;AACN,AAAA,AAACK,AAAML,AAAoB,AAACX,AAAI,AAACe,AAAQN,AAAiBC,AAC1B,AAAA,AAAUC;;AAR5C,AAUEA;;;;;AAEN,AAAA,AAAOM,AACJP,AAAcC;AADjB,AAEE,AAAI,AAAK,AAACO,AAAYP,AAAY,AAACQ,AAAIR;AACrC,AAAAS,AAAmB,AAAAC,AAAe,AAACC,AAAMX;AAAtB,AAAA,AAAAU,AAAAA,AAACX,AAAAA,AAAAA;;AAApB,AAAA,AAAAU;AAAA,AAAAA,AAASR;AAAT,AACE,AAACV,AACC,AAACY,AAAMF,AAAU,AAACZ,AAAI,AAACe,AAAQE,AAAiBP,AAC1B,AAACa,AAAKZ,AAC5B,AAACV,AAAKU;;AACR,AAACZ,AACC,AAAA,AAACyB,AAAM,AAACF,AAAMX,AACR,AAACX,AAAI,AAACe,AAAQE,AAAiBP,AAC1B,AAACa,AAAKZ,AACjB,AAACV,AAAKU;;;AACVA;;;AAEJ;;;;;;;;AAAA,AAAMc,AAOHf,AAAcC;AAPjB,AASE,AACE,AAASA;AAETA;;AAHF,AAKE,AAAAe,AAAK,AAACC,AAAKhB;AAAX,AAAA,AAAAe;AAAuB,AAAA,AAAMf;;AAA7Be;;;AAEA,AAACjB,AAAiBC,AAAcC;;AAPlC,AASE,AAAK,AAACiB,AAAQjB,AAAY,AAAAkB,AAAU,AAACP,AAAMX;AAE3C,AAACM,AAAiBP,AAAcC;;AAXlC,AAaE,AAACO,AAAYP;AAGb,AAACf,AAAoB,AAACmB,AAAQU,AAAUf,AAAeC;;AAhBzD,AAkBE,AAAWmB,AAAuBnB;AAElCA;;AApBF,AAuBE,AAAA,AAACoB","names",["instaparse.transform/map-preserving-meta","f","l","cljs.core/with-meta","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core/meta","instaparse.transform/merge-meta","obj","metamap","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","cljs.core/IWithMeta","instaparse.gll/merge-meta","instaparse.transform/enlive-transform","transform-map","parse-tree","transform","G__29358","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","instaparse.transform/hiccup-transform","cljs.core/sequential?","cljs.core/seq","temp__5718__auto__","G__29364","cljs.core/first","cljs.core/next","cljs.core.into.cljs$core$IFn$_invoke$arity$2","instaparse.transform/transform","and__4120__auto__","cljs.core/map?","cljs.core/vector?","cljs.core/Keyword","instaparse.gll/Failure","instaparse.util.throw_illegal_argument_exception.cljs$core$IFn$_invoke$arity$variadic"]]],"~:cache-keys",["~#cmap",[["^15","instaparse/auto_flatten_seq.cljc"],[1548085352000,"~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^I",[]],"~:deps-syms",["^S","^R"]]],["~:macro","^R"],[1559826623000],["^15","goog/math/math.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S","~$goog.array","~$goog.asserts"]]],["^15","instaparse/gll.cljc"],[1548085352000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S","^R","~$instaparse.auto-flatten-seq","~$instaparse.failure","~$instaparse.reduction","~$instaparse.combinators-source","~$instaparse.print","^Q","~$goog.i18n.uChar"]]],["^15","goog/array/array.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S","^1H"]]],["^15","goog/debug/error.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S"]]],["^15","goog/dom/nodetype.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S"]]],["^15","instaparse/transform.cljc"],[1548085352000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S","^R","^P","^Q"]]],["^15","goog/object/object.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S"]]],"~:SHADOW-TIMESTAMP",[1560546091000,1559826623000],["^15","goog/math/long.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S","^1H","~$goog.reflect"]]],["^15","instaparse/reduction.cljc"],[1548085352000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S","^R","^1I","^Q"]]],["^15","goog/string/internal.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S"]]],["^15","goog/i18n/uchar.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S"]]],["^15","goog/functions/functions.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S"]]],["^15","goog/structs/map.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^15","instaparse/failure.cljc"],[1548085352000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S","^R","^1M"]]],["^15","goog/asserts/asserts.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^15","goog/uri/uri.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S","^1G","^1H","~$goog.string","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^15","instaparse/print.cljc"],[1548085352000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S","^R","~$clojure.string"]]],["^1F","^P"],[1548085352000],["^15","goog/base.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",[]]],["^15","goog/structs/structs.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S","^1G","~$goog.object"]]],["^15","clojure/string.cljs"],[1559826623000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S","^R","^1U","~$goog.string.StringBuffer"]]],["^15","goog/string/string.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S","~$goog.string.internal"]]],["^15","goog/reflect/reflect.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S"]]],["^15","goog/string/stringbuffer.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S"]]],["^15","goog/iter/iter.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S","^1G","^1H","~$goog.functions","~$goog.math"]]],["^15","cljs/core.cljs"],[1559826623000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["~$goog.math.Long","~$goog.math.Integer","^1U","^20","^1G","~$goog.Uri","^21"]]],["^15","instaparse/util.cljc"],[1548085352000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S","^R"]]],["^15","goog/math/integer.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S"]]],["^15","goog/uri/utils.js"],[1560546089000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S","^1G","^1H","^1U"]]],["^15","instaparse/combinators_source.cljc"],[1548085352000,"^1B",["^ ","^1C",null,"^1D",["^I",[]],"^1E",["^S","^R","^1K","^Q"]]]]],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","Functions to transform parse trees","^7","instaparse/transform.cljc","^8",1,"^9",5,"^:",1,"^;",25],"^<",["^ ","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F"],"^G",null,"^H",["^I",[]],"^J","^K","^N",null,"^O",["^ ","^P","^P","^Q","^Q","^R","^R","^S","^S"],"^T",["^I",["^U"]],"^V",["^ ","^W","^Q"],"~:defs",["^ ","~$map-preserving-meta",["^ ","~:protocol-inline",null,"^5",["^ ","^7","instaparse/transform.cljc","^8",6,"^9",7,"^:",6,"^;",26,"~:arglists",["^Z",["~$quote",["^Z",[["~$f","~$l"]]]]]],"^J","~$instaparse.transform/map-preserving-meta","^7","instaparse/transform.cljc","^;",26,"~:method-params",["^Z",[["~$f","~$l"]]],"~:protocol-impl",null,"~:arglists-meta",["^Z",[null,null]],"^9",1,"~:variadic?",false,"^8",6,"~:ret-tag",["^I",["~$clj","~$cljs.core/MetaFn","~$clj-nil"]],"^:",6,"~:max-fixed-arity",2,"~:fn-var",true,"^2<",["^Z",["^2=",["^Z",[["~$f","~$l"]]]]]],"~$merge-meta",["^ ","^2;",null,"^5",["^ ","^7","instaparse/transform.cljc","^8",9,"^9",7,"^:",9,"^;",17,"^2<",["^Z",["^2=",["^Z",[["~$obj","~$metamap"]]]]],"^6","This variation of the merge-meta in gll does nothing if obj is not\nsomething that can have a metamap attached."],"^J","~$instaparse.transform/merge-meta","^7","instaparse/transform.cljc","^;",17,"^2?",["^Z",[["^2J","^2K"]]],"^2@",null,"^2A",["^Z",[null,null]],"^9",1,"^2B",false,"^8",9,"^2C",["^I",[null,"^2D","^2E","^2F"]],"^:",9,"^2G",2,"^2H",true,"^2<",["^Z",["^2=",["^Z",[["^2J","^2K"]]]]],"^6","This variation of the merge-meta in gll does nothing if obj is not\nsomething that can have a metamap attached."],"~$enlive-transform",["^ ","^2;",null,"^5",["^ ","^7","instaparse/transform.cljc","^8",18,"^9",8,"^:",18,"^;",24,"~:private",true,"^2<",["^Z",["^2=",["^Z",[["~$transform-map","~$parse-tree"]]]]]],"^2N",true,"^J","~$instaparse.transform/enlive-transform","^7","instaparse/transform.cljc","^;",24,"^2?",["^Z",[["^2O","^2P"]]],"^2@",null,"^2A",["^Z",[null,null]],"^9",1,"^2B",false,"^8",18,"^2C",["^I",[null,"^2D","~$any","^2E","^2F"]],"^:",18,"^2G",2,"^2H",true,"^2<",["^Z",["^2=",["^Z",[["^2O","^2P"]]]]]],"~$hiccup-transform",["^ ","^2;",null,"^5",["^ ","^7","instaparse/transform.cljc","^8",33,"^9",8,"^:",33,"^;",24,"^2N",true,"^2<",["^Z",["^2=",["^Z",[["^2O","^2P"]]]]]],"^2N",true,"^J","~$instaparse.transform/hiccup-transform","^7","instaparse/transform.cljc","^;",24,"^2?",["^Z",[["^2O","^2P"]]],"^2@",null,"^2A",["^Z",[null,null]],"^9",1,"^2B",false,"^8",33,"^2C",["^I",[null,"^2D","^2E","^2F"]],"^:",33,"^2G",2,"^2H",true,"^2<",["^Z",["^2=",["^Z",[["^2O","^2P"]]]]]],"~$transform",["^ ","^2;",null,"^5",["^ ","^7","instaparse/transform.cljc","^8",48,"^9",7,"^:",48,"^;",16,"^2<",["^Z",["^2=",["^Z",[["^2O","^2P"]]]]],"^6","Takes a transform map and a parse tree (or seq of parse-trees).\n   A transform map is a mapping from tags to \n   functions that take a node's contents and return\n   a replacement for the node, i.e.,\n   {:node-tag (fn [child1 child2 ...] node-replacement),\n    :another-node-tag (fn [child1 child2 ...] node-replacement)}"],"^J","~$instaparse.transform/transform","^7","instaparse/transform.cljc","^;",16,"^2?",["^Z",[["^2O","^2P"]]],"^2@",null,"^2A",["^Z",[null,null]],"^9",1,"^2B",false,"^8",48,"^2C",["^I",[null,"^2D","^2R","~$string","^2E","~$instaparse.gll/Failure","^2F"]],"^:",48,"^2G",2,"^2H",true,"^2<",["^Z",["^2=",["^Z",[["^2O","^2P"]]]]],"^6","Takes a transform map and a parse tree (or seq of parse-trees).\n   A transform map is a mapping from tags to \n   functions that take a node's contents and return\n   a replacement for the node, i.e.,\n   {:node-tag (fn [child1 child2 ...] node-replacement),\n    :another-node-tag (fn [child1 child2 ...] node-replacement)}"]],"^X",["^ ","^R","^R","^P","^P"],"~:cljs.analyzer/constants",["^ ","^T",["^I",["~:else","~:content","~:tag"]],"~:order",["^30","^2[","^2Z"]],"^11",["^ ","^U",["^I",[]]],"^12",["^ "],"^13",["^S","^R","^P","^Q"]],"^M","^K","~:ns-specs",["^ "],"~:ns-speced-vars",[],"~:compiler-options",["^1A",[["^34","~:static-fns"],true,["^34","~:elide-asserts"],true,["^34","~:optimize-constants"],null,["^34","^18"],null,["^34","~:external-config"],null,["^34","~:tooling-config"],null,["^34","~:emit-constants"],null,["^34","~:load-tests"],false,["^34","~:infer-externs"],true,["^34","^1:"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:release",["^34","~:fn-invoke-direct"],null,["^34","~:source-map"],"/dev/null"]]]