["^ ","~:output",["^ ","~:js","goog.provide('loom.alg');\nloom.alg.traverse_all = (function loom$alg$traverse_all(nodes,traverse){\nreturn cljs.core.persistent_BANG_(cljs.core.second(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p__29982,n){\nvar vec__29983 = p__29982;\nvar seen = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__29983,(0),null);\nvar trav = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__29983,(1),null);\nif(cljs.core.truth_((seen.cljs$core$IFn$_invoke$arity$1 ? seen.cljs$core$IFn$_invoke$arity$1(n) : seen.call(null,n)))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [seen,trav], null);\n} else {\nvar ctrav = (function (){var G__29986 = n;\nvar G__29987 = new cljs.core.Keyword(null,\"seen\",\"seen\",-518999789);\nvar G__29988 = seen;\nreturn (traverse.cljs$core$IFn$_invoke$arity$3 ? traverse.cljs$core$IFn$_invoke$arity$3(G__29986,G__29987,G__29988) : traverse.call(null,G__29986,G__29987,G__29988));\n})();\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.into.cljs$core$IFn$_invoke$arity$2(seen,ctrav),cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.conj_BANG_,trav,ctrav)], null);\n}\n}),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentHashSet.EMPTY,cljs.core.transient$(cljs.core.PersistentVector.EMPTY)], null),nodes)));\n});\n/**\n * Traverses graph g depth-first from start. Returns a lazy seq of nodes.\n *   When no starting node is provided, traverses the entire graph, connected\n *   or not.\n * @param {...*} var_args\n */\nloom.alg.pre_traverse = (function loom$alg$pre_traverse(var_args){\nvar G__29990 = arguments.length;\nswitch (G__29990) {\ncase 1:\nreturn loom.alg.pre_traverse.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn loom.alg.pre_traverse.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nloom.alg.pre_traverse.cljs$core$IFn$_invoke$arity$1 = (function (g){\nreturn loom.alg.traverse_all(loom.graph.nodes(g),cljs.core.partial.cljs$core$IFn$_invoke$arity$2(loom.alg_generic.pre_traverse,loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g)));\n});\n\nloom.alg.pre_traverse.cljs$core$IFn$_invoke$arity$2 = (function (g,start){\nreturn loom.alg_generic.pre_traverse(loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),start);\n});\n\nloom.alg.pre_traverse.cljs$lang$maxFixedArity = 2;\n\n/**\n * Returns a depth-first spanning tree of the form {node [successors]}\n * @param {...*} var_args\n */\nloom.alg.pre_span = (function loom$alg$pre_span(var_args){\nvar G__29994 = arguments.length;\nswitch (G__29994) {\ncase 1:\nreturn loom.alg.pre_span.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn loom.alg.pre_span.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nloom.alg.pre_span.cljs$core$IFn$_invoke$arity$1 = (function (g){\nreturn cljs.core.second(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p__29995,n){\nvar vec__29996 = p__29995;\nvar seen = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__29996,(0),null);\nvar span = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__29996,(1),null);\nif(cljs.core.truth_((seen.cljs$core$IFn$_invoke$arity$1 ? seen.cljs$core$IFn$_invoke$arity$1(n) : seen.call(null,n)))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [seen,span], null);\n} else {\nvar vec__30000 = loom.alg_generic.pre_span.cljs$core$IFn$_invoke$arity$variadic(loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),n,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"seen\",\"seen\",-518999789),seen,new cljs.core.Keyword(null,\"return-seen\",\"return-seen\",308792727),true], 0));\nvar cspan = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30000,(0),null);\nvar seen__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30000,(1),null);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [seen__$1,cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([span,cljs.core.PersistentArrayMap.createAsIfByAssoc([n,cljs.core.PersistentVector.EMPTY]),cspan], 0))], null);\n}\n}),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentHashSet.EMPTY,cljs.core.PersistentArrayMap.EMPTY], null),loom.graph.nodes(g)));\n});\n\nloom.alg.pre_span.cljs$core$IFn$_invoke$arity$2 = (function (g,start){\nreturn loom.alg_generic.pre_span(loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),start);\n});\n\nloom.alg.pre_span.cljs$lang$maxFixedArity = 2;\n\n/**\n * Traverses graph g depth-first, post-order from start. Returns a\n *   vector of the nodes.\n * @param {...*} var_args\n */\nloom.alg.post_traverse = (function loom$alg$post_traverse(var_args){\nvar G__30008 = arguments.length;\nswitch (G__30008) {\ncase 1:\nreturn loom.alg.post_traverse.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___30560 = arguments.length;\nvar i__4731__auto___30561 = (0);\nwhile(true){\nif((i__4731__auto___30561 < len__4730__auto___30560)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___30561]));\n\nvar G__30562 = (i__4731__auto___30561 + (1));\ni__4731__auto___30561 = G__30562;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn loom.alg.post_traverse.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\nloom.alg.post_traverse.cljs$core$IFn$_invoke$arity$1 = (function (g){\nreturn loom.alg.traverse_all(loom.graph.nodes(g),cljs.core.partial.cljs$core$IFn$_invoke$arity$2(loom.alg_generic.post_traverse,loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g)));\n});\n\nloom.alg.post_traverse.cljs$core$IFn$_invoke$arity$variadic = (function (g,start,opts){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$4(loom.alg_generic.post_traverse,loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),start,opts);\n});\n\n/** @this {Function} */\nloom.alg.post_traverse.cljs$lang$applyTo = (function (seq30005){\nvar G__30006 = cljs.core.first(seq30005);\nvar seq30005__$1 = cljs.core.next(seq30005);\nvar G__30007 = cljs.core.first(seq30005__$1);\nvar seq30005__$2 = cljs.core.next(seq30005__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__30006,G__30007,seq30005__$2);\n});\n\nloom.alg.post_traverse.cljs$lang$maxFixedArity = (2);\n\n/**\n * Topological sort of a directed acyclic graph (DAG). Returns nil if\n *   g contains any cycles.\n * @param {...*} var_args\n */\nloom.alg.topsort = (function loom$alg$topsort(var_args){\nvar G__30010 = arguments.length;\nswitch (G__30010) {\ncase 1:\nreturn loom.alg.topsort.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn loom.alg.topsort.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nloom.alg.topsort.cljs$core$IFn$_invoke$arity$1 = (function (g){\nvar seen = cljs.core.PersistentHashSet.EMPTY;\nvar result = cljs.core.List.EMPTY;\nvar G__30014 = cljs.core.seq(loom.graph.nodes(g));\nvar vec__30015 = G__30014;\nvar seq__30016 = cljs.core.seq(vec__30015);\nvar first__30017 = cljs.core.first(seq__30016);\nvar seq__30016__$1 = cljs.core.next(seq__30016);\nvar n = first__30017;\nvar ns = seq__30016__$1;\nvar seen__$1 = seen;\nvar result__$1 = result;\nvar G__30014__$1 = G__30014;\nwhile(true){\nvar seen__$2 = seen__$1;\nvar result__$2 = result__$1;\nvar vec__30021 = G__30014__$1;\nvar seq__30022 = cljs.core.seq(vec__30021);\nvar first__30023 = cljs.core.first(seq__30022);\nvar seq__30022__$1 = cljs.core.next(seq__30022);\nvar n__$1 = first__30023;\nvar ns__$1 = seq__30022__$1;\nif(cljs.core.not(n__$1)){\nreturn result__$2;\n} else {\nif(cljs.core.truth_((seen__$2.cljs$core$IFn$_invoke$arity$1 ? seen__$2.cljs$core$IFn$_invoke$arity$1(n__$1) : seen__$2.call(null,n__$1)))){\nvar G__30577 = seen__$2;\nvar G__30578 = result__$2;\nvar G__30579 = ns__$1;\nseen__$1 = G__30577;\nresult__$1 = G__30578;\nG__30014__$1 = G__30579;\ncontinue;\n} else {\nvar temp__5720__auto__ = loom.alg_generic.topsort_component.cljs$core$IFn$_invoke$arity$4(loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),n__$1,seen__$2,seen__$2);\nif(cljs.core.truth_(temp__5720__auto__)){\nvar cresult = temp__5720__auto__;\nvar G__30580 = cljs.core.into.cljs$core$IFn$_invoke$arity$2(seen__$2,cresult);\nvar G__30581 = cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cresult,result__$2);\nvar G__30582 = ns__$1;\nseen__$1 = G__30580;\nresult__$1 = G__30581;\nG__30014__$1 = G__30582;\ncontinue;\n} else {\nreturn null;\n}\n}\n}\nbreak;\n}\n});\n\nloom.alg.topsort.cljs$core$IFn$_invoke$arity$2 = (function (g,start){\nreturn loom.alg_generic.topsort_component.cljs$core$IFn$_invoke$arity$2(loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),start);\n});\n\nloom.alg.topsort.cljs$lang$maxFixedArity = 2;\n\n/**\n * Traverses graph g breadth-first from start. When option :f is provided,\n *   returns a lazy seq of (f node predecessor-map depth) for each node traversed.\n *   Otherwise, returns a lazy seq of the nodes. When option :when is provided,\n *   filters successors with (f neighbor predecessor depth).\n * @param {...*} var_args\n */\nloom.alg.bf_traverse = (function loom$alg$bf_traverse(var_args){\nvar G__30041 = arguments.length;\nswitch (G__30041) {\ncase 1:\nreturn loom.alg.bf_traverse.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn loom.alg.bf_traverse.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__4751__auto__ = [];\nvar len__4730__auto___30587 = arguments.length;\nvar i__4731__auto___30588 = (0);\nwhile(true){\nif((i__4731__auto___30588 < len__4730__auto___30587)){\nargs_arr__4751__auto__.push((arguments[i__4731__auto___30588]));\n\nvar G__30590 = (i__4731__auto___30588 + (1));\ni__4731__auto___30588 = G__30590;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4752__auto__ = (new cljs.core.IndexedSeq(args_arr__4751__auto__.slice((2)),(0),null));\nreturn loom.alg.bf_traverse.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4752__auto__);\n\n}\n});\n\nloom.alg.bf_traverse.cljs$core$IFn$_invoke$arity$1 = (function (g){\nreturn cljs.core.first(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p__30049,n){\nvar vec__30050 = p__30049;\nvar cc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30050,(0),null);\nvar predmap = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30050,(1),null);\nif(cljs.core.contains_QMARK_(predmap,n)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cc,predmap], null);\n} else {\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (vec__30050,cc,predmap){\nreturn (function (p__30054,p__30055){\nvar vec__30056 = p__30054;\nvar cc__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30056,(0),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30056,(1),null);\nvar vec__30059 = p__30055;\nvar n__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30059,(0),null);\nvar pm = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30059,(1),null);\nvar ___$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30059,(2),null);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cc__$1,n__$1),pm], null);\n});})(vec__30050,cc,predmap))\n,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cc,predmap], null),loom.alg_generic.bf_traverse.cljs$core$IFn$_invoke$arity$variadic(loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),n,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"f\",\"f\",-1597136552),cljs.core.vector,new cljs.core.Keyword(null,\"seen\",\"seen\",-518999789),predmap], 0)));\n}\n}),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentVector.EMPTY,cljs.core.PersistentArrayMap.EMPTY], null),loom.graph.nodes(g)));\n});\n\nloom.alg.bf_traverse.cljs$core$IFn$_invoke$arity$2 = (function (g,start){\nreturn loom.alg_generic.bf_traverse(loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),start);\n});\n\nloom.alg.bf_traverse.cljs$core$IFn$_invoke$arity$variadic = (function (g,start,opts){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$4(loom.alg_generic.bf_traverse,loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),start,opts);\n});\n\n/** @this {Function} */\nloom.alg.bf_traverse.cljs$lang$applyTo = (function (seq30038){\nvar G__30039 = cljs.core.first(seq30038);\nvar seq30038__$1 = cljs.core.next(seq30038);\nvar G__30040 = cljs.core.first(seq30038__$1);\nvar seq30038__$2 = cljs.core.next(seq30038__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__30039,G__30040,seq30038__$2);\n});\n\nloom.alg.bf_traverse.cljs$lang$maxFixedArity = (2);\n\n/**\n * Returns a breadth-first spanning tree of the form {node [successors]}\n * @param {...*} var_args\n */\nloom.alg.bf_span = (function loom$alg$bf_span(var_args){\nvar G__30070 = arguments.length;\nswitch (G__30070) {\ncase 1:\nreturn loom.alg.bf_span.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn loom.alg.bf_span.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nloom.alg.bf_span.cljs$core$IFn$_invoke$arity$1 = (function (g){\nreturn loom.alg_generic.preds__GT_span(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (predmap,n){\nif(cljs.core.contains_QMARK_(predmap,n)){\nreturn predmap;\n} else {\nreturn cljs.core.last(loom.alg_generic.bf_traverse.cljs$core$IFn$_invoke$arity$variadic(loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),n,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"f\",\"f\",-1597136552),(function (_,pm,___$1){\nreturn pm;\n}),new cljs.core.Keyword(null,\"seen\",\"seen\",-518999789),predmap], 0)));\n}\n}),cljs.core.PersistentArrayMap.EMPTY,loom.graph.nodes(g)));\n});\n\nloom.alg.bf_span.cljs$core$IFn$_invoke$arity$2 = (function (g,start){\nreturn loom.alg_generic.bf_span(loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),start);\n});\n\nloom.alg.bf_span.cljs$lang$maxFixedArity = 2;\n\n/**\n * Returns a path from start to end with the fewest hops (i.e. irrespective\n *   of edge weights)\n * @param {...*} var_args\n */\nloom.alg.bf_path = (function loom$alg$bf_path(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___30609 = arguments.length;\nvar i__4731__auto___30610 = (0);\nwhile(true){\nif((i__4731__auto___30610 < len__4730__auto___30609)){\nargs__4736__auto__.push((arguments[i__4731__auto___30610]));\n\nvar G__30611 = (i__4731__auto___30610 + (1));\ni__4731__auto___30610 = G__30611;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((3) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((3)),(0),null)):null);\nreturn loom.alg.bf_path.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4737__auto__);\n});\n\nloom.alg.bf_path.cljs$core$IFn$_invoke$arity$variadic = (function (g,start,end,opts){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$5(loom.alg_generic.bf_path,loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),start,end,opts);\n});\n\nloom.alg.bf_path.cljs$lang$maxFixedArity = (3);\n\n/** @this {Function} */\nloom.alg.bf_path.cljs$lang$applyTo = (function (seq30074){\nvar G__30075 = cljs.core.first(seq30074);\nvar seq30074__$1 = cljs.core.next(seq30074);\nvar G__30076 = cljs.core.first(seq30074__$1);\nvar seq30074__$2 = cljs.core.next(seq30074__$1);\nvar G__30077 = cljs.core.first(seq30074__$2);\nvar seq30074__$3 = cljs.core.next(seq30074__$2);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__30075,G__30076,G__30077,seq30074__$3);\n});\n\n/**\n * Using a bidirectional breadth-first search, finds a path from start to\n *   end with the fewest hops (i.e. irrespective of edge weights). Can be much\n *   faster than a unidirectional search on certain types of graphs\n */\nloom.alg.bf_path_bi = (function loom$alg$bf_path_bi(g,start,end){\nif(loom.graph.directed_QMARK_(g)){\nreturn loom.alg_generic.bf_path_bi(loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),loom.graph.predecessors.cljs$core$IFn$_invoke$arity$1(g),start,end);\n} else {\nreturn loom.alg_generic.bf_path_bi(loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),start,end);\n}\n});\n/**\n * Returns a lazy-seq of [current-node state] where state is a map in\n *   the format {node [distance predecessor]}. When f is provided,\n *   returns a lazy-seq of (f node state) for each node\n * @param {...*} var_args\n */\nloom.alg.dijkstra_traverse = (function loom$alg$dijkstra_traverse(var_args){\nvar G__30085 = arguments.length;\nswitch (G__30085) {\ncase 1:\nreturn loom.alg.dijkstra_traverse.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn loom.alg.dijkstra_traverse.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn loom.alg.dijkstra_traverse.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nloom.alg.dijkstra_traverse.cljs$core$IFn$_invoke$arity$1 = (function (g){\nreturn loom.alg_generic.dijkstra_traverse.cljs$core$IFn$_invoke$arity$3(loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),loom.graph.weight.cljs$core$IFn$_invoke$arity$1(g),cljs.core.first(loom.graph.nodes(g)));\n});\n\nloom.alg.dijkstra_traverse.cljs$core$IFn$_invoke$arity$2 = (function (g,start){\nreturn loom.alg_generic.dijkstra_traverse.cljs$core$IFn$_invoke$arity$4(loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),loom.graph.weight.cljs$core$IFn$_invoke$arity$1(g),start,cljs.core.vector);\n});\n\nloom.alg.dijkstra_traverse.cljs$core$IFn$_invoke$arity$3 = (function (g,start,f){\nreturn loom.alg_generic.dijkstra_traverse.cljs$core$IFn$_invoke$arity$4(loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),loom.graph.weight.cljs$core$IFn$_invoke$arity$1(g),start,f);\n});\n\nloom.alg.dijkstra_traverse.cljs$lang$maxFixedArity = 3;\n\n/**\n * Finds all shortest distances from start. Returns a map in the\n *   format {node {successor distance}}\n * @param {...*} var_args\n */\nloom.alg.dijkstra_span = (function loom$alg$dijkstra_span(var_args){\nvar G__30094 = arguments.length;\nswitch (G__30094) {\ncase 1:\nreturn loom.alg.dijkstra_span.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn loom.alg.dijkstra_span.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nloom.alg.dijkstra_span.cljs$core$IFn$_invoke$arity$1 = (function (g){\nreturn loom.alg_generic.dijkstra_span(loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),loom.graph.weight.cljs$core$IFn$_invoke$arity$1(g),cljs.core.first(loom.graph.nodes(g)));\n});\n\nloom.alg.dijkstra_span.cljs$core$IFn$_invoke$arity$2 = (function (g,start){\nreturn loom.alg_generic.dijkstra_span(loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),loom.graph.weight.cljs$core$IFn$_invoke$arity$1(g),start);\n});\n\nloom.alg.dijkstra_span.cljs$lang$maxFixedArity = 2;\n\n/**\n * Finds the shortest path from start to end. Returns a vector:\n *   [path distance]\n */\nloom.alg.dijkstra_path_dist = (function loom$alg$dijkstra_path_dist(g,start,end){\nreturn loom.alg_generic.dijkstra_path_dist(loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g),loom.graph.weight.cljs$core$IFn$_invoke$arity$1(g),start,end);\n});\n/**\n * Finds the shortest path from start to end\n */\nloom.alg.dijkstra_path = (function loom$alg$dijkstra_path(g,start,end){\nreturn cljs.core.first(loom.alg.dijkstra_path_dist(g,start,end));\n});\n/**\n * Tests for whether we can improve the shortest path to v found so far\n * by going through u.\n */\nloom.alg.can_relax_edge_QMARK_ = (function loom$alg$can_relax_edge_QMARK_(p__30127,weight,costs){\nvar vec__30128 = p__30127;\nvar u = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30128,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30128,(1),null);\nvar edge = vec__30128;\nvar vd = cljs.core.get.cljs$core$IFn$_invoke$arity$2(costs,v);\nvar ud = cljs.core.get.cljs$core$IFn$_invoke$arity$2(costs,u);\nvar sum = (ud + weight);\nreturn (vd > sum);\n});\n/**\n * If there's a shorter path from s to v via u,\n *  update our map of estimated path costs and\n * map of paths from source to vertex v\n */\nloom.alg.relax_edge = (function loom$alg$relax_edge(p__30140,weight,p__30141){\nvar vec__30142 = p__30140;\nvar u = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30142,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30142,(1),null);\nvar edge = vec__30142;\nvar vec__30145 = p__30141;\nvar costs = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30145,(0),null);\nvar paths = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30145,(1),null);\nvar estimates = vec__30145;\nvar ud = cljs.core.get.cljs$core$IFn$_invoke$arity$2(costs,u);\nvar sum = (ud + weight);\nif(loom.alg.can_relax_edge_QMARK_(edge,weight,costs)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(costs,v,sum),cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(paths,v,u)], null);\n} else {\nreturn estimates;\n}\n});\n/**\n * Performs edge relaxation on all edges in weighted directed graph\n */\nloom.alg.relax_edges = (function loom$alg$relax_edges(g,start,estimates){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (estimates__$1,p__30152){\nvar vec__30153 = p__30152;\nvar u = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30153,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30153,(1),null);\nvar edge = vec__30153;\nreturn loom.alg.relax_edge(edge,loom.graph.weight.cljs$core$IFn$_invoke$arity$3(g,u,v),estimates__$1);\n}),estimates,loom.graph.edges(g));\n});\n/**\n * Initializes path cost estimates and paths from source to all vertices,\n * for Bellman-Ford algorithm\n */\nloom.alg.init_estimates = (function loom$alg$init_estimates(graph,start){\nvar nodes = cljs.core.disj.cljs$core$IFn$_invoke$arity$2(loom.graph.nodes(graph),start);\nvar path_costs = cljs.core.PersistentArrayMap.createAsIfByAssoc([start,(0)]);\nvar paths = cljs.core.PersistentArrayMap.createAsIfByAssoc([start,null]);\nvar infinities = cljs.core.repeat.cljs$core$IFn$_invoke$arity$1(Infinity);\nvar nils = cljs.core.repeat.cljs$core$IFn$_invoke$arity$1(null);\nvar init_costs = cljs.core.interleave.cljs$core$IFn$_invoke$arity$2(nodes,infinities);\nvar init_paths = cljs.core.interleave.cljs$core$IFn$_invoke$arity$2(nodes,nils);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.assoc,path_costs,init_costs),cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.assoc,paths,init_paths)], null);\n});\n/**\n * Given a weighted, directed graph G = (V, E) with source start,\n * the Bellman-Ford algorithm produces map of single source shortest\n * paths and their costs if no negative-weight cycle that is reachable\n * from the source exists, and false otherwise, indicating that no\n * solution exists.\n */\nloom.alg.bellman_ford = (function loom$alg$bellman_ford(g,start){\nvar initial_estimates = loom.alg.init_estimates(g,start);\nvar vec__30157 = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (initial_estimates){\nreturn (function (estimates,_){\nreturn loom.alg.relax_edges(g,start,estimates);\n});})(initial_estimates))\n,initial_estimates,cljs.core.range.cljs$core$IFn$_invoke$arity$1((cljs.core.count(loom.graph.nodes(g)) - (1))));\nvar costs = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30157,(0),null);\nvar paths = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30157,(1),null);\nvar edges = loom.graph.edges(g);\nif(cljs.core.truth_(cljs.core.some(((function (initial_estimates,vec__30157,costs,paths,edges){\nreturn (function (p__30160){\nvar vec__30161 = p__30160;\nvar u = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30161,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30161,(1),null);\nvar edge = vec__30161;\nreturn loom.alg.can_relax_edge_QMARK_(edge,loom.graph.weight.cljs$core$IFn$_invoke$arity$3(g,u,v),costs);\n});})(initial_estimates,vec__30157,costs,paths,edges))\n,edges))){\nreturn false;\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [costs,cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (initial_estimates,vec__30157,costs,paths,edges){\nreturn (function (final_paths,v){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(final_paths,v,(function (){var node = v;\nvar path = cljs.core.List.EMPTY;\nwhile(true){\nif(cljs.core.truth_(node)){\nvar G__30670 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(paths,node);\nvar G__30671 = cljs.core.cons(node,path);\nnode = G__30670;\npath = G__30671;\ncontinue;\n} else {\nreturn path;\n}\nbreak;\n}\n})());\n});})(initial_estimates,vec__30157,costs,paths,edges))\n,cljs.core.PersistentArrayMap.EMPTY,cljs.core.remove.cljs$core$IFn$_invoke$arity$2(((function (initial_estimates,vec__30157,costs,paths,edges){\nreturn (function (p1__30156_SHARP_){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(Infinity,cljs.core.get.cljs$core$IFn$_invoke$arity$2(costs,p1__30156_SHARP_));\n});})(initial_estimates,vec__30157,costs,paths,edges))\n,cljs.core.keys(paths)))], null);\n}\n});\n/**\n * Returns true if g is a directed acyclic graph\n */\nloom.alg.dag_QMARK_ = (function loom$alg$dag_QMARK_(g){\nreturn cljs.core.boolean$(loom.alg.topsort.cljs$core$IFn$_invoke$arity$1(g));\n});\n/**\n * Finds the shortest path from start to end in graph g, using Dijkstra's\n *   algorithm if the graph is weighted, breadth-first search otherwise.\n */\nloom.alg.shortest_path = (function loom$alg$shortest_path(g,start,end){\nif(loom.graph.weighted_QMARK_(g)){\nreturn loom.alg.dijkstra_path(g,start,end);\n} else {\nreturn loom.alg.bf_path(g,start,end);\n}\n});\n/**\n * Finds the longest shortest path beginning at start, using Dijkstra's\n *   algorithm if the graph is weighted, breadth-first search otherwise.\n */\nloom.alg.longest_shortest_path = (function loom$alg$longest_shortest_path(g,start){\nreturn cljs.core.reverse(((loom.graph.weighted_QMARK_(g))?cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (path1,p__30166){\nvar vec__30167 = p__30166;\nvar n = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30167,(0),null);\nvar state = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30167,(1),null);\nvar path2 = loom.alg_generic.trace_path(cljs.core.comp.cljs$core$IFn$_invoke$arity$2(cljs.core.second,state),n);\nif((cljs.core.count(path1) < cljs.core.count(path2))){\nreturn path2;\n} else {\nreturn path1;\n}\n}),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [start], null),loom.alg.dijkstra_traverse.cljs$core$IFn$_invoke$arity$3(g,start,cljs.core.vector)):cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (path1,p__30170){\nvar vec__30171 = p__30170;\nvar n = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30171,(0),null);\nvar predmap = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30171,(1),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30171,(2),null);\nvar path2 = loom.alg_generic.trace_path(predmap,n);\nif((cljs.core.count(path1) < cljs.core.count(path2))){\nreturn path2;\n} else {\nreturn path1;\n}\n}),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [start], null),loom.alg.bf_traverse.cljs$core$IFn$_invoke$arity$variadic(g,start,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"f\",\"f\",-1597136552),cljs.core.vector], 0)))));\n});\n/**\n * Helper function for Johnson's algorithm. Uses Bellman-Ford to remove negative weights.\n */\nloom.alg.bellman_ford_transform = (function loom$alg$bellman_ford_transform(wg){\nvar q = cljs.core.first(cljs.core.drop_while.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(loom.graph.has_node_QMARK_,wg),cljs.core.repeatedly.cljs$core$IFn$_invoke$arity$1(cljs.core.gensym)));\nvar es = (function (){var iter__4523__auto__ = ((function (q){\nreturn (function loom$alg$bellman_ford_transform_$_iter__30174(s__30175){\nreturn (new cljs.core.LazySeq(null,((function (q){\nreturn (function (){\nvar s__30175__$1 = s__30175;\nwhile(true){\nvar temp__5720__auto__ = cljs.core.seq(s__30175__$1);\nif(temp__5720__auto__){\nvar s__30175__$2 = temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(s__30175__$2)){\nvar c__4521__auto__ = cljs.core.chunk_first(s__30175__$2);\nvar size__4522__auto__ = cljs.core.count(c__4521__auto__);\nvar b__30177 = cljs.core.chunk_buffer(size__4522__auto__);\nif((function (){var i__30176 = (0);\nwhile(true){\nif((i__30176 < size__4522__auto__)){\nvar v = cljs.core._nth.cljs$core$IFn$_invoke$arity$2(c__4521__auto__,i__30176);\ncljs.core.chunk_append(b__30177,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [q,v,(0)], null));\n\nvar G__30702 = (i__30176 + (1));\ni__30176 = G__30702;\ncontinue;\n} else {\nreturn true;\n}\nbreak;\n}\n})()){\nreturn cljs.core.chunk_cons(cljs.core.chunk(b__30177),loom$alg$bellman_ford_transform_$_iter__30174(cljs.core.chunk_rest(s__30175__$2)));\n} else {\nreturn cljs.core.chunk_cons(cljs.core.chunk(b__30177),null);\n}\n} else {\nvar v = cljs.core.first(s__30175__$2);\nreturn cljs.core.cons(new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [q,v,(0)], null),loom$alg$bellman_ford_transform_$_iter__30174(cljs.core.rest(s__30175__$2)));\n}\n} else {\nreturn null;\n}\nbreak;\n}\n});})(q))\n,null,null));\n});})(q))\n;\nreturn iter__4523__auto__(loom.graph.nodes(wg));\n})();\nvar bf_results = loom.alg.bellman_ford(loom.graph.add_edges_STAR_(wg,es),q);\nif(cljs.core.truth_(bf_results)){\nvar vec__30179 = bf_results;\nvar dist_q = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30179,(0),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30179,(1),null);\nvar new_es = cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.juxt.cljs$core$IFn$_invoke$arity$3(cljs.core.first,cljs.core.second,((function (vec__30179,dist_q,_,q,es,bf_results){\nreturn (function (p__30182){\nvar vec__30183 = p__30182;\nvar u = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30183,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30183,(1),null);\nreturn (loom.graph.weight.cljs$core$IFn$_invoke$arity$3(wg,u,v) + ((dist_q.cljs$core$IFn$_invoke$arity$1 ? dist_q.cljs$core$IFn$_invoke$arity$1(u) : dist_q.call(null,u)) - (dist_q.cljs$core$IFn$_invoke$arity$1 ? dist_q.cljs$core$IFn$_invoke$arity$1(v) : dist_q.call(null,v))));\n});})(vec__30179,dist_q,_,q,es,bf_results))\n),loom.graph.edges(wg));\nreturn loom.graph.add_edges_STAR_(wg,new_es);\n} else {\nreturn false;\n}\n});\n/**\n * Finds all-pairs shortest paths using Bellman-Ford to remove any negative edges before\n *   using Dijkstra's algorithm to find the shortest paths from each vertex to every other.\n *   This algorithm is efficient for sparse graphs.\n * \n *   If the graph is unweighted, a default weight of 1 will be used. Note that it is more efficient\n *   to use breadth-first spans for a graph with a uniform edge weight rather than Dijkstra's algorithm.\n *   Most callers should use shortest-paths and allow the most efficient implementation be selected\n *   for the graph.\n */\nloom.alg.johnson = (function loom$alg$johnson(g){\nvar g__$1 = (cljs.core.truth_((function (){var and__4120__auto__ = loom.graph.weighted_QMARK_(g);\nif(and__4120__auto__){\nreturn cljs.core.some(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(cljs.core._GT_,(0)),cljs.core.map.cljs$core$IFn$_invoke$arity$2(loom.graph.weight.cljs$core$IFn$_invoke$arity$1(g),loom.graph.edges(g)));\n} else {\nreturn and__4120__auto__;\n}\n})())?loom.alg.bellman_ford_transform(g):g);\nif(g__$1 === false){\nreturn false;\n} else {\nvar dist = ((loom.graph.weighted_QMARK_(g__$1))?loom.graph.weight.cljs$core$IFn$_invoke$arity$1(g__$1):((function (g__$1){\nreturn (function (u,v){\nif(cljs.core.truth_(loom.graph.has_edge_QMARK_(g__$1,u,v))){\nreturn (1);\n} else {\nreturn null;\n}\n});})(g__$1))\n);\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (dist,g__$1){\nreturn (function (acc,node){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(acc,node,loom.alg_generic.dijkstra_span(loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g__$1),dist,node));\n});})(dist,g__$1))\n,cljs.core.PersistentArrayMap.EMPTY,loom.graph.nodes(g__$1));\n}\n});\n/**\n * Uses bf-span on each node in the graph.\n */\nloom.alg.bf_all_pairs_shortest_paths = (function loom$alg$bf_all_pairs_shortest_paths(g){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (spans,node){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(spans,node,loom.alg.bf_span.cljs$core$IFn$_invoke$arity$2(g,node));\n}),cljs.core.PersistentArrayMap.EMPTY,loom.graph.nodes(g));\n});\n/**\n * Finds all-pairs shortest paths in a graph. Uses Johnson's algorithm for weighted graphs\n *   which is efficient for sparse graphs. Breadth-first spans are used for unweighted graphs.\n */\nloom.alg.all_pairs_shortest_paths = (function loom$alg$all_pairs_shortest_paths(g){\nif(loom.graph.weighted_QMARK_(g)){\nreturn loom.alg.johnson(g);\n} else {\nreturn loom.alg.bf_all_pairs_shortest_paths(g);\n}\n});\n/**\n * Returns the connected components of graph g as a vector of vectors. If g\n *   is directed, returns the weakly-connected components.\n */\nloom.alg.connected_components = (function loom$alg$connected_components(g){\nvar nb = (((!(loom.graph.directed_QMARK_(g))))?loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g):(function (p1__30187_SHARP_){\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2(loom.graph.successors.cljs$core$IFn$_invoke$arity$2(g,p1__30187_SHARP_),loom.graph.predecessors.cljs$core$IFn$_invoke$arity$2(g,p1__30187_SHARP_));\n}));\nreturn cljs.core.first(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (nb){\nreturn (function (p__30189,n){\nvar vec__30190 = p__30189;\nvar cc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30190,(0),null);\nvar predmap = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30190,(1),null);\nif(cljs.core.contains_QMARK_(predmap,n)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cc,predmap], null);\n} else {\nvar vec__30193 = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (vec__30190,cc,predmap,nb){\nreturn (function (p__30196,p__30197){\nvar vec__30198 = p__30196;\nvar c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30198,(0),null);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30198,(1),null);\nvar vec__30201 = p__30197;\nvar n__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30201,(0),null);\nvar pm = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30201,(1),null);\nvar ___$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30201,(2),null);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.conj.cljs$core$IFn$_invoke$arity$2(c,n__$1),pm], null);\n});})(vec__30190,cc,predmap,nb))\n,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentVector.EMPTY,null], null),loom.alg_generic.bf_traverse.cljs$core$IFn$_invoke$arity$variadic(nb,n,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"f\",\"f\",-1597136552),cljs.core.vector,new cljs.core.Keyword(null,\"seen\",\"seen\",-518999789),predmap], 0)));\nvar c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30193,(0),null);\nvar pm = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30193,(1),null);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cc,c),pm], null);\n}\n});})(nb))\n,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentVector.EMPTY,cljs.core.PersistentArrayMap.EMPTY], null),loom.graph.nodes(g)));\n});\n/**\n * Returns true if g is connected\n */\nloom.alg.connected_QMARK_ = (function loom$alg$connected_QMARK_(g){\nreturn (cljs.core.count(cljs.core.first(loom.alg.connected_components(g))) === cljs.core.count(loom.graph.nodes(g)));\n});\n/**\n * Returns the strongly-connected components of directed graph g as a vector of\n *   vectors. Uses Kosaraju's algorithm.\n */\nloom.alg.scc = (function loom$alg$scc(g){\nvar gt = loom.graph.transpose(g);\nvar stack = cljs.core.reverse(loom.alg.post_traverse.cljs$core$IFn$_invoke$arity$1(g));\nvar seen = cljs.core.PersistentHashSet.EMPTY;\nvar cc = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nwhile(true){\nif(cljs.core.empty_QMARK_(stack)){\nreturn cljs.core.persistent_BANG_(cc);\n} else {\nif(cljs.core.truth_((function (){var G__30209 = cljs.core.first(stack);\nreturn (seen.cljs$core$IFn$_invoke$arity$1 ? seen.cljs$core$IFn$_invoke$arity$1(G__30209) : seen.call(null,G__30209));\n})())){\nvar G__30740 = cljs.core.rest(stack);\nvar G__30741 = seen;\nvar G__30742 = cc;\nstack = G__30740;\nseen = G__30741;\ncc = G__30742;\ncontinue;\n} else {\nvar vec__30211 = loom.alg.post_traverse.cljs$core$IFn$_invoke$arity$variadic(gt,cljs.core.first(stack),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"seen\",\"seen\",-518999789),seen,new cljs.core.Keyword(null,\"return-seen\",\"return-seen\",308792727),true], 0));\nvar c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30211,(0),null);\nvar seen__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30211,(1),null);\nvar G__30743 = cljs.core.rest(stack);\nvar G__30744 = seen__$1;\nvar G__30745 = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(cc,c);\nstack = G__30743;\nseen = G__30744;\ncc = G__30745;\ncontinue;\n}\n}\nbreak;\n}\n});\nloom.alg.strongly_connected_QMARK_ = (function loom$alg$strongly_connected_QMARK_(g){\nreturn (cljs.core.count(cljs.core.first(loom.alg.scc(g))) === cljs.core.count(loom.graph.nodes(g)));\n});\n/**\n * Returns graph g with all connected components connected to each other\n */\nloom.alg.connect = (function loom$alg$connect(g){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(loom.graph.add_edges,g,cljs.core.partition.cljs$core$IFn$_invoke$arity$3((2),(1),cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.first,loom.alg.connected_components(g))));\n});\n/**\n * Return the density of graph g\n * @param {...*} var_args\n */\nloom.alg.density = (function loom$alg$density(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___30755 = arguments.length;\nvar i__4731__auto___30756 = (0);\nwhile(true){\nif((i__4731__auto___30756 < len__4730__auto___30755)){\nargs__4736__auto__.push((arguments[i__4731__auto___30756]));\n\nvar G__30757 = (i__4731__auto___30756 + (1));\ni__4731__auto___30756 = G__30757;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((1) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((1)),(0),null)):null);\nreturn loom.alg.density.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4737__auto__);\n});\n\nloom.alg.density.cljs$core$IFn$_invoke$arity$variadic = (function (g,p__30218){\nvar map__30219 = p__30218;\nvar map__30219__$1 = (((((!((map__30219 == null))))?(((((map__30219.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__30219.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__30219):map__30219);\nvar loops = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__30219__$1,new cljs.core.Keyword(null,\"loops\",\"loops\",-1766681555),false);\nvar order = cljs.core.count(loom.graph.nodes(g));\nreturn (cljs.core.count(loom.graph.edges(g)) / (order * (cljs.core.truth_(loops)?order:(order - (1)))));\n});\n\nloom.alg.density.cljs$lang$maxFixedArity = (1);\n\n/** @this {Function} */\nloom.alg.density.cljs$lang$applyTo = (function (seq30216){\nvar G__30217 = cljs.core.first(seq30216);\nvar seq30216__$1 = cljs.core.next(seq30216);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__30217,seq30216__$1);\n});\n\n/**\n * Returns nodes with no connections to other nodes (i.e., isolated nodes)\n */\nloom.alg.loners = (function loom$alg$loners(g){\nvar degree_total = ((loom.graph.directed_QMARK_(g))?(function (p1__30221_SHARP_){\nreturn (loom.graph.in_degree(g,p1__30221_SHARP_) + loom.graph.out_degree(g,p1__30221_SHARP_));\n}):(function (p1__30222_SHARP_){\nreturn loom.graph.out_degree(g,p1__30222_SHARP_);\n}));\nreturn cljs.core.filter.cljs$core$IFn$_invoke$arity$2(cljs.core.comp.cljs$core$IFn$_invoke$arity$2(cljs.core.zero_QMARK_,degree_total),loom.graph.nodes(g));\n});\n/**\n * Returns the distinct edges of g. Only useful for undirected graphs\n */\nloom.alg.distinct_edges = (function loom$alg$distinct_edges(g){\nif(loom.graph.directed_QMARK_(g)){\nreturn loom.graph.edges(g);\n} else {\nreturn cljs.core.second(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p__30223,e){\nvar vec__30224 = p__30223;\nvar seen = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30224,(0),null);\nvar es = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30224,(1),null);\nvar eset = cljs.core.set(cljs.core.take.cljs$core$IFn$_invoke$arity$2((2),e));\nif(cljs.core.truth_((seen.cljs$core$IFn$_invoke$arity$1 ? seen.cljs$core$IFn$_invoke$arity$1(eset) : seen.call(null,eset)))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [seen,es], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.conj.cljs$core$IFn$_invoke$arity$2(seen,eset),cljs.core.conj.cljs$core$IFn$_invoke$arity$2(es,e)], null);\n}\n}),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentHashSet.EMPTY,cljs.core.PersistentVector.EMPTY], null),loom.graph.edges(g)));\n}\n});\n/**\n * Attempts a two-coloring of graph g. When successful, returns a map of\n *   nodes to colors (1 or 0). Otherwise, returns nil.\n */\nloom.alg.bipartite_color = (function loom$alg$bipartite_color(g){\nvar color_component = (function loom$alg$bipartite_color_$_color_component(coloring,start){\nvar coloring__$1 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(coloring,start,(1));\nvar queue = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentQueue.EMPTY,start);\nwhile(true){\nif(cljs.core.empty_QMARK_(queue)){\nreturn coloring__$1;\n} else {\nvar v = cljs.core.peek(queue);\nvar color = ((1) - (coloring__$1.cljs$core$IFn$_invoke$arity$1 ? coloring__$1.cljs$core$IFn$_invoke$arity$1(v) : coloring__$1.call(null,v)));\nvar nbrs = loom.graph.successors.cljs$core$IFn$_invoke$arity$2(g,v);\nif(cljs.core.truth_(cljs.core.some(((function (coloring__$1,queue,v,color,nbrs){\nreturn (function (p1__30228_SHARP_){\nvar and__4120__auto__ = (coloring__$1.cljs$core$IFn$_invoke$arity$1 ? coloring__$1.cljs$core$IFn$_invoke$arity$1(p1__30228_SHARP_) : coloring__$1.call(null,p1__30228_SHARP_));\nif(cljs.core.truth_(and__4120__auto__)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((coloring__$1.cljs$core$IFn$_invoke$arity$1 ? coloring__$1.cljs$core$IFn$_invoke$arity$1(v) : coloring__$1.call(null,v)),(coloring__$1.cljs$core$IFn$_invoke$arity$1 ? coloring__$1.cljs$core$IFn$_invoke$arity$1(p1__30228_SHARP_) : coloring__$1.call(null,p1__30228_SHARP_)));\n} else {\nreturn and__4120__auto__;\n}\n});})(coloring__$1,queue,v,color,nbrs))\n,nbrs))){\nreturn null;\n} else {\nvar nbrs__$1 = cljs.core.remove.cljs$core$IFn$_invoke$arity$2(coloring__$1,nbrs);\nvar G__30858 = cljs.core.into.cljs$core$IFn$_invoke$arity$2(coloring__$1,(function (){var iter__4523__auto__ = ((function (coloring__$1,queue,nbrs__$1,v,color,nbrs){\nreturn (function loom$alg$bipartite_color_$_color_component_$_iter__30252(s__30253){\nreturn (new cljs.core.LazySeq(null,((function (coloring__$1,queue,nbrs__$1,v,color,nbrs){\nreturn (function (){\nvar s__30253__$1 = s__30253;\nwhile(true){\nvar temp__5720__auto__ = cljs.core.seq(s__30253__$1);\nif(temp__5720__auto__){\nvar s__30253__$2 = temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(s__30253__$2)){\nvar c__4521__auto__ = cljs.core.chunk_first(s__30253__$2);\nvar size__4522__auto__ = cljs.core.count(c__4521__auto__);\nvar b__30255 = cljs.core.chunk_buffer(size__4522__auto__);\nif((function (){var i__30254 = (0);\nwhile(true){\nif((i__30254 < size__4522__auto__)){\nvar nbr = cljs.core._nth.cljs$core$IFn$_invoke$arity$2(c__4521__auto__,i__30254);\ncljs.core.chunk_append(b__30255,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [nbr,color], null));\n\nvar G__30882 = (i__30254 + (1));\ni__30254 = G__30882;\ncontinue;\n} else {\nreturn true;\n}\nbreak;\n}\n})()){\nreturn cljs.core.chunk_cons(cljs.core.chunk(b__30255),loom$alg$bipartite_color_$_color_component_$_iter__30252(cljs.core.chunk_rest(s__30253__$2)));\n} else {\nreturn cljs.core.chunk_cons(cljs.core.chunk(b__30255),null);\n}\n} else {\nvar nbr = cljs.core.first(s__30253__$2);\nreturn cljs.core.cons(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [nbr,color], null),loom$alg$bipartite_color_$_color_component_$_iter__30252(cljs.core.rest(s__30253__$2)));\n}\n} else {\nreturn null;\n}\nbreak;\n}\n});})(coloring__$1,queue,nbrs__$1,v,color,nbrs))\n,null,null));\n});})(coloring__$1,queue,nbrs__$1,v,color,nbrs))\n;\nreturn iter__4523__auto__(nbrs__$1);\n})());\nvar G__30859 = cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.pop(queue),nbrs__$1);\ncoloring__$1 = G__30858;\nqueue = G__30859;\ncontinue;\n}\n}\nbreak;\n}\n});\nvar G__30267 = cljs.core.seq(loom.graph.nodes(g));\nvar vec__30268 = G__30267;\nvar seq__30269 = cljs.core.seq(vec__30268);\nvar first__30270 = cljs.core.first(seq__30269);\nvar seq__30269__$1 = cljs.core.next(seq__30269);\nvar node = first__30270;\nvar nodes = seq__30269__$1;\nvar coloring = cljs.core.PersistentArrayMap.EMPTY;\nvar G__30267__$1 = G__30267;\nvar coloring__$1 = coloring;\nwhile(true){\nvar vec__30280 = G__30267__$1;\nvar seq__30281 = cljs.core.seq(vec__30280);\nvar first__30282 = cljs.core.first(seq__30281);\nvar seq__30281__$1 = cljs.core.next(seq__30281);\nvar node__$1 = first__30282;\nvar nodes__$1 = seq__30281__$1;\nvar coloring__$2 = coloring__$1;\nif(cljs.core.truth_(coloring__$2)){\nif((node__$1 == null)){\nreturn coloring__$2;\n} else {\nif(cljs.core.truth_((coloring__$2.cljs$core$IFn$_invoke$arity$1 ? coloring__$2.cljs$core$IFn$_invoke$arity$1(node__$1) : coloring__$2.call(null,node__$1)))){\nvar G__30924 = nodes__$1;\nvar G__30925 = coloring__$2;\nG__30267__$1 = G__30924;\ncoloring__$1 = G__30925;\ncontinue;\n} else {\nvar G__30926 = nodes__$1;\nvar G__30927 = color_component(coloring__$2,node__$1);\nG__30267__$1 = G__30926;\ncoloring__$1 = G__30927;\ncontinue;\n}\n}\n} else {\nreturn null;\n}\nbreak;\n}\n});\n/**\n * Returns true if g is bipartite\n */\nloom.alg.bipartite_QMARK_ = (function loom$alg$bipartite_QMARK_(g){\nreturn cljs.core.boolean$(loom.alg.bipartite_color(g));\n});\n/**\n * Returns two sets of nodes, one for each color of the bipartite coloring,\n *   or nil if g is not bipartite\n */\nloom.alg.bipartite_sets = (function loom$alg$bipartite_sets(g){\nvar temp__5720__auto__ = loom.alg.bipartite_color(g);\nif(cljs.core.truth_(temp__5720__auto__)){\nvar coloring = temp__5720__auto__;\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (coloring,temp__5720__auto__){\nreturn (function (p__30299,p__30300){\nvar vec__30304 = p__30299;\nvar s1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30304,(0),null);\nvar s2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30304,(1),null);\nvar vec__30307 = p__30300;\nvar node = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30307,(0),null);\nvar color = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30307,(1),null);\nif((color === (0))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.conj.cljs$core$IFn$_invoke$arity$2(s1,node),s2], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [s1,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(s2,node)], null);\n}\n});})(coloring,temp__5720__auto__))\n,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentHashSet.EMPTY,cljs.core.PersistentHashSet.EMPTY], null),coloring);\n} else {\nreturn null;\n}\n});\n/**\n * Given a putative coloring of a graph, returns the colors of all the\n *   neighbors of a given node.\n */\nloom.alg.neighbor_colors = (function loom$alg$neighbor_colors(g,node,coloring){\nvar successors = loom.graph.successors.cljs$core$IFn$_invoke$arity$2(g,node);\nvar neighbors = (((!(loom.graph.directed_QMARK_(g))))?successors:cljs.core.concat.cljs$core$IFn$_invoke$arity$2(successors,loom.graph.predecessors.cljs$core$IFn$_invoke$arity$2(g,node)));\nreturn cljs.core.set(cljs.core.remove.cljs$core$IFn$_invoke$arity$2(cljs.core.nil_QMARK_,cljs.core.map.cljs$core$IFn$_invoke$arity$2(((function (successors,neighbors){\nreturn (function (p1__30311_SHARP_){\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(coloring,p1__30311_SHARP_);\n});})(successors,neighbors))\n,neighbors)));\n});\n/**\n * Returns true if a map of nodes to colors is a proper coloring of a graph.\n */\nloom.alg.coloring_QMARK_ = (function loom$alg$coloring_QMARK_(g,coloring){\nvar different_colors_QMARK_ = (function loom$alg$coloring_QMARK__$_different_colors_QMARK_(node){\nreturn (!(cljs.core.contains_QMARK_(loom.alg.neighbor_colors(g,node,coloring),(coloring.cljs$core$IFn$_invoke$arity$1 ? coloring.cljs$core$IFn$_invoke$arity$1(node) : coloring.call(null,node)))));\n});\nreturn ((cljs.core.every_QMARK_(different_colors_QMARK_,loom.graph.nodes(g))) && (cljs.core.every_QMARK_(cljs.core.complement(cljs.core.nil_QMARK_),cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__30322_SHARP_){\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(coloring,p1__30322_SHARP_);\n}),loom.graph.nodes(g)))));\n});\n/**\n * Greedily color the vertices of a graph using the first-fit heuristic.\n *   Returns a map of nodes to colors (0, 1, ...).\n */\nloom.alg.greedy_coloring = (function loom$alg$greedy_coloring(g){\nvar node_seq = loom.alg.bf_traverse.cljs$core$IFn$_invoke$arity$1(g);\nvar coloring = cljs.core.PersistentArrayMap.EMPTY;\nvar colors = cljs.core.PersistentHashSet.EMPTY;\nwhile(true){\nif(cljs.core.empty_QMARK_(node_seq)){\nreturn coloring;\n} else {\nvar node = cljs.core.first(node_seq);\nvar possible_colors = clojure.set.difference.cljs$core$IFn$_invoke$arity$2(colors,loom.alg.neighbor_colors(g,node,coloring));\nvar node_color = ((cljs.core.empty_QMARK_(possible_colors))?cljs.core.count(colors):cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.min,possible_colors));\nvar G__30979 = cljs.core.rest(node_seq);\nvar G__30980 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(coloring,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [node,node_color], null));\nvar G__30981 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(colors,node_color);\nnode_seq = G__30979;\ncoloring = G__30980;\ncolors = G__30981;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Returns [flow-map flow-value], where flow-map is a weighted adjacency map\n * representing the maximum flow.  The argument should be a weighted digraph,\n * where the edge weights are flow capacities.  Source and sink are the vertices\n * representing the flow source and sink vertices.  Optionally, pass in\n *   :method :algorithm to use.  Currently, the only option is :edmonds-karp .\n * @param {...*} var_args\n */\nloom.alg.max_flow = (function loom$alg$max_flow(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___30982 = arguments.length;\nvar i__4731__auto___30983 = (0);\nwhile(true){\nif((i__4731__auto___30983 < len__4730__auto___30982)){\nargs__4736__auto__.push((arguments[i__4731__auto___30983]));\n\nvar G__30984 = (i__4731__auto___30983 + (1));\ni__4731__auto___30983 = G__30984;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((3) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((3)),(0),null)):null);\nreturn loom.alg.max_flow.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__4737__auto__);\n});\n\nloom.alg.max_flow.cljs$core$IFn$_invoke$arity$variadic = (function (g,source,sink,p__30346){\nvar map__30347 = p__30346;\nvar map__30347__$1 = (((((!((map__30347 == null))))?(((((map__30347.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__30347.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__30347):map__30347);\nvar method = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__30347__$1,new cljs.core.Keyword(null,\"method\",\"method\",55703592),new cljs.core.Keyword(null,\"edmonds-karp\",\"edmonds-karp\",-1793813821));\nvar method_set = new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"edmonds-karp\",\"edmonds-karp\",-1793813821),null], null), null);\nvar n = loom.graph.successors.cljs$core$IFn$_invoke$arity$1(g);\nvar i = loom.graph.predecessors.cljs$core$IFn$_invoke$arity$1(g);\nvar c = loom.graph.weight.cljs$core$IFn$_invoke$arity$1(g);\nvar s = source;\nvar t = sink;\nvar vec__30351 = (function (){var G__30354 = method;\nvar G__30354__$1 = (((G__30354 instanceof cljs.core.Keyword))?G__30354.fqn:null);\nswitch (G__30354__$1) {\ncase \"edmonds-karp\":\nreturn loom.flow.edmonds_karp.cljs$core$IFn$_invoke$arity$5(n,i,c,s,t);\n\nbreak;\ndefault:\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2([\"Method not found.  Choose from: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(method_set)].join(''),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"method-set\",\"method-set\",-2030344221),method_set], null));\n\n}\n})();\nvar flow_map = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30351,(0),null);\nvar flow_value = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30351,(1),null);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [flow_map,flow_value], null);\n});\n\nloom.alg.max_flow.cljs$lang$maxFixedArity = (3);\n\n/** @this {Function} */\nloom.alg.max_flow.cljs$lang$applyTo = (function (seq30339){\nvar G__30340 = cljs.core.first(seq30339);\nvar seq30339__$1 = cljs.core.next(seq30339);\nvar G__30341 = cljs.core.first(seq30339__$1);\nvar seq30339__$2 = cljs.core.next(seq30339__$1);\nvar G__30342 = cljs.core.first(seq30339__$2);\nvar seq30339__$3 = cljs.core.next(seq30339__$2);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__30340,G__30341,G__30342,seq30339__$3);\n});\n\n/**\n * Wrapper function to return edges along with weights for a given graph.\n * For un-weighted graphs a default value of one is produced. The function\n * returns values of the form [[[u v] 10] [[x y] 20] ...]\n */\nloom.alg.edge_weights = (function loom$alg$edge_weights(wg,v){\nvar edge_weight = (function (u,v__$1){\nif(loom.graph.weighted_QMARK_(wg)){\nreturn loom.graph.weight.cljs$core$IFn$_invoke$arity$3(wg,u,v__$1);\n} else {\nreturn (1);\n}\n});\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(((function (edge_weight){\nreturn (function (p1__30365_SHARP_){\nreturn cljs.core.vec(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [p1__30365_SHARP_,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [v,edge_weight(v,p1__30365_SHARP_)], null)], null));\n});})(edge_weight))\n,loom.graph.successors.cljs$core$IFn$_invoke$arity$2(wg,v));\n});\n/**\n * An edge-list of an minimum spanning tree along with weights that\n *   represents an MST of the given graph. Returns the MST edge-list\n *   for un-weighted graphs.\n * @param {...*} var_args\n */\nloom.alg.prim_mst_edges = (function loom$alg$prim_mst_edges(var_args){\nvar G__30371 = arguments.length;\nswitch (G__30371) {\ncase 1:\nreturn loom.alg.prim_mst_edges.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 5:\nreturn loom.alg.prim_mst_edges.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nloom.alg.prim_mst_edges.cljs$core$IFn$_invoke$arity$1 = (function (wg){\nif(loom.graph.directed_QMARK_(wg)){\nthrow Error(\"Spanning tree only defined for undirected graphs\");\n} else {\nvar mst = loom.alg.prim_mst_edges.cljs$core$IFn$_invoke$arity$5(wg,loom.graph.nodes(wg),null,cljs.core.PersistentHashSet.EMPTY,cljs.core.PersistentVector.EMPTY);\nif(loom.graph.weighted_QMARK_(wg)){\nreturn mst;\n} else {\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(((function (mst){\nreturn (function (p1__30368_SHARP_){\nreturn cljs.core.vec(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(p1__30368_SHARP_),cljs.core.second(p1__30368_SHARP_)], null));\n});})(mst))\n,mst);\n}\n\n}\n});\n\nloom.alg.prim_mst_edges.cljs$core$IFn$_invoke$arity$5 = (function (wg,n,h,visited,acc){\nwhile(true){\nif(cljs.core.empty_QMARK_(n)){\nreturn acc;\n} else {\nif(cljs.core.empty_QMARK_(h)){\nvar v = cljs.core.first(n);\nvar h__$1 = cljs.core.into.cljs$core$IFn$_invoke$arity$2(tailrecursion.priority_map.priority_map_keyfn(cljs.core.second),loom.alg.edge_weights(wg,v));\nvar G__31028 = wg;\nvar G__31029 = cljs.core.disj.cljs$core$IFn$_invoke$arity$2(n,v);\nvar G__31030 = h__$1;\nvar G__31031 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(visited,v);\nvar G__31032 = acc;\nwg = G__31028;\nn = G__31029;\nh = G__31030;\nvisited = G__31031;\nacc = G__31032;\ncontinue;\n} else {\nvar next_edge = cljs.core.peek(h);\nvar u = cljs.core.first(cljs.core.second(next_edge));\nvar v = cljs.core.first(next_edge);\nvar update_dist = ((function (wg,n,h,visited,acc,next_edge,u,v){\nreturn (function (h__$1,p__30382){\nvar vec__30383 = p__30382;\nvar v__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30383,(0),null);\nvar vec__30386 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30383,(1),null);\nvar u__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30386,(0),null);\nvar wt = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30386,(1),null);\nif((cljs.core.get.cljs$core$IFn$_invoke$arity$2(h__$1,v__$1) == null)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(h__$1,v__$1,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [u__$1,wt], null));\n} else {\nif((cljs.core.second(cljs.core.get.cljs$core$IFn$_invoke$arity$2(h__$1,v__$1)) > wt)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(h__$1,v__$1,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [u__$1,wt], null));\n} else {\nreturn h__$1;\n\n}\n}\n});})(wg,n,h,visited,acc,next_edge,u,v))\n;\nvar wt = cljs.core.second(cljs.core.second(next_edge));\nvar visited__$1 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(visited,v);\nvar h__$1 = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(update_dist,cljs.core.pop(h),cljs.core.filter.cljs$core$IFn$_invoke$arity$2(((function (wg,n,h,visited,acc,wt,visited__$1,next_edge,u,v,update_dist){\nreturn (function (p1__30369_SHARP_){\nvar G__30390 = cljs.core.first(p1__30369_SHARP_);\nvar fexpr__30389 = cljs.core.complement(visited__$1);\nreturn (fexpr__30389.cljs$core$IFn$_invoke$arity$1 ? fexpr__30389.cljs$core$IFn$_invoke$arity$1(G__30390) : fexpr__30389.call(null,G__30390));\n});})(wg,n,h,visited,acc,wt,visited__$1,next_edge,u,v,update_dist))\n,loom.alg.edge_weights(wg,v)));\nvar G__31044 = wg;\nvar G__31045 = cljs.core.disj.cljs$core$IFn$_invoke$arity$2(n,v);\nvar G__31046 = h__$1;\nvar G__31047 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(visited__$1,v);\nvar G__31048 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(acc,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [u,v,wt], null));\nwg = G__31044;\nn = G__31045;\nh = G__31046;\nvisited = G__31047;\nacc = G__31048;\ncontinue;\n\n}\n}\nbreak;\n}\n});\n\nloom.alg.prim_mst_edges.cljs$lang$maxFixedArity = 5;\n\n/**\n * Minimum spanning tree of given graph. If the graph contains more than one\n * component then returns a spanning forest of minimum spanning trees.\n */\nloom.alg.prim_mst = (function loom$alg$prim_mst(wg){\nvar mst = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(loom.graph.weighted_graph,loom.alg.prim_mst_edges.cljs$core$IFn$_invoke$arity$1(wg));\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((function (){var fexpr__30396 = cljs.core.comp.cljs$core$IFn$_invoke$arity$2(cljs.core.count,loom.graph.nodes);\nreturn (fexpr__30396.cljs$core$IFn$_invoke$arity$1 ? fexpr__30396.cljs$core$IFn$_invoke$arity$1(wg) : fexpr__30396.call(null,wg));\n})(),(function (){var fexpr__30397 = cljs.core.comp.cljs$core$IFn$_invoke$arity$2(cljs.core.count,loom.graph.nodes);\nreturn (fexpr__30397.cljs$core$IFn$_invoke$arity$1 ? fexpr__30397.cljs$core$IFn$_invoke$arity$1(mst) : fexpr__30397.call(null,mst));\n})())){\nreturn mst;\n} else {\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(loom.graph.add_nodes,mst,cljs.core.filter.cljs$core$IFn$_invoke$arity$2(((function (mst){\nreturn (function (p1__30391_SHARP_){\nreturn (loom.graph.out_degree(wg,p1__30391_SHARP_) === (0));\n});})(mst))\n,loom.graph.nodes(wg)));\n\n}\n});\n/**\n * Returns the shortest path using A* algorithm. Returns a map of predecessors.\n * @param {...*} var_args\n */\nloom.alg.astar_path = (function loom$alg$astar_path(var_args){\nvar G__30399 = arguments.length;\nswitch (G__30399) {\ncase 4:\nreturn loom.alg.astar_path.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 6:\nreturn loom.alg.astar_path.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nloom.alg.astar_path.cljs$core$IFn$_invoke$arity$4 = (function (g,src,target,heur){\nvar heur__$1 = (((heur == null))?(function (x,y){\nreturn (0);\n}):heur);\nvar q = tailrecursion.priority_map.priority_map_keyfn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.first,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([src,new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [(0),null,(0),(0)], null)], 0));\nvar explored = cljs.core.PersistentHashMap.EMPTY;\nreturn loom.alg.astar_path.cljs$core$IFn$_invoke$arity$6(g,src,target,heur__$1,q,explored);\n});\n\nloom.alg.astar_path.cljs$core$IFn$_invoke$arity$6 = (function (g,src,target,heur,q,explored){\nwhile(true){\nif(cljs.core.empty_QMARK_(q)){\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"Target not reachable from source\",cljs.core.PersistentArrayMap.EMPTY);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.first(cljs.core.peek(q)),target)){\nvar u = cljs.core.first(cljs.core.peek(q));\nvar parent = (function (){var fexpr__30418 = cljs.core.second(cljs.core.peek(q));\nreturn (fexpr__30418.cljs$core$IFn$_invoke$arity$1 ? fexpr__30418.cljs$core$IFn$_invoke$arity$1((1)) : fexpr__30418.call(null,(1)));\n})();\nvar explored__$1 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(explored,target,parent);\nvar path = (function (){var s = target;\nvar acc = cljs.core.PersistentArrayMap.EMPTY;\nwhile(true){\nif((s == null)){\nreturn acc;\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(s,src)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(acc,s,null);\n} else {\nvar G__31066 = (explored__$1.cljs$core$IFn$_invoke$arity$1 ? explored__$1.cljs$core$IFn$_invoke$arity$1(s) : explored__$1.call(null,s));\nvar G__31067 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(acc,s,(explored__$1.cljs$core$IFn$_invoke$arity$1 ? explored__$1.cljs$core$IFn$_invoke$arity$1(s) : explored__$1.call(null,s)));\ns = G__31066;\nacc = G__31067;\ncontinue;\n\n}\n}\nbreak;\n}\n})();\nreturn path;\n} else {\nvar curr_node = cljs.core.first(cljs.core.peek(q));\nvar curr_dist = (function (){var fexpr__30424 = cljs.core.second(cljs.core.peek(q));\nreturn (fexpr__30424.cljs$core$IFn$_invoke$arity$1 ? fexpr__30424.cljs$core$IFn$_invoke$arity$1((2)) : fexpr__30424.call(null,(2)));\n})();\nvar explored__$1 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(explored,curr_node,(function (){var fexpr__30425 = cljs.core.second(cljs.core.peek(q));\nreturn (fexpr__30425.cljs$core$IFn$_invoke$arity$1 ? fexpr__30425.cljs$core$IFn$_invoke$arity$1((1)) : fexpr__30425.call(null,(1)));\n})());\nvar nbrs = cljs.core.remove.cljs$core$IFn$_invoke$arity$2(cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentHashSet.EMPTY,cljs.core.keys(explored__$1)),loom.graph.successors.cljs$core$IFn$_invoke$arity$2(g,curr_node));\nvar update_dist = ((function (g,src,target,heur,q,explored,curr_node,curr_dist,explored__$1,nbrs){\nreturn (function (curr_node__$1,curr_dist__$1,q__$1,v){\nvar act = (curr_dist__$1 + ((loom.graph.weighted_QMARK_(g))?loom.graph.weight.cljs$core$IFn$_invoke$arity$3(g,curr_node__$1,v):(1)));\nvar est = (((cljs.core.get.cljs$core$IFn$_invoke$arity$2(q__$1,v) == null))?(heur.cljs$core$IFn$_invoke$arity$2 ? heur.cljs$core$IFn$_invoke$arity$2(v,target) : heur.call(null,v,target)):(function (){var fexpr__30431 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(q__$1,v);\nreturn (fexpr__30431.cljs$core$IFn$_invoke$arity$1 ? fexpr__30431.cljs$core$IFn$_invoke$arity$1((3)) : fexpr__30431.call(null,(3)));\n})());\nif((((cljs.core.get.cljs$core$IFn$_invoke$arity$2(q__$1,v) == null)) || (((function (){var fexpr__30434 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(q__$1,v);\nreturn (fexpr__30434.cljs$core$IFn$_invoke$arity$1 ? fexpr__30434.cljs$core$IFn$_invoke$arity$1((2)) : fexpr__30434.call(null,(2)));\n})() > act)))){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(q__$1,v,new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [(act + est),curr_node__$1,act,est], null));\n} else {\nreturn q__$1;\n\n}\n});})(g,src,target,heur,q,explored,curr_node,curr_dist,explored__$1,nbrs))\n;\nvar q__$1 = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.partial.cljs$core$IFn$_invoke$arity$3(update_dist,curr_node,curr_dist),cljs.core.pop(q),nbrs);\nvar G__31069 = g;\nvar G__31070 = src;\nvar G__31071 = target;\nvar G__31072 = heur;\nvar G__31073 = q__$1;\nvar G__31074 = explored__$1;\ng = G__31069;\nsrc = G__31070;\ntarget = G__31071;\nheur = G__31072;\nq = G__31073;\nexplored = G__31074;\ncontinue;\n\n}\n}\nbreak;\n}\n});\n\nloom.alg.astar_path.cljs$lang$maxFixedArity = 6;\n\n/**\n * Returns the length of the shortest path between src and target using\n *  the A* algorithm\n */\nloom.alg.astar_dist = (function loom$alg$astar_dist(g,src,target,heur){\nvar path = loom.alg.astar_path.cljs$core$IFn$_invoke$arity$4(g,src,target,heur);\nvar dist = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (path){\nreturn (function (c,p__30436){\nvar vec__30437 = p__30436;\nvar u = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30437,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30437,(1),null);\nif((v == null)){\nreturn c;\n} else {\nreturn (c + ((loom.graph.weighted_QMARK_(g))?loom.graph.weight.cljs$core$IFn$_invoke$arity$3(g,v,u):(1)));\n}\n});})(path))\n,(0),path);\nreturn dist;\n});\n/**\n * Returns sequence of vertices in degeneracy order.\n */\nloom.alg.degeneracy_ordering = (function loom$alg$degeneracy_ordering(g){\nvar ordered_nodes = cljs.core.PersistentVector.EMPTY;\nvar node_degs = cljs.core.into.cljs$core$IFn$_invoke$arity$2(tailrecursion.priority_map.priority_map(),cljs.core.zipmap(loom.graph.nodes(g),cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(loom.graph.out_degree,g),loom.graph.nodes(g))));\nvar k = (0);\nwhile(true){\nif(cljs.core.empty_QMARK_(node_degs)){\nreturn ordered_nodes;\n} else {\nvar vec__30456 = cljs.core.first(node_degs);\nvar n = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30456,(0),null);\nvar deg = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30456,(1),null);\nvar updated_degs = cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.juxt.cljs$core$IFn$_invoke$arity$2(cljs.core.first,cljs.core.comp.cljs$core$IFn$_invoke$arity$2(cljs.core.dec,cljs.core.second)),cljs.core.filter.cljs$core$IFn$_invoke$arity$2(cljs.core.second,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.juxt.cljs$core$IFn$_invoke$arity$2(cljs.core.identity,node_degs),loom.graph.successors.cljs$core$IFn$_invoke$arity$2(g,n)))));\nvar G__31082 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(ordered_nodes,n);\nvar G__31083 = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (ordered_nodes,node_degs,k,vec__30456,n,deg,updated_degs){\nreturn (function (n_ds,p__30459){\nvar vec__30460 = p__30459;\nvar n__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30460,(0),null);\nvar d = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30460,(1),null);\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(n_ds,n__$1,d);\n});})(ordered_nodes,node_degs,k,vec__30456,n,deg,updated_degs))\n,cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(node_degs,n),updated_degs);\nvar G__31084 = (function (){var x__4219__auto__ = k;\nvar y__4220__auto__ = deg;\nreturn ((x__4219__auto__ > y__4220__auto__) ? x__4219__auto__ : y__4220__auto__);\n})();\nordered_nodes = G__31082;\nnode_degs = G__31083;\nk = G__31084;\ncontinue;\n}\nbreak;\n}\n});\nloom.alg.bk_gen = (function loom$alg$bk_gen(g,p__30463,stack){\nvar vec__30465 = p__30463;\nvar r = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30465,(0),null);\nvar p = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30465,(1),null);\nvar x = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30465,(2),null);\nvar v_pivot = cljs.core.reduce.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(cljs.core.max_key,cljs.core.partial.cljs$core$IFn$_invoke$arity$2(loom.graph.out_degree,g)),p);\nvar v = v_pivot;\nvar p__$1 = cljs.core.set(p);\nvar x__$1 = cljs.core.set(x);\nvar stack__$1 = stack;\nwhile(true){\nif((v == null)){\nreturn stack__$1;\n} else {\nvar succ_v = cljs.core.set(loom.graph.successors.cljs$core$IFn$_invoke$arity$2(g,v));\nvar G__31087 = cljs.core.first(clojure.set.difference.cljs$core$IFn$_invoke$arity$2(cljs.core.disj.cljs$core$IFn$_invoke$arity$2(p__$1,v),cljs.core.set(loom.graph.successors.cljs$core$IFn$_invoke$arity$2(g,v_pivot))));\nvar G__31088 = cljs.core.disj.cljs$core$IFn$_invoke$arity$2(p__$1,v);\nvar G__31089 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(x__$1,v);\nvar G__31090 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(stack__$1,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.conj.cljs$core$IFn$_invoke$arity$2(r,v),clojure.set.intersection.cljs$core$IFn$_invoke$arity$2(p__$1,succ_v),clojure.set.intersection.cljs$core$IFn$_invoke$arity$2(x__$1,succ_v)], null));\nv = G__31087;\np__$1 = G__31088;\nx__$1 = G__31089;\nstack__$1 = G__31090;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * An iterative implementation of Bron-Kerbosch using degeneracy ordering\n *   at the outer loop and max-degree vertex pivoting in the inner loop.\n */\nloom.alg.bk = (function loom$alg$bk(g){\nvar vs = loom.alg.degeneracy_ordering(g);\nvar max_clqs = cljs.core.seq(cljs.core.PersistentVector.EMPTY);\nvar p = cljs.core.set(loom.graph.nodes(g));\nvar x = cljs.core.PersistentHashSet.EMPTY;\nvar stack = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(((cljs.core.empty_QMARK_(stack)) && (cljs.core.empty_QMARK_(vs)))){\nreturn max_clqs;\n} else {\nif(cljs.core.empty_QMARK_(stack)){\nvar v = cljs.core.first(vs);\nvar succ_v = cljs.core.set(loom.graph.successors.cljs$core$IFn$_invoke$arity$2(g,v));\nvar G__31094 = cljs.core.rest(vs);\nvar G__31095 = max_clqs;\nvar G__31096 = cljs.core.disj.cljs$core$IFn$_invoke$arity$2(p,v);\nvar G__31097 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(x,v);\nvar G__31098 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.PersistentHashSet.createAsIfByAssoc([v]),clojure.set.intersection.cljs$core$IFn$_invoke$arity$2(p,succ_v),clojure.set.intersection.cljs$core$IFn$_invoke$arity$2(x,succ_v)], null)], null);\nvs = G__31094;\nmax_clqs = G__31095;\np = G__31096;\nx = G__31097;\nstack = G__31098;\ncontinue;\n} else {\nvar vec__30491 = cljs.core.peek(stack);\nvar r = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30491,(0),null);\nvar s_p = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30491,(1),null);\nvar s_x = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30491,(2),null);\nif(((cljs.core.empty_QMARK_(s_p)) && (cljs.core.empty_QMARK_(s_x)))){\nvar G__31103 = vs;\nvar G__31104 = cljs.core.cons(r,max_clqs);\nvar G__31105 = p;\nvar G__31106 = x;\nvar G__31107 = cljs.core.pop(stack);\nvs = G__31103;\nmax_clqs = G__31104;\np = G__31105;\nx = G__31106;\nstack = G__31107;\ncontinue;\n} else {\nif(cljs.core.empty_QMARK_(s_p)){\nvar G__31109 = vs;\nvar G__31110 = max_clqs;\nvar G__31111 = p;\nvar G__31112 = x;\nvar G__31113 = cljs.core.pop(stack);\nvs = G__31109;\nmax_clqs = G__31110;\np = G__31111;\nx = G__31112;\nstack = G__31113;\ncontinue;\n} else {\nvar G__31116 = vs;\nvar G__31117 = max_clqs;\nvar G__31118 = p;\nvar G__31119 = x;\nvar G__31120 = loom.alg.bk_gen(g,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [r,s_p,s_x], null),cljs.core.pop(stack));\nvs = G__31116;\nmax_clqs = G__31117;\np = G__31118;\nx = G__31119;\nstack = G__31120;\ncontinue;\n\n}\n}\n\n}\n}\nbreak;\n}\n});\n/**\n * Enumerate the maximal cliques using Bron-Kerbosch.\n */\nloom.alg.maximal_cliques = (function loom$alg$maximal_cliques(g){\nreturn loom.alg.bk(g);\n});\n/**\n * Returns true iff g1 is a subgraph of g2. An undirected graph is never\n *   considered as a subgraph of a directed graph and vice versa.\n */\nloom.alg.subgraph_QMARK_ = (function loom$alg$subgraph_QMARK_(g1,g2){\nvar and__4120__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(loom.graph.directed_QMARK_(g1),loom.graph.directed_QMARK_(g2));\nif(and__4120__auto__){\nvar edge_test_fn = ((loom.graph.directed_QMARK_(g1))?loom.graph.has_edge_QMARK_:((function (and__4120__auto__){\nreturn (function (g,x,y){\nvar or__4131__auto__ = loom.graph.has_edge_QMARK_(g,x,y);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn loom.graph.has_edge_QMARK_(g,y,x);\n}\n});})(and__4120__auto__))\n);\nreturn ((cljs.core.every_QMARK_(((function (edge_test_fn,and__4120__auto__){\nreturn (function (p1__30496_SHARP_){\nreturn loom.graph.has_node_QMARK_(g2,p1__30496_SHARP_);\n});})(edge_test_fn,and__4120__auto__))\n,loom.graph.nodes(g1))) && (cljs.core.every_QMARK_(((function (edge_test_fn,and__4120__auto__){\nreturn (function (p__30534){\nvar vec__30535 = p__30534;\nvar x = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30535,(0),null);\nvar y = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30535,(1),null);\nreturn (edge_test_fn.cljs$core$IFn$_invoke$arity$3 ? edge_test_fn.cljs$core$IFn$_invoke$arity$3(g2,x,y) : edge_test_fn.call(null,g2,x,y));\n});})(edge_test_fn,and__4120__auto__))\n,loom.graph.edges(g1))));\n} else {\nreturn and__4120__auto__;\n}\n});\n/**\n * Returns true iff g1 is a subgraph of g2 and g2 is a subgraph of g1\n */\nloom.alg.eql_QMARK_ = (function loom$alg$eql_QMARK_(g1,g2){\nreturn ((loom.alg.subgraph_QMARK_(g1,g2)) && (loom.alg.subgraph_QMARK_(g2,g1)));\n});\n/**\n * Given a mapping phi between the vertices of two graphs, determine\n *   if the mapping is an isomorphism, e.g., {(phi x), (phi y)} connected\n *   in g2 iff {x, y} are connected in g1.\n */\nloom.alg.isomorphism_QMARK_ = (function loom$alg$isomorphism_QMARK_(g1,g2,phi){\nreturn loom.alg.eql_QMARK_(g2,loom.graph.add_edges_STAR_(loom.graph.add_nodes_STAR_(((loom.graph.directed_QMARK_(g1))?loom.graph.digraph():loom.graph.graph()),cljs.core.map.cljs$core$IFn$_invoke$arity$2(phi,loom.graph.nodes(g1))),cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p__30542){\nvar vec__30543 = p__30542;\nvar x = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30543,(0),null);\nvar y = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__30543,(1),null);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(phi.cljs$core$IFn$_invoke$arity$1 ? phi.cljs$core$IFn$_invoke$arity$1(x) : phi.call(null,x)),(phi.cljs$core$IFn$_invoke$arity$1 ? phi.cljs$core$IFn$_invoke$arity$1(y) : phi.call(null,y))], null);\n}),loom.graph.edges(g1))));\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","loom/alg.cljc","~:line",5,"~:column",3,"~:end-line",5,"~:end-column",11,"~:doc","Graph algorithms. Any graph record/type that satisfies the\nGraph, Digraph, or WeightedGraph protocols (as appropriate per algorithm)\ncan use these functions.","~:author","Justin Kramer"],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$create-react-class","~$module$node_modules$create_react_class$index","~$react-dom","~$module$node_modules$react_dom$index","~$clojure.spec.alpha","~$cljs.spec.alpha"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$loom.alg","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$cljs.core","^Q","~$loom.alg-generic","^R","~$loom.graph","^S","~$goog","^T","~$clj.set","~$clojure.set","~$gen","^R","~$flow","~$loom.flow","~$tailrecursion.priority-map","^Z","^V","^V","^Y","^Y","~$pm","^Z","~$graph","^S"],"~:seen",["^J",["~:require"]],"~:uses",["^ ","~$directed?","^S","~$weighted?","^S","~$edges","^S","~$add-nodes","^S","~$add-edges","^S","~$out-degree","^S","~$trace-path","^R","~$preds->span","^R","~$successors","^S","~$transpose","^S","~$predecessors","^S","~$in-degree","^S","~$weight","^S","~$nodes","^S","^10","^S","~$digraph","^S"],"~:require-macros",["^ ","^Q","^Q"],"~:form",["~#list",["~$ns","^L",["^1E",["^12",["^R","~:as","^W"],["^Y","^1G","^X"],["^S","~:refer",["^17","^18","^1A","^16","^1<","^1@","^1>","^19","^1?","^15","^14","^10","^1B","^1="],"^1G","^10"],["^R","^1H",["^1:","^1;"]],["^Z","^1G","^["],["^V","^1G","^U"]]]]],"~:flags",["^ ","^12",["^J",[]]],"~:js-deps",["^ "],"~:deps",["^T","^Q","^R","^Y","^S","^Z","^V"]],"^N","^L","~:resource-id",["~:shadow.build.classpath/resource","loom/alg.cljc"],"~:compiled-at",1560578451168,"~:resource-name","loom/alg.cljc","~:warnings",[],"~:source","(ns ^{:doc \"Graph algorithms. Any graph record/type that satisfies the\nGraph, Digraph, or WeightedGraph protocols (as appropriate per algorithm)\ncan use these functions.\"\n      :author \"Justin Kramer\"}\n  loom.alg\n  (:require [loom.alg-generic :as gen]\n            [loom.flow :as flow]\n            [loom.graph\n             :refer [add-nodes add-edges nodes edges successors weight predecessors\n                     out-degree in-degree weighted? directed? graph digraph transpose]\n             :as graph]\n            [loom.alg-generic :refer [trace-path preds->span]]\n            #?(:clj [clojure.data.priority-map :as pm]\n               :cljs [tailrecursion.priority-map :as pm])\n            [clojure.set :as clj.set]))\n\n;;;\n;;; Convenience wrappers for loom.alg-generic functions\n;;;\n(defn- traverse-all\n  [nodes traverse]\n  (persistent! (second\n   (reduce\n    (fn [[seen trav] n]\n      (if (seen n)\n        [seen trav]\n        (let [ctrav (traverse n :seen seen)]\n          [(into seen ctrav) (reduce conj! trav ctrav)])))\n    [#{} (transient [])]\n    nodes))))\n\n(defn pre-traverse\n  \"Traverses graph g depth-first from start. Returns a lazy seq of nodes.\n  When no starting node is provided, traverses the entire graph, connected\n  or not.\"\n  ([g]\n     (traverse-all (nodes g) (partial gen/pre-traverse (graph/successors g))))\n  ([g start]\n     (gen/pre-traverse (graph/successors g) start)))\n\n(defn pre-span\n  \"Returns a depth-first spanning tree of the form {node [successors]}\"\n  ([g]\n     (second\n      (reduce\n       (fn [[seen span] n]\n         (if (seen n)\n           [seen span]\n           (let [[cspan seen] (gen/pre-span\n                               (graph/successors g)\n                               n :seen seen :return-seen true)]\n             [seen (merge span {n []} cspan)])))\n       [#{} {}]\n       (nodes g))))\n  ([g start]\n     (gen/pre-span (graph/successors g) start)))\n\n(defn post-traverse\n  \"Traverses graph g depth-first, post-order from start. Returns a\n  vector of the nodes.\"\n  ([g]\n     (traverse-all (nodes g) (partial gen/post-traverse (graph/successors g))))\n  ([g start & opts]\n     (apply gen/post-traverse (graph/successors g) start opts)))\n\n(defn topsort\n  \"Topological sort of a directed acyclic graph (DAG). Returns nil if\n  g contains any cycles.\"\n  ([g]\n     (loop [seen #{}\n            result ()\n            [n & ns] (seq (nodes g))]\n       (if-not n\n         result\n         (if (seen n)\n           (recur seen result ns)\n           (when-let [cresult (gen/topsort-component\n                               (graph/successors g) n seen seen)]\n             (recur (into seen cresult) (concat cresult result) ns))))))\n  ([g start]\n     (gen/topsort-component (graph/successors g) start)))\n\n(defn bf-traverse\n  \"Traverses graph g breadth-first from start. When option :f is provided,\n  returns a lazy seq of (f node predecessor-map depth) for each node traversed.\n  Otherwise, returns a lazy seq of the nodes. When option :when is provided,\n  filters successors with (f neighbor predecessor depth).\"\n  ([g]\n     (first\n      (reduce\n       (fn [[cc predmap] n]\n         (if (contains? predmap n)\n           [cc predmap]\n           (reduce\n            (fn [[cc _] [n pm _]]\n              [(conj cc n) pm])\n            [cc predmap]\n            (gen/bf-traverse (graph/successors g) n :f vector :seen predmap))))\n       [[] {}]\n       (nodes g))))\n  ([g start]\n     (gen/bf-traverse (graph/successors g) start))\n  ([g start & opts]\n     (apply gen/bf-traverse (graph/successors g) start opts)))\n\n(defn bf-span\n  \"Returns a breadth-first spanning tree of the form {node [successors]}\"\n  ([g]\n     (preds->span\n      (reduce\n       (fn [predmap n]\n         (if (contains? predmap n)\n           predmap\n           (last (gen/bf-traverse (graph/successors g) n\n                                  :f (fn [_ pm _] pm)\n                                  :seen predmap))))\n       {}\n       (nodes g))))\n  ([g start]\n     (gen/bf-span (graph/successors g) start)))\n\n(defn bf-path\n  \"Returns a path from start to end with the fewest hops (i.e. irrespective\n  of edge weights)\"\n  [g start end & opts]\n  (apply gen/bf-path (graph/successors g) start end opts))\n\n(defn bf-path-bi\n  \"Using a bidirectional breadth-first search, finds a path from start to\n  end with the fewest hops (i.e. irrespective of edge weights). Can be much\n  faster than a unidirectional search on certain types of graphs\"\n  [g start end]\n  (if (directed? g)\n    (gen/bf-path-bi (graph/successors g) (predecessors g) start end)\n    (gen/bf-path-bi (graph/successors g) (graph/successors g) start end)))\n\n(defn dijkstra-traverse\n  \"Returns a lazy-seq of [current-node state] where state is a map in\n  the format {node [distance predecessor]}. When f is provided,\n  returns a lazy-seq of (f node state) for each node\"\n  ([g]\n     (gen/dijkstra-traverse\n      (graph/successors g) (graph/weight g) (first (nodes g))))\n  ([g start]\n     (gen/dijkstra-traverse (graph/successors g) (graph/weight g) start vector))\n  ([g start f]\n     (gen/dijkstra-traverse (graph/successors g) (graph/weight g) start f)))\n\n(defn dijkstra-span\n  \"Finds all shortest distances from start. Returns a map in the\n  format {node {successor distance}}\"\n  ([g]\n     (gen/dijkstra-span\n      (graph/successors g) (graph/weight g) (first (nodes g))))\n  ([g start]\n     (gen/dijkstra-span (graph/successors g) (graph/weight g) start)))\n\n(defn dijkstra-path-dist\n  \"Finds the shortest path from start to end. Returns a vector:\n  [path distance]\"\n  [g start end]\n  (gen/dijkstra-path-dist (graph/successors g) (graph/weight g) start end))\n\n(defn dijkstra-path\n  \"Finds the shortest path from start to end\"\n  [g start end]\n  (first (dijkstra-path-dist g start end)))\n\n(defn- can-relax-edge?\n  \"Tests for whether we can improve the shortest path to v found so far\n   by going through u.\"\n  [[u v :as edge] weight costs]\n  (let [vd (get costs v)\n        ud (get costs u)\n        sum (+ ud weight)]\n    (> vd sum)))\n\n(defn- relax-edge\n  \"If there's a shorter path from s to v via u,\n    update our map of estimated path costs and\n   map of paths from source to vertex v\"\n  [[u v :as edge] weight [costs paths :as estimates]]\n  (let [ud (get costs u)\n        sum (+ ud weight)]\n    (if (can-relax-edge? edge weight costs)\n      [(assoc costs v sum) (assoc paths v u)]\n      estimates)))\n\n(defn- relax-edges\n  \"Performs edge relaxation on all edges in weighted directed graph\"\n  [g start estimates]\n  (->> (edges g)\n       (reduce (fn [estimates [u v :as edge]]\n                 (relax-edge edge (graph/weight g u v) estimates))\n               estimates)))\n\n(defn- init-estimates\n  \"Initializes path cost estimates and paths from source to all vertices,\n   for Bellman-Ford algorithm\"\n  [graph start]\n  (let [nodes (disj (nodes graph) start)\n        path-costs {start 0}\n        paths {start nil}\n        infinities (repeat #?(:clj Double/POSITIVE_INFINITY\n                              :cljs js/Infinity))\n        nils (repeat nil)\n        init-costs (interleave nodes infinities)\n        init-paths (interleave nodes nils)]\n    [(apply assoc path-costs init-costs)\n     (apply assoc paths init-paths)]))\n\n\n;;;\n;;; Graph algorithms\n;;;\n\n(defn bellman-ford\n  \"Given a weighted, directed graph G = (V, E) with source start,\n   the Bellman-Ford algorithm produces map of single source shortest\n   paths and their costs if no negative-weight cycle that is reachable\n   from the source exists, and false otherwise, indicating that no\n   solution exists.\"\n  [g start]\n  (let [initial-estimates (init-estimates g start)\n        ;;relax-edges is calculated for all edges V-1 times\n        [costs paths] (reduce (fn [estimates _]\n                                (relax-edges g start estimates))\n                              initial-estimates\n                              (-> g nodes count dec range))\n        edges (edges g)]\n    (if (some\n         (fn [[u v :as edge]]\n           (can-relax-edge? edge (graph/weight g u v) costs))\n         edges)\n      false\n      [costs\n       (->> (keys paths)\n            ;;remove vertices that are unreachable from source\n            (remove #(= #?(:clj Double/POSITIVE_INFINITY\n                           :cljs js/Infinity)\n                        (get costs %)))\n            (reduce\n             (fn [final-paths v]\n               (assoc final-paths v\n                      ;; follows the parent pointers\n                      ;; to construct path from source to node v\n                      (loop [node v\n                             path ()]\n                        (if node\n                          (recur (get paths node) (cons node path))\n                          path))))\n             {}))])))\n\n(defn dag?\n  \"Returns true if g is a directed acyclic graph\"\n  [g]\n  (boolean (topsort g)))\n\n(defn shortest-path\n  \"Finds the shortest path from start to end in graph g, using Dijkstra's\n  algorithm if the graph is weighted, breadth-first search otherwise.\"\n  [g start end]\n  (if (weighted? g)\n    (dijkstra-path g start end)\n    (bf-path g start end)))\n\n(defn longest-shortest-path\n  \"Finds the longest shortest path beginning at start, using Dijkstra's\n  algorithm if the graph is weighted, breadth-first search otherwise.\"\n  [g start]\n  (reverse\n   (if (weighted? g)\n     (reduce\n      (fn [path1 [n state]]\n        (let [path2 (trace-path (comp second state) n)]\n          (if (< (count path1) (count path2)) path2 path1)))\n      [start]\n      (dijkstra-traverse g start vector))\n     (reduce\n      (fn [path1 [n predmap _]]\n        (let [path2 (trace-path predmap n)]\n          (if (< (count path1) (count path2)) path2 path1)))\n      [start]\n      (bf-traverse g start :f vector)))))\n\n(defn- bellman-ford-transform\n  \"Helper function for Johnson's algorithm. Uses Bellman-Ford to remove negative weights.\"\n  [wg]\n  (let [q (first (drop-while (partial graph/has-node? wg) (repeatedly gensym)))\n        es (for [v (graph/nodes wg)] [q v 0])\n        bf-results (bellman-ford (graph/add-edges* wg es) q)]\n    (if bf-results\n      (let [[dist-q _] bf-results\n            new-es (map (juxt first second (fn [[u v]]\n                                             (+ (weight wg u v) (- (dist-q u)\n                                                                   (dist-q v)))))\n                        (graph/edges wg))]\n        (graph/add-edges* wg new-es))\n      false)))\n\n(defn johnson\n  \"Finds all-pairs shortest paths using Bellman-Ford to remove any negative edges before\n  using Dijkstra's algorithm to find the shortest paths from each vertex to every other.\n  This algorithm is efficient for sparse graphs.\n\n  If the graph is unweighted, a default weight of 1 will be used. Note that it is more efficient\n  to use breadth-first spans for a graph with a uniform edge weight rather than Dijkstra's algorithm.\n  Most callers should use shortest-paths and allow the most efficient implementation be selected\n  for the graph.\"\n  [g]\n  (let [g (if (and (weighted? g) (some (partial > 0) (map (graph/weight g) (graph/edges g))))\n            (bellman-ford-transform g)\n            g)]\n    (if (false? g)\n      false\n      (let [dist (if (weighted? g)\n                   (weight g)\n                   (fn [u v] (when (graph/has-edge? g u v) 1)))]\n        (reduce (fn [acc node]\n                  (assoc acc node (gen/dijkstra-span (successors g) dist node)))\n                {}\n                (nodes g))))))\n\n(defn bf-all-pairs-shortest-paths\n  \"Uses bf-span on each node in the graph.\"\n  [g]\n  (reduce (fn [spans node]\n            (assoc spans node (bf-span g node)))\n          {}\n          (nodes g)))\n\n(defn all-pairs-shortest-paths\n  \"Finds all-pairs shortest paths in a graph. Uses Johnson's algorithm for weighted graphs\n  which is efficient for sparse graphs. Breadth-first spans are used for unweighted graphs.\"\n  [g]\n  (if (weighted? g)\n    (johnson g)\n    (bf-all-pairs-shortest-paths g)))\n\n(defn connected-components\n  \"Returns the connected components of graph g as a vector of vectors. If g\n  is directed, returns the weakly-connected components.\"\n  [g]\n  (let [nb (if-not (directed? g) (graph/successors g)\n                   #(concat (graph/successors g %) (predecessors g %)))]\n    (first\n     (reduce\n      (fn [[cc predmap] n]\n        (if (contains? predmap n)\n          [cc predmap]\n          (let [[c pm] (reduce\n                        (fn [[c _] [n pm _]]\n                          [(conj c n) pm])\n                        [[] nil]\n                        (gen/bf-traverse nb n :f vector :seen predmap))]\n            [(conj cc c) pm])))\n      [[] {}]\n      (nodes g)))))\n\n(defn connected?\n  \"Returns true if g is connected\"\n  [g]\n  (== (count (first (connected-components g))) (count (nodes g))))\n\n(defn scc\n  \"Returns the strongly-connected components of directed graph g as a vector of\n  vectors. Uses Kosaraju's algorithm.\"\n  [g]\n  (let [gt (transpose g)]\n    (loop [stack (reverse (post-traverse g))\n           seen #{}\n           cc (transient [])]\n      (if (empty? stack)\n        (persistent! cc)\n        (if (seen (first stack))\n          (recur (rest stack) seen cc)\n          (let [[c seen] (post-traverse gt (first stack)\n                                      :seen seen :return-seen true)]\n            (recur (rest stack)\n                 seen\n                 (conj! cc c))))\n        ))))\n\n(defn strongly-connected?\n  [g]\n  (== (count (first (scc g))) (count (nodes g))))\n\n(defn connect\n  \"Returns graph g with all connected components connected to each other\"\n  [g]\n  (reduce add-edges g (partition 2 1 (map first (connected-components g)))))\n\n(defn density\n  \"Return the density of graph g\"\n  [g & {:keys [loops] :or {loops false}}]\n  (let [order (count (nodes g))]\n    (/ (count (edges g))\n       (* order (if loops\n                  order\n                  (dec order))))))\n\n(defn loners\n  \"Returns nodes with no connections to other nodes (i.e., isolated nodes)\"\n  [g]\n  (let [degree-total (if (directed? g)\n                       #(+ (in-degree g %) (out-degree g %))\n                       #(out-degree g %))]\n    (filter (comp zero? degree-total) (nodes g))))\n\n(defn distinct-edges\n  \"Returns the distinct edges of g. Only useful for undirected graphs\"\n  [g]\n  (if (directed? g)\n    (edges g)\n    (second\n     (reduce\n      (fn [[seen es] e]\n        (let [eset (set (take 2 e))]\n          (if (seen eset)\n            [seen es]\n            [(conj seen eset)\n             (conj es e)])))\n      [#{} []]\n      (edges g)))))\n\n(defn bipartite-color\n  \"Attempts a two-coloring of graph g. When successful, returns a map of\n  nodes to colors (1 or 0). Otherwise, returns nil.\"\n  [g]\n  (letfn [(color-component [coloring start]\n            (loop [coloring (assoc coloring start 1)\n                   queue (conj #?(:clj clojure.lang.PersistentQueue/EMPTY\n                                  :cljs cljs.core/PersistentQueue.EMPTY) start)]\n              (if (empty? queue)\n                coloring\n                (let [v (peek queue)\n                      color (- 1 (coloring v))\n                      nbrs (graph/successors g v)]\n                  ;; TODO: could be better\n                  (if (some #(and (coloring %) (= (coloring v) (coloring %)))\n                            nbrs)\n                    nil ; graph is not bipartite\n                    (let [nbrs (remove coloring nbrs)]\n                      (recur (into coloring (for [nbr nbrs] [nbr color]))\n                             (into (pop queue) nbrs))))))))]\n    (loop [[node & nodes] (seq (nodes g))\n           coloring {}]\n      (when coloring\n        (if (nil? node)\n          coloring\n          (if (coloring node)\n            (recur nodes coloring)\n            (recur nodes (color-component coloring node))))))))\n\n(defn bipartite?\n  \"Returns true if g is bipartite\"\n  [g]\n  (boolean (bipartite-color g)))\n\n(defn bipartite-sets\n  \"Returns two sets of nodes, one for each color of the bipartite coloring,\n  or nil if g is not bipartite\"\n  [g]\n  (when-let [coloring (bipartite-color g)]\n    (reduce\n     (fn [[s1 s2] [node color]]\n       (if (zero? color)\n         [(conj s1 node) s2]\n         [s1 (conj s2 node)]))\n     [#{} #{}]\n     coloring)))\n\n(defn- neighbor-colors\n  \"Given a putative coloring of a graph, returns the colors of all the\n  neighbors of a given node.\"\n  [g node coloring]\n  (let [successors (graph/successors g node)\n        neighbors (if-not (directed? g)\n                    successors\n                    (concat successors\n                            (graph/predecessors g node)))]\n    (set (remove nil?\n                 (map #(get coloring %)\n                      neighbors)))))\n\n(defn coloring?\n  \"Returns true if a map of nodes to colors is a proper coloring of a graph.\"\n  [g coloring]\n  (letfn [(different-colors? [node]\n            (not (contains? (neighbor-colors g node coloring)\n                            (coloring node))))]\n    (and (every? different-colors? (nodes g))\n         (every? (complement nil?) (map #(get coloring %)\n                                        (nodes g))))))\n\n(defn greedy-coloring\n  \"Greedily color the vertices of a graph using the first-fit heuristic.\n  Returns a map of nodes to colors (0, 1, ...).\"\n  [g]\n  (loop [node-seq (bf-traverse g)\n         coloring {}\n         colors #{}]\n    (if (empty? node-seq)\n      coloring\n      (let [node (first node-seq)\n            possible-colors (clj.set/difference colors\n                                                (neighbor-colors g\n                                                                 node\n                                                                 coloring))\n            node-color (if (empty? possible-colors)\n                         (count colors)\n                         (apply min possible-colors))]\n        (recur (rest node-seq)\n               (conj coloring [node node-color])\n               (conj colors node-color))))))\n\n(defn max-flow\n  \"Returns [flow-map flow-value], where flow-map is a weighted adjacency map\n   representing the maximum flow.  The argument should be a weighted digraph,\n   where the edge weights are flow capacities.  Source and sink are the vertices\n   representing the flow source and sink vertices.  Optionally, pass in\n     :method :algorithm to use.  Currently, the only option is :edmonds-karp .\"\n  [g source sink & {:keys [method] :or {method :edmonds-karp}}]\n  (let [method-set #{:edmonds-karp}\n        n (graph/successors g),\n        i (predecessors g),\n        c (graph/weight g),\n        s source,\n        t sink\n        [flow-map flow-value] (case method\n                                :edmonds-karp (flow/edmonds-karp n i c s t)\n                                (throw\n                                 (ex-info\n                                  (str \"Method not found.  Choose from: \"\n                                       method-set)\n                                  {:method-set method-set})))]\n    [flow-map flow-value]))\n\n\n\n;; mst algorithms\n;; convenience functions for mst algo\n(defn- edge-weights\n  \"Wrapper function to return edges along with weights for a given graph.\n   For un-weighted graphs a default value of one is produced. The function\n   returns values of the form [[[u v] 10] [[x y] 20] ...]\"\n  [wg v]\n  (let [edge-weight (fn [u v]\n                      (if (weighted? wg) (weight wg u v) 1))]\n    (map #(vec [%1 [v (edge-weight v %1)] ])\n         (successors wg v)))\n  )\n\n(defn prim-mst-edges\n  \"An edge-list of an minimum spanning tree along with weights that\n  represents an MST of the given graph. Returns the MST edge-list\n  for un-weighted graphs.\"\n  ([wg]\n     (cond\n      (directed? wg) (throw (#?(:clj Exception. :cljs js/Error)\n                             \"Spanning tree only defined for undirected graphs\"))\n      :else (let [mst (prim-mst-edges wg (nodes wg) nil #{} [])]\n              (if (weighted? wg)\n                mst\n                (map #(vec [(first %1) (second %1)]) mst)))))\n  ([wg n h visited acc]\n     (cond\n      (empty? n) acc\n      (empty? h) (let [v (first n)\n                       h  (into (pm/priority-map-keyfn second) (edge-weights wg v))]\n                   (recur wg (disj n v) h (conj visited v) acc))\n      :else (let [next_edge (peek h)\n                  u (first (second next_edge))\n                  v (first next_edge)\n                  update-dist (fn [h [v [u wt]]]\n                                (cond\n                                 (nil? (get h v)) (assoc h v [u wt])\n                                 (> (second (get h v)) wt) (assoc h v [u wt])\n                                 :else h))]\n              (let [wt (second (second next_edge))\n                    visited (conj visited v)\n                    h (reduce update-dist (pop h)\n                              (filter #((complement visited) (first %) )\n                                      (edge-weights wg v)))]\n                (recur wg (disj n v) h (conj visited v)(conj acc [u v wt])))))))\n\n(defn prim-mst\n  \"Minimum spanning tree of given graph. If the graph contains more than one\n   component then returns a spanning forest of minimum spanning trees.\"\n  [wg]\n  (let [mst (apply graph/weighted-graph (prim-mst-edges wg))\n        ]\n    (cond\n     (= ((comp count nodes) wg) ((comp count nodes) mst)) mst\n     :else (apply add-nodes mst (filter #(zero? (out-degree wg %)) (nodes wg)))\n     )))\n\n(defn astar-path\n  \"Returns the shortest path using A* algorithm. Returns a map of predecessors.\"\n  ([g src target heur]\n     (let [heur (if (nil? heur) (fn [x y] 0) heur)\n           ;; store in q => {u [heur+dist parent act est]}\n           q (pm/priority-map-keyfn first src [0 nil 0 0])\n           explored (hash-map)]\n       (astar-path g src target heur q explored))\n       )\n  ([g src target heur q explored]\n     (cond\n      ;; queue empty, target not reachable\n      (empty? q) (throw (ex-info \"Target not reachable from source\" {}))\n      ;; target found, build path and return\n      (= (first (peek q)) target) (let [u (first (peek q))\n                                        parent ((second (peek q)) 1)\n                                        explored(assoc explored target parent)\n                                        path (loop [s target acc {}]\n                                               (cond\n                                                (nil? s) acc\n                                                (= s src) (assoc acc s nil)\n                                                :else (recur (explored s)\n                                                             (assoc acc s (explored s)))))\n                                        ]\n                                    path\n                                    )\n      ;; continue searching\n      :else (let\n                [curr-node (first (peek q))\n                 curr-dist ((second (peek q)) 2)\n                 ;; update path\n                 explored (assoc explored curr-node ((second (peek q)) 1))\n                 nbrs (remove (into #{} (keys explored)) (successors g curr-node))\n                 ;; we do this for following reasons\n                 ;; a. avoiding duplicate heuristics computation\n                 ;; b. duplicate entries for nodes, which needs to be removed later\n                 ;; TODO: this could be sped up if we priority-map supported transients\n                 update-dist (fn [curr-node curr-dist q v]\n                               (let [act (+ curr-dist\n                                            (if (weighted? g) (weight g curr-node v) 1))\n                                     est (if (nil? (get q v))\n                                           (heur v target) ((get q v) 3))\n                                  ]\n                                 (cond\n                                  (or (nil? (get q v))\n                                      (> ((get q v) 2) act))\n                                  (assoc q v [(+ act est ) curr-node act est])\n                                  :else q)))\n                 q (reduce (partial update-dist curr-node curr-dist) (pop q)\n                           nbrs)]\n              (recur g src target heur q explored)))))\n\n(defn astar-dist\n  \"Returns the length of the shortest path between src and target using\n    the A* algorithm\"\n  [g src target heur]\n  (let [path (astar-path g src target heur)\n        dist (reduce (fn [c [u v]]\n                       (if (nil? v)\n                         c\n                         (+ c (if (weighted? g) (weight g v u) 1))\n                         )\n                       ) 0 path)]\n    dist))\n\n(defn degeneracy-ordering\n  \"Returns sequence of vertices in degeneracy order.\"\n  [g]\n  (loop [ordered-nodes []\n         node-degs (->> (zipmap (nodes g)\n                                (map (partial out-degree g) (nodes g)))\n                        (into (pm/priority-map)))\n         k 0]\n    (if (empty? node-degs)\n      ordered-nodes\n      (let [[n deg] (first node-degs)\n            ;; This will be the adjacent nodes still in node-degs (not in ordered-nodes) decr'd by 1\n            updated-degs (->> (map (juxt identity node-degs) (successors g n))\n                              (filter second)\n                              (map (juxt first (comp dec second)))\n                              (into {}))]\n        (recur (conj ordered-nodes n)\n               (reduce (fn [n-ds [n d]] ;; Update this assoc'ing the updated-degs found above\n                         (assoc n-ds n d))\n                       (dissoc node-degs n)\n                       updated-degs)\n               (max k deg))))))\n\n(defn- bk-gen [g [r p x] stack]\n  (let [v-pivot (reduce (partial max-key (partial out-degree g)) p)]\n    (loop [v v-pivot\n           p (set p)\n           x (set x)\n           stack stack]\n      (if (nil? v)\n        stack\n        (let [succ-v (set (successors g v))]\n          (recur (-> (clj.set/difference (disj p v)\n                                         (set (successors g v-pivot)))\n                     first)\n                 (disj p v)\n                 (conj x v)\n                 (conj stack [(conj r v)\n                              (clj.set/intersection p succ-v)\n                              (clj.set/intersection x succ-v)])))))))\n\n(defn- bk\n  \"An iterative implementation of Bron-Kerbosch using degeneracy ordering\n  at the outer loop and max-degree vertex pivoting in the inner loop.\"\n  [g]\n  (loop [vs (degeneracy-ordering g)\n         max-clqs (seq [])\n         p (set (nodes g))\n         x #{}\n         stack []]\n    (cond\n     ;; Done\n     (and (empty? stack) (empty? vs))\n     max-clqs\n\n     ;; Empty stack, create a seed to generate stack items\n     (empty? stack)\n     (let [v (first vs)\n           succ-v (set (successors g v))]\n       (recur (rest vs)\n              max-clqs\n              (disj p v)\n              (conj x v)\n              [[#{v}\n                (clj.set/intersection p succ-v)\n                (clj.set/intersection x succ-v)]]))\n\n     ;; Pull the next request off the stack\n     :else\n     (let [[r s-p s-x] (peek stack)]\n       (cond\n        ;; Maximal clique found\n        (and (empty? s-p) (empty? s-x))\n        (recur vs\n               (cons r max-clqs)\n               p\n               x\n               (pop stack))\n        ;; No maximal clique that excludes x exists\n        (empty? s-p)\n        (recur vs\n               max-clqs\n               p\n               x\n               (pop stack))\n        ;; Use this state to generate more states\n        :else\n        (recur vs\n               max-clqs\n               p\n               x\n               (bk-gen g [r s-p s-x] (pop stack))))))))\n\n(defn maximal-cliques\n  \"Enumerate the maximal cliques using Bron-Kerbosch.\"\n  [g]\n  (bk g))\n\n;;;\n;;; Compare graphs\n;;;\n(defn subgraph?\n  \"Returns true iff g1 is a subgraph of g2. An undirected graph is never\n  considered as a subgraph of a directed graph and vice versa.\"\n  [g1 g2]\n  (and (= (directed? g1) (directed? g2))\n       (let [edge-test-fn (if (directed? g1)\n                            graph/has-edge?\n                            (fn [g x y]\n                              (or (graph/has-edge? g x y)\n                                  (graph/has-edge? g y x))))]\n         (and (every? #(graph/has-node? g2 %) (nodes g1))\n              (every? (fn [[x y]] (edge-test-fn g2 x y))\n                      (edges g1))))))\n\n(defn eql?\n  \"Returns true iff g1 is a subgraph of g2 and g2 is a subgraph of g1\"\n  [g1 g2]\n  (and (subgraph? g1 g2)\n       (subgraph? g2 g1)))\n\n(defn isomorphism?\n  \"Given a mapping phi between the vertices of two graphs, determine\n  if the mapping is an isomorphism, e.g., {(phi x), (phi y)} connected\n  in g2 iff {x, y} are connected in g1.\"\n  [g1 g2 phi]\n  (eql? g2 (-> (if (directed? g1) (digraph) (graph))\n               (graph/add-nodes* (map phi (nodes g1)))\n               (graph/add-edges* (map (fn [[x y]] [(phi x) (phi y)])\n                                      (edges g1))))))\n\n;; ;; Todo: MST, coloring, matching, etc etc\n","~:reader-features",["^J",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["loom.alg/traverse-all","nodes","traverse","cljs.core/persistent!","cljs.core/second","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","p__29982","vec__29983","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","seen","trav","n","ctrav","G__29986","G__29987","G__29988","cljs.core.into.cljs$core$IFn$_invoke$arity$2","cljs.core/conj!","cljs.core/transient","var_args","G__29990","loom.alg/pre-traverse","js/Error","g","loom.graph/nodes","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","loom.alg-generic/pre-traverse","loom.graph.successors.cljs$core$IFn$_invoke$arity$1","start","G__29994","loom.alg/pre-span","p__29995","vec__29996","span","vec__30000","cspan","loom.alg_generic.pre_span.cljs$core$IFn$_invoke$arity$variadic","cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic","loom.alg-generic/pre-span","G__30008","loom.alg/post-traverse","args-arr__4751__auto__","len__4730__auto__","i__4731__auto__","argseq__4752__auto__","cljs.core/IndexedSeq","seq30005","G__30006","cljs.core/first","cljs.core/next","G__30007","self__4717__auto__","loom.alg-generic/post-traverse","opts","cljs.core.apply.cljs$core$IFn$_invoke$arity$4","G__30010","loom.alg/topsort","G__30014","vec__30015","seq__30016","cljs.core/seq","first__30017","vec__30021","seq__30022","first__30023","result","ns","cljs.core/not","temp__5720__auto__","cresult","loom.alg_generic.topsort_component.cljs$core$IFn$_invoke$arity$4","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","loom.alg_generic.topsort_component.cljs$core$IFn$_invoke$arity$2","G__30041","loom.alg/bf-traverse","seq30038","G__30039","G__30040","p__30049","vec__30050","cc","predmap","cljs.core/contains?","p__30054","p__30055","vec__30056","vec__30059","_","pm","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","loom.alg_generic.bf_traverse.cljs$core$IFn$_invoke$arity$variadic","cljs.core/vector","loom.alg-generic/bf-traverse","G__30070","loom.alg/bf-span","loom.alg-generic/preds->span","cljs.core/last","loom.alg-generic/bf-span","args__4736__auto__","argseq__4737__auto__","loom.alg/bf-path","seq30074","G__30075","G__30076","G__30077","end","cljs.core.apply.cljs$core$IFn$_invoke$arity$5","loom.alg-generic/bf-path","loom.alg/bf-path-bi","loom.graph/directed?","loom.alg-generic/bf-path-bi","loom.graph.predecessors.cljs$core$IFn$_invoke$arity$1","G__30085","loom.alg/dijkstra-traverse","loom.alg_generic.dijkstra_traverse.cljs$core$IFn$_invoke$arity$3","loom.graph.weight.cljs$core$IFn$_invoke$arity$1","loom.alg_generic.dijkstra_traverse.cljs$core$IFn$_invoke$arity$4","f","G__30094","loom.alg/dijkstra-span","loom.alg-generic/dijkstra-span","loom.alg/dijkstra-path-dist","loom.alg-generic/dijkstra-path-dist","loom.alg/dijkstra-path","p__30127","vec__30128","loom.alg/can-relax-edge?","u","v","edge","weight","costs","vd","cljs.core.get.cljs$core$IFn$_invoke$arity$2","ud","sum","p__30140","p__30141","vec__30142","vec__30145","loom.alg/relax-edge","paths","estimates","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","loom.alg/relax-edges","loom.graph/edges","p__30152","vec__30153","loom.graph.weight.cljs$core$IFn$_invoke$arity$3","loom.alg/init-estimates","graph","cljs.core.disj.cljs$core$IFn$_invoke$arity$2","path-costs","infinities","cljs.core.repeat.cljs$core$IFn$_invoke$arity$1","js/Infinity","nils","init-costs","cljs.core.interleave.cljs$core$IFn$_invoke$arity$2","init-paths","cljs.core.apply.cljs$core$IFn$_invoke$arity$3","cljs.core/assoc","loom.alg/bellman-ford","vec__30157","initial-estimates","cljs.core/count","cljs.core.range.cljs$core$IFn$_invoke$arity$1","edges","cljs.core/some","p__30160","vec__30161","cljs.core/keys","p1__30156#","cljs.core.remove.cljs$core$IFn$_invoke$arity$2","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","final-paths","node","path","cljs.core/cons","loom.alg/dag?","cljs.core/boolean","loom.alg.topsort.cljs$core$IFn$_invoke$arity$1","loom.alg/shortest-path","loom.graph/weighted?","loom.alg/longest-shortest-path","cljs.core/reverse","p__30166","vec__30167","path1","state","path2","loom.alg-generic/trace-path","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","loom.alg.dijkstra_traverse.cljs$core$IFn$_invoke$arity$3","p__30170","vec__30171","loom.alg.bf_traverse.cljs$core$IFn$_invoke$arity$variadic","loom.alg/bellman-ford-transform","wg","q","cljs.core.drop_while.cljs$core$IFn$_invoke$arity$2","loom.graph/has-node?","cljs.core.repeatedly.cljs$core$IFn$_invoke$arity$1","cljs.core/gensym","es","iter__4523__auto__","s__30175","cljs.core/LazySeq","cljs.core/chunked-seq?","c__4521__auto__","size__4522__auto__","b__30177","cljs.core/chunk-buffer","i__30176","cljs.core._nth.cljs$core$IFn$_invoke$arity$2","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__30174","cljs.core/chunk-rest","cljs.core/rest","bf-results","loom.graph/add-edges*","vec__30179","dist-q","new-es","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core.juxt.cljs$core$IFn$_invoke$arity$3","p__30182","vec__30183","loom.alg/johnson","and__4120__auto__","cljs.core/>","dist","loom.graph/has-edge?","acc","loom.alg/bf-all-pairs-shortest-paths","spans","loom.alg.bf_span.cljs$core$IFn$_invoke$arity$2","loom.alg/all-pairs-shortest-paths","loom.alg/connected-components","nb","p1__30187#","loom.graph.successors.cljs$core$IFn$_invoke$arity$2","loom.graph.predecessors.cljs$core$IFn$_invoke$arity$2","p__30189","vec__30190","vec__30193","c","p__30196","p__30197","vec__30198","vec__30201","loom.alg/connected?","loom.alg/scc","gt","loom.graph/transpose","stack","loom.alg.post_traverse.cljs$core$IFn$_invoke$arity$1","cljs.core/empty?","G__30209","vec__30211","loom.alg.post_traverse.cljs$core$IFn$_invoke$arity$variadic","cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2","loom.alg/strongly-connected?","loom.alg/connect","loom.graph/add-edges","cljs.core.partition.cljs$core$IFn$_invoke$arity$3","loom.alg/density","p__30218","map__30219","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$3","seq30216","G__30217","loops","order","loom.alg/loners","degree-total","p1__30221#","p1__30222#","loom.graph/in-degree","loom.graph/out-degree","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core/zero?","loom.alg/distinct-edges","p__30223","vec__30224","e","eset","cljs.core/set","cljs.core.take.cljs$core$IFn$_invoke$arity$2","loom.alg/bipartite-color","coloring","queue","cljs.core/PersistentQueue","cljs.core/peek","color","nbrs","p1__30228#","s__30253","b__30255","i__30254","iter__30252","nbr","cljs.core/pop","G__30267","vec__30268","seq__30269","first__30270","vec__30280","seq__30281","first__30282","color-component","loom.alg/bipartite?","loom.alg/bipartite-sets","p__30299","p__30300","vec__30304","vec__30307","s1","s2","loom.alg/neighbor-colors","successors","neighbors","cljs.core/nil?","p1__30311#","loom.alg/coloring?","cljs.core/every?","different-colors?","cljs.core/complement","p1__30322#","loom.alg/greedy-coloring","node-seq","loom.alg.bf_traverse.cljs$core$IFn$_invoke$arity$1","colors","possible-colors","clojure.set.difference.cljs$core$IFn$_invoke$arity$2","node-color","cljs.core/min","loom.alg/max-flow","p__30346","map__30347","seq30339","G__30340","G__30341","G__30342","source","sink","method","vec__30351","method-set","i","s","t","flow-map","flow-value","G__30354","cljs.core/Keyword","loom.flow.edmonds_karp.cljs$core$IFn$_invoke$arity$5","cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2","loom.alg/edge-weights","edge-weight","p1__30365#","cljs.core/vec","G__30371","loom.alg/prim-mst-edges","mst","loom.alg.prim_mst_edges.cljs$core$IFn$_invoke$arity$5","p1__30368#","h","visited","tailrecursion.priority-map/priority-map-keyfn","next_edge","update-dist","p__30382","vec__30383","vec__30386","wt","p1__30369#","G__30390","fexpr__30389","loom.alg/prim-mst","loom.graph/weighted-graph","loom.alg.prim_mst_edges.cljs$core$IFn$_invoke$arity$1","fexpr__30396","fexpr__30397","loom.graph/add-nodes","p1__30391#","G__30399","loom.alg/astar-path","src","target","heur","x","y","tailrecursion.priority_map.priority_map_keyfn.cljs$core$IFn$_invoke$arity$variadic","explored","cljs.core/PersistentHashMap","loom.alg.astar_path.cljs$core$IFn$_invoke$arity$6","parent","fexpr__30418","curr-node","curr-dist","fexpr__30424","fexpr__30425","act","est","fexpr__30431","fexpr__30434","cljs.core.partial.cljs$core$IFn$_invoke$arity$3","loom.alg/astar-dist","loom.alg.astar_path.cljs$core$IFn$_invoke$arity$4","p__30436","vec__30437","loom.alg/degeneracy-ordering","ordered-nodes","node-degs","cljs.core/zipmap","tailrecursion.priority-map/priority-map","k","vec__30456","deg","updated-degs","cljs.core.juxt.cljs$core$IFn$_invoke$arity$2","cljs.core/identity","cljs.core/dec","p__30459","vec__30460","n-ds","d","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","x__4219__auto__","y__4220__auto__","p__30463","vec__30465","loom.alg/bk-gen","r","p","v-pivot","cljs.core.reduce.cljs$core$IFn$_invoke$arity$2","cljs.core/max-key","succ-v","clojure.set.intersection.cljs$core$IFn$_invoke$arity$2","loom.alg/bk","vs","max-clqs","vec__30491","s-p","s-x","loom.alg/maximal-cliques","loom.alg/subgraph?","g1","g2","edge-test-fn","or__4131__auto__","p1__30496#","p__30534","vec__30535","loom.alg/eql?","loom.alg/isomorphism?","phi","loom.graph/digraph","loom.graph/graph","loom.graph/add-nodes*","p__30542","vec__30543","cljs.core/chunk-first"]]],"~:cache-keys",["~#cmap",[["~:macro","~$loom.cljs"],[1545217035000],["^1Z","^Q"],[1559826623000],["^1M","cljs/tools/reader/impl/utils.cljs"],[1560546087000,"~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^J",[]],"~:deps-syms",["^T","^Q","~$clojure.string","~$goog.string"]]],["^1M","goog/math/math.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","~$goog.array","~$goog.asserts"]]],["^1M","goog/array/array.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^27"]]],["^1Z","~$cljs.tools.reader.reader-types"],[1560546087000],["^1M","goog/debug/error.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T"]]],["^1M","cljs/tools/reader/edn.cljs"],[1560546087000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^Q","~$cljs.tools.reader.impl.errors","^28","~$cljs.tools.reader.impl.utils","~$cljs.tools.reader.impl.commons","~$cljs.tools.reader","^25","~$goog.string.StringBuffer"]]],["^1M","goog/dom/nodetype.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T"]]],["^1M","cljs/tools/reader/impl/inspect.cljs"],[1560546087000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^Q"]]],["^1M","loom/graph.cljc"],[1545217035000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^Q","^R"]]],["^1M","tailrecursion/priority_map.cljs"],[1545217035000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^Q","~$cljs.reader"]]],["^1M","cljs/tools/reader.cljs"],[1560546087000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^Q","^28","^2:","^2;","^29","^26","^25","^2="]]],["^1M","goog/object/object.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T"]]],"~:SHADOW-TIMESTAMP",[1560546091000,1559826623000],["^1M","goog/math/long.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^27","~$goog.reflect"]]],["^1M","goog/string/internal.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T"]]],["^1M","goog/functions/functions.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T"]]],["^1M","goog/structs/map.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^1M","cljs/reader.cljs"],[1559826623000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^Q","~$goog.object","^2<","~$cljs.tools.reader.edn","^2="]]],["^1M","goog/asserts/asserts.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1M","goog/uri/uri.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^26","^27","^25","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1M","loom/flow.cljc"],[1545217035000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^Q","^R"]]],["^1M","goog/base.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",[]]],["^1M","goog/structs/structs.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^26","^2C"]]],["^1M","cljs/tools/reader/impl/errors.cljs"],[1560546087000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^Q","^28","^24","~$cljs.tools.reader.impl.inspect"]]],["^1M","clojure/string.cljs"],[1559826623000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^Q","^25","^2="]]],["^1M","loom/alg.cljc"],[1545217035000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^Q","^R","^Y","^S","^Z","^V"]]],["^1M","goog/string/string.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","~$goog.string.internal"]]],["^1M","goog/reflect/reflect.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T"]]],["^1M","goog/string/stringbuffer.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T"]]],["^1M","cljs/tools/reader/reader_types.cljs"],[1560546087000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^Q","^2:","^25","^2="]]],["^1M","goog/iter/iter.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^26","^27","~$goog.functions","~$goog.math"]]],["^1M","loom/alg_generic.cljc"],[1545217035000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^Q"]]],["^1M","cljs/tools/reader/impl/commons.cljs"],[1560546087000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^Q","^29","^28","^2:"]]],["^1M","cljs/core.cljs"],[1559826623000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["~$goog.math.Long","~$goog.math.Integer","^25","^2C","^26","~$goog.Uri","^2="]]],["^1M","goog/math/integer.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T"]]],["^1M","clojure/set.cljs"],[1559826623000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^Q"]]],["^1M","goog/uri/utils.js"],[1560546089000,"^20",["^ ","^21",null,"^22",["^J",[]],"^23",["^T","^26","^27","^25"]]],["^1Z","^2>"],[1559826623000]]],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","loom/alg.cljc","^7",5,"^8",3,"^9",5,"^:",11,"^;","Graph algorithms. Any graph record/type that satisfies the\nGraph, Digraph, or WeightedGraph protocols (as appropriate per algorithm)\ncan use these functions.","^<","Justin Kramer"],"^=",["^ ","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G"],"^H",null,"^I",["^J",[]],"^K","^L","^O",null,"^P",["^ ","^Q","^Q","^R","^R","^S","^S","^T","^T","^U","^V","^W","^R","^X","^Y","^Z","^Z","^V","^V","^Y","^Y","^[","^Z","^10","^S"],"^11",["^J",["^12"]],"~:shadow/js-access-global",["^J",["Infinity","Error"]],"^13",["^ ","^14","^S","^15","^S","^16","^S","^17","^S","^18","^S","^19","^S","^1:","^R","^1;","^R","^1<","^S","^1=","^S","^1>","^S","^1?","^S","^1@","^S","^1A","^S","^10","^S","^1B","^S"],"~:defs",["^ ","~$relax-edges",["^ ","~:protocol-inline",null,"^5",["^ ","^6","loom/alg.cljc","^7",189,"^8",8,"^9",189,"^:",19,"~:private",true,"~:arglists",["^1E",["~$quote",["^1E",[["~$g","~$start","~$estimates"]]]]],"^;","Performs edge relaxation on all edges in weighted directed graph"],"^2X",true,"^K","~$loom.alg/relax-edges","^6","loom/alg.cljc","^:",19,"~:method-params",["^1E",[["~$g","^2[","^30"]]],"~:protocol-impl",null,"~:arglists-meta",["^1E",[null,null]],"^8",1,"~:variadic?",false,"^7",189,"~:ret-tag",["^J",[null,"~$any"]],"^9",189,"~:max-fixed-arity",3,"~:fn-var",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^2[","^30"]]]]],"^;","Performs edge relaxation on all edges in weighted directed graph"],"~$degeneracy-ordering",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",663,"^8",7,"^9",663,"^:",26,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns sequence of vertices in degeneracy order."],"^K","~$loom.alg/degeneracy-ordering","^6","loom/alg.cljc","^:",26,"^32",["^1E",[["~$g"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",663,"^36",["^J",["~$clj","~$cljs.core/IVector"]],"^9",663,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns sequence of vertices in degeneracy order."],"~$pre-span",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^:",15,"~:top-fn",["^ ","^35",false,"~:fixed-arity",2,"^38",2,"^32",["^1E",[["~$g"],["~$g","^2["]]],"^2Y",["^1E",[["~$g"],["~$g","^2["]]],"^34",["^1E",[null,null]]],"^8",7,"^7",41,"^9",41,"^2Y",["^1E",["^2Z",["^1E",[["~$g"],["~$g","^2["]]]]],"^;","Returns a depth-first spanning tree of the form {node [successors]}","~:jsdoc",["^1E",["@param {...*} var_args"]]],"^K","~$loom.alg/pre-span","^6","loom/alg.cljc","^:",15,"^3?",["^ ","^35",false,"^3@",2,"^38",2,"^32",["^1E",[["~$g"],["~$g","^2["]]],"^2Y",["^1E",[["~$g"],["~$g","^2["]]],"^34",["^1E",[null,null]]],"^32",["^1E",[["~$g"],["~$g","^2["]]],"^33",null,"^3@",2,"^34",["^1E",[null,null]],"^8",1,"^35",false,"~:methods",[["^ ","^3@",1,"^35",false,"~:tag",["^J",["^37","~$clj-nil"]]],["^ ","^3@",2,"^35",false,"^3D",["^J",[null,"^3=","^37"]]]],"^7",41,"^9",41,"^38",2,"^39",true,"^2Y",["^1E",[["~$g"],["~$g","^2["]]],"^;","Returns a depth-first spanning tree of the form {node [successors]}","^3A",["^1E",["@param {...*} var_args"]]],"~$bf-all-pairs-shortest-paths",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",324,"^8",7,"^9",324,"^:",34,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Uses bf-span on each node in the graph."],"^K","~$loom.alg/bf-all-pairs-shortest-paths","^6","loom/alg.cljc","^:",34,"^32",["^1E",[["~$g"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",324,"^36",["^J",[null,"^37"]],"^9",324,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Uses bf-span on each node in the graph."],"~$subgraph?",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",764,"^8",7,"^9",764,"^:",16,"^2Y",["^1E",["^2Z",["^1E",[["~$g1","~$g2"]]]]],"^;","Returns true iff g1 is a subgraph of g2. An undirected graph is never\n  considered as a subgraph of a directed graph and vice versa."],"^K","~$loom.alg/subgraph?","^6","loom/alg.cljc","^:",16,"^32",["^1E",[["^3I","^3J"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",764,"^36","~$boolean","^9",764,"^38",2,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["^3I","^3J"]]]]],"^;","Returns true iff g1 is a subgraph of g2. An undirected graph is never\n  considered as a subgraph of a directed graph and vice versa."],"~$density",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^:",14,"^3?",["^ ","^35",true,"^3@",1,"^38",1,"^32",[["^1E",["~$g",["^ ","~:keys",["~$loops"],"~:or",["^ ","^3O",false]]]]],"^2Y",["^1E",[["~$g","~$&",["^ ","^3N",["^3O"],"^3P",["^ ","^3O",false]]]]],"^34",["^1E",[null]]],"^8",7,"^7",393,"^9",393,"^2Y",["^1E",["^2Z",["^1E",[["~$g","~$&",["^ ","^3N",["^3O"],"^3P",["^ ","^3O",false]]]]]]],"^;","Return the density of graph g","^3A",["^1E",["@param {...*} var_args"]]],"^K","~$loom.alg/density","^6","loom/alg.cljc","^:",14,"^3?",["^ ","^35",true,"^3@",1,"^38",1,"^32",[["^1E",["~$g",["^ ","^3N",["^3O"],"^3P",["^ ","^3O",false]]]]],"^2Y",["^1E",[["~$g","~$&",["^ ","^3N",["^3O"],"^3P",["^ ","^3O",false]]]]],"^34",["^1E",[null]]],"^32",[["^1E",["~$g",["^ ","^3N",["^3O"],"^3P",["^ ","^3O",false]]]]],"^33",null,"^3@",1,"^34",["^1E",[null]],"^8",1,"^35",true,"^3C",[["^ ","^3@",1,"^35",true,"^3D","~$number"]],"^7",393,"^36","^37","^9",393,"^38",1,"^39",true,"^2Y",["^1E",[["~$g","~$&",["^ ","^3N",["^3O"],"^3P",["^ ","^3O",false]]]]],"^;","Return the density of graph g","^3A",["^1E",["@param {...*} var_args"]]],"~$bellman-ford",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",217,"^8",7,"^9",217,"^:",19,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^2["]]]]],"^;","Given a weighted, directed graph G = (V, E) with source start,\n   the Bellman-Ford algorithm produces map of single source shortest\n   paths and their costs if no negative-weight cycle that is reachable\n   from the source exists, and false otherwise, indicating that no\n   solution exists."],"^K","~$loom.alg/bellman-ford","^6","loom/alg.cljc","^:",19,"^32",["^1E",[["~$g","^2["]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",217,"^36",["^J",["^3L","^3="]],"^9",217,"^38",2,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^2["]]]]],"^;","Given a weighted, directed graph G = (V, E) with source start,\n   the Bellman-Ford algorithm produces map of single source shortest\n   paths and their costs if no negative-weight cycle that is reachable\n   from the source exists, and false otherwise, indicating that no\n   solution exists."],"~$astar-dist",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",650,"^8",7,"^9",650,"^:",17,"^2Y",["^1E",["^2Z",["^1E",[["~$g","~$src","~$target","~$heur"]]]]],"^;","Returns the length of the shortest path between src and target using\n    the A* algorithm"],"^K","~$loom.alg/astar-dist","^6","loom/alg.cljc","^:",17,"^32",["^1E",[["~$g","^3V","^3W","^3X"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",650,"^36",["^J",[null,"^37"]],"^9",650,"^38",4,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^3V","^3W","^3X"]]]]],"^;","Returns the length of the shortest path between src and target using\n    the A* algorithm"],"~$distinct-edges",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",410,"^8",7,"^9",410,"^:",21,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns the distinct edges of g. Only useful for undirected graphs"],"^K","~$loom.alg/distinct-edges","^6","loom/alg.cljc","^:",21,"^32",["^1E",[["~$g"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",410,"^36",["^J",["^37","^3E"]],"^9",410,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns the distinct edges of g. Only useful for undirected graphs"],"~$bk",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",704,"^8",8,"^9",704,"^:",10,"^2X",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","An iterative implementation of Bron-Kerbosch using degeneracy ordering\n  at the outer loop and max-degree vertex pivoting in the inner loop."],"^2X",true,"^K","~$loom.alg/bk","^6","loom/alg.cljc","^:",10,"^32",["^1E",[["~$g"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",704,"^36",["^J",["~$seq","^3<"]],"^9",704,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","An iterative implementation of Bron-Kerbosch using degeneracy ordering\n  at the outer loop and max-degree vertex pivoting in the inner loop."],"~$bipartite?",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",455,"^8",7,"^9",455,"^:",17,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns true if g is bipartite"],"^K","~$loom.alg/bipartite?","^6","loom/alg.cljc","^:",17,"^32",["^1E",[["~$g"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",455,"^36","^3L","^9",455,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns true if g is bipartite"],"~$greedy-coloring",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",496,"^8",7,"^9",496,"^:",22,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Greedily color the vertices of a graph using the first-fit heuristic.\n  Returns a map of nodes to colors (0, 1, ...)."],"^K","~$loom.alg/greedy-coloring","^6","loom/alg.cljc","^:",22,"^32",["^1E",[["~$g"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",496,"^36",["^J",["^3<","~$cljs.core/IMap"]],"^9",496,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Greedily color the vertices of a graph using the first-fit heuristic.\n  Returns a map of nodes to colors (0, 1, ...)."],"~$dijkstra-path-dist",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",158,"^8",7,"^9",158,"^:",25,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^2[","~$end"]]]]],"^;","Finds the shortest path from start to end. Returns a vector:\n  [path distance]"],"^K","~$loom.alg/dijkstra-path-dist","^6","loom/alg.cljc","^:",25,"^32",["^1E",[["~$g","^2[","^49"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",158,"^36",["^J",["^3=","^3E"]],"^9",158,"^38",3,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^2[","^49"]]]]],"^;","Finds the shortest path from start to end. Returns a vector:\n  [path distance]"],"~$scc",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",365,"^8",7,"^9",365,"^:",10,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns the strongly-connected components of directed graph g as a vector of\n  vectors. Uses Kosaraju's algorithm."],"^K","~$loom.alg/scc","^6","loom/alg.cljc","^:",10,"^32",["^1E",[["~$g"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",365,"^36","^3<","^9",365,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns the strongly-connected components of directed graph g as a vector of\n  vectors. Uses Kosaraju's algorithm."],"~$bipartite-sets",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",460,"^8",7,"^9",460,"^:",21,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns two sets of nodes, one for each color of the bipartite coloring,\n  or nil if g is not bipartite"],"^K","~$loom.alg/bipartite-sets","^6","loom/alg.cljc","^:",21,"^32",["^1E",[["~$g"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",460,"^36",["^J",[null,"^37","^3E"]],"^9",460,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns two sets of nodes, one for each color of the bipartite coloring,\n  or nil if g is not bipartite"],"~$loners",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",402,"^8",7,"^9",402,"^:",13,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns nodes with no connections to other nodes (i.e., isolated nodes)"],"^K","~$loom.alg/loners","^6","loom/alg.cljc","^:",13,"^32",["^1E",[["~$g"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",402,"^36","~$cljs.core/LazySeq","^9",402,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns nodes with no connections to other nodes (i.e., isolated nodes)"],"~$traverse-all",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",20,"^8",8,"^9",20,"^:",20,"^2X",true,"^2Y",["^1E",["^2Z",["^1E",[["^1A","~$traverse"]]]]]],"^2X",true,"^K","~$loom.alg/traverse-all","^6","loom/alg.cljc","^:",20,"^32",["^1E",[["^1A","^4C"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",20,"^36","^3<","^9",20,"^38",2,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["^1A","^4C"]]]]]],"~$longest-shortest-path",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",267,"^8",7,"^9",267,"^:",28,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^2["]]]]],"^;","Finds the longest shortest path beginning at start, using Dijkstra's\n  algorithm if the graph is weighted, breadth-first search otherwise."],"^K","~$loom.alg/longest-shortest-path","^6","loom/alg.cljc","^:",28,"^32",["^1E",[["~$g","^2["]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",267,"^36",["^J",[null,"^42","~$cljs.core/IList","^37"]],"^9",267,"^38",2,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^2["]]]]],"^;","Finds the longest shortest path beginning at start, using Dijkstra's\n  algorithm if the graph is weighted, breadth-first search otherwise."],"~$neighbor-colors",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",473,"^8",8,"^9",473,"^:",23,"^2X",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g","~$node","~$coloring"]]]]],"^;","Given a putative coloring of a graph, returns the colors of all the\n  neighbors of a given node."],"^2X",true,"^K","~$loom.alg/neighbor-colors","^6","loom/alg.cljc","^:",23,"^32",["^1E",[["~$g","^4I","^4J"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",473,"^36",["^J",["^3<","^37","~$cljs.core/ISet","~$cljs.core/MetaFn","^3E"]],"^9",473,"^38",3,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^4I","^4J"]]]]],"^;","Given a putative coloring of a graph, returns the colors of all the\n  neighbors of a given node."],"~$dag?",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",254,"^8",7,"^9",254,"^:",11,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns true if g is a directed acyclic graph"],"^K","~$loom.alg/dag?","^6","loom/alg.cljc","^:",11,"^32",["^1E",[["~$g"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",254,"^36","^3L","^9",254,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns true if g is a directed acyclic graph"],"~$prim-mst-edges",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^:",21,"^3?",["^ ","^35",false,"^3@",5,"^38",5,"^32",["^1E",[["~$wg"],["^4Q","~$n","~$h","~$visited","~$acc"]]],"^2Y",["^1E",[["^4Q"],["^4Q","~$n","~$h","^4R","^4S"]]],"^34",["^1E",[null,null]]],"^8",7,"^7",554,"^9",554,"^2Y",["^1E",["^2Z",["^1E",[["^4Q"],["^4Q","~$n","~$h","^4R","^4S"]]]]],"^;","An edge-list of an minimum spanning tree along with weights that\n  represents an MST of the given graph. Returns the MST edge-list\n  for un-weighted graphs.","^3A",["^1E",["@param {...*} var_args"]]],"^K","~$loom.alg/prim-mst-edges","^6","loom/alg.cljc","^:",21,"^3?",["^ ","^35",false,"^3@",5,"^38",5,"^32",["^1E",[["^4Q"],["^4Q","~$n","~$h","^4R","^4S"]]],"^2Y",["^1E",[["^4Q"],["^4Q","~$n","~$h","^4R","^4S"]]],"^34",["^1E",[null,null]]],"^32",["^1E",[["^4Q"],["^4Q","~$n","~$h","^4R","^4S"]]],"^33",null,"^3@",5,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^3C",[["^ ","^3@",1,"^35",false,"^3D",["^J",["^37","^4A"]]],["^ ","^3@",5,"^35",false]],"^7",554,"^9",554,"^38",5,"^39",true,"^2Y",["^1E",[["^4Q"],["^4Q","~$n","~$h","^4R","^4S"]]],"^;","An edge-list of an minimum spanning tree along with weights that\n  represents an MST of the given graph. Returns the MST edge-list\n  for un-weighted graphs.","^3A",["^1E",["@param {...*} var_args"]]],"~$shortest-path",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",259,"^8",7,"^9",259,"^:",20,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^2[","^49"]]]]],"^;","Finds the shortest path from start to end in graph g, using Dijkstra's\n  algorithm if the graph is weighted, breadth-first search otherwise."],"^K","~$loom.alg/shortest-path","^6","loom/alg.cljc","^:",20,"^32",["^1E",[["~$g","^2[","^49"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",259,"^36",["^J",["^37","^3E"]],"^9",259,"^38",3,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^2[","^49"]]]]],"^;","Finds the shortest path from start to end in graph g, using Dijkstra's\n  algorithm if the graph is weighted, breadth-first search otherwise."],"~$bk-gen",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",686,"^8",8,"^9",686,"^:",14,"^2X",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g",["~$r","~$p","~$x"],"~$stack"]]]]]],"^2X",true,"^K","~$loom.alg/bk-gen","^6","loom/alg.cljc","^:",14,"^32",["^1E",[["~$g","~$p__30463","^4X"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",686,"^36","^37","^9",686,"^38",3,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g",["~$r","~$p","~$x"],"^4X"]]]]]],"~$init-estimates",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",197,"^8",8,"^9",197,"^:",22,"^2X",true,"^2Y",["^1E",["^2Z",["^1E",[["^10","^2["]]]]],"^;","Initializes path cost estimates and paths from source to all vertices,\n   for Bellman-Ford algorithm"],"^2X",true,"^K","~$loom.alg/init-estimates","^6","loom/alg.cljc","^:",22,"^32",["^1E",[["^10","^2["]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",197,"^36","^3=","^9",197,"^38",2,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["^10","^2["]]]]],"^;","Initializes path cost estimates and paths from source to all vertices,\n   for Bellman-Ford algorithm"],"~$maximal-cliques",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",756,"^8",7,"^9",756,"^:",22,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Enumerate the maximal cliques using Bron-Kerbosch."],"^K","~$loom.alg/maximal-cliques","^6","loom/alg.cljc","^:",22,"^32",["^1E",[["~$g"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",756,"^36",["^J",["^42","^3<"]],"^9",756,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Enumerate the maximal cliques using Bron-Kerbosch."],"~$connected-components",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",340,"^8",7,"^9",340,"^:",27,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns the connected components of graph g as a vector of vectors. If g\n  is directed, returns the weakly-connected components."],"^K","~$loom.alg/connected-components","^6","loom/alg.cljc","^:",27,"^32",["^1E",[["~$g"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",340,"^36",["^J",["^37","^3E"]],"^9",340,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns the connected components of graph g as a vector of vectors. If g\n  is directed, returns the weakly-connected components."],"~$johnson",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",301,"^8",7,"^9",301,"^:",14,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Finds all-pairs shortest paths using Bellman-Ford to remove any negative edges before\n  using Dijkstra's algorithm to find the shortest paths from each vertex to every other.\n  This algorithm is efficient for sparse graphs.\n\n  If the graph is unweighted, a default weight of 1 will be used. Note that it is more efficient\n  to use breadth-first spans for a graph with a uniform edge weight rather than Dijkstra's algorithm.\n  Most callers should use shortest-paths and allow the most efficient implementation be selected\n  for the graph."],"^K","~$loom.alg/johnson","^6","loom/alg.cljc","^:",14,"^32",["^1E",[["~$g"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",301,"^36",["^J",[null,"^3L","^37"]],"^9",301,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Finds all-pairs shortest paths using Bellman-Ford to remove any negative edges before\n  using Dijkstra's algorithm to find the shortest paths from each vertex to every other.\n  This algorithm is efficient for sparse graphs.\n\n  If the graph is unweighted, a default weight of 1 will be used. Note that it is more efficient\n  to use breadth-first spans for a graph with a uniform edge weight rather than Dijkstra's algorithm.\n  Most callers should use shortest-paths and allow the most efficient implementation be selected\n  for the graph."],"~$connected?",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",360,"^8",7,"^9",360,"^:",17,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns true if g is connected"],"^K","~$loom.alg/connected?","^6","loom/alg.cljc","^:",17,"^32",["^1E",[["~$g"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",360,"^36","^3L","^9",360,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns true if g is connected"],"~$relax-edge",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",178,"^8",8,"^9",178,"^:",18,"^2X",true,"^2Y",["^1E",["^2Z",["^1E",[[["~$u","~$v","^1G","~$edge"],"^1@",["~$costs","~$paths","^1G","^30"]]]]]],"^;","If there's a shorter path from s to v via u,\n    update our map of estimated path costs and\n   map of paths from source to vertex v"],"^2X",true,"^K","~$loom.alg/relax-edge","^6","loom/alg.cljc","^:",18,"^32",["^1E",[["~$p__30140","^1@","~$p__30141"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",178,"^36",["^J",[null,"^3="]],"^9",178,"^38",3,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[[["~$u","~$v","^1G","^5:"],"^1@",["^5;","^5<","^1G","^30"]]]]]],"^;","If there's a shorter path from s to v via u,\n    update our map of estimated path costs and\n   map of paths from source to vertex v"],"~$bf-path",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^:",14,"^3?",["^ ","^35",true,"^3@",3,"^38",3,"^32",[["^1E",["~$g","^2[","^49","~$opts"]]],"^2Y",["^1E",[["~$g","^2[","^49","~$&","^5A"]]],"^34",["^1E",[null]]],"^8",7,"^7",122,"^9",122,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^2[","^49","~$&","^5A"]]]]],"^;","Returns a path from start to end with the fewest hops (i.e. irrespective\n  of edge weights)","^3A",["^1E",["@param {...*} var_args"]]],"^K","~$loom.alg/bf-path","^6","loom/alg.cljc","^:",14,"^3?",["^ ","^35",true,"^3@",3,"^38",3,"^32",[["^1E",["~$g","^2[","^49","^5A"]]],"^2Y",["^1E",[["~$g","^2[","^49","~$&","^5A"]]],"^34",["^1E",[null]]],"^32",[["^1E",["~$g","^2[","^49","^5A"]]],"^33",null,"^3@",3,"^34",["^1E",[null]],"^8",1,"^35",true,"^3C",[["^ ","^3@",3,"^35",true,"^3D","^37"]],"^7",122,"^36","^37","^9",122,"^38",3,"^39",true,"^2Y",["^1E",[["~$g","^2[","^49","~$&","^5A"]]],"^;","Returns a path from start to end with the fewest hops (i.e. irrespective\n  of edge weights)","^3A",["^1E",["@param {...*} var_args"]]],"~$bf-path-bi",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",128,"^8",7,"^9",128,"^:",17,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^2[","^49"]]]]],"^;","Using a bidirectional breadth-first search, finds a path from start to\n  end with the fewest hops (i.e. irrespective of edge weights). Can be much\n  faster than a unidirectional search on certain types of graphs"],"^K","~$loom.alg/bf-path-bi","^6","loom/alg.cljc","^:",17,"^32",["^1E",[["~$g","^2[","^49"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",128,"^36","~$ignore","^9",128,"^38",3,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^2[","^49"]]]]],"^;","Using a bidirectional breadth-first search, finds a path from start to\n  end with the fewest hops (i.e. irrespective of edge weights). Can be much\n  faster than a unidirectional search on certain types of graphs"],"~$dijkstra-traverse",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^:",24,"^3?",["^ ","^35",false,"^3@",3,"^38",3,"^32",["^1E",[["~$g"],["~$g","^2["],["~$g","^2[","~$f"]]],"^2Y",["^1E",[["~$g"],["~$g","^2["],["~$g","^2[","~$f"]]],"^34",["^1E",[null,null,null]]],"^8",7,"^7",137,"^9",137,"^2Y",["^1E",["^2Z",["^1E",[["~$g"],["~$g","^2["],["~$g","^2[","~$f"]]]]],"^;","Returns a lazy-seq of [current-node state] where state is a map in\n  the format {node [distance predecessor]}. When f is provided,\n  returns a lazy-seq of (f node state) for each node","^3A",["^1E",["@param {...*} var_args"]]],"^K","~$loom.alg/dijkstra-traverse","^6","loom/alg.cljc","^:",24,"^3?",["^ ","^35",false,"^3@",3,"^38",3,"^32",["^1E",[["~$g"],["~$g","^2["],["~$g","^2[","~$f"]]],"^2Y",["^1E",[["~$g"],["~$g","^2["],["~$g","^2[","~$f"]]],"^34",["^1E",[null,null,null]]],"^32",["^1E",[["~$g"],["~$g","^2["],["~$g","^2[","~$f"]]],"^33",null,"^3@",3,"^34",["^1E",[null,null,null]],"^8",1,"^35",false,"^3C",[["^ ","^3@",1,"^35",false,"^3D","^37"],["^ ","^3@",2,"^35",false,"^3D","^37"],["^ ","^3@",3,"^35",false,"^3D","^37"]],"^7",137,"^9",137,"^38",3,"^39",true,"^2Y",["^1E",[["~$g"],["~$g","^2["],["~$g","^2[","~$f"]]],"^;","Returns a lazy-seq of [current-node state] where state is a map in\n  the format {node [distance predecessor]}. When f is provided,\n  returns a lazy-seq of (f node state) for each node","^3A",["^1E",["@param {...*} var_args"]]],"~$astar-path",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^:",17,"^3?",["^ ","^35",false,"^3@",6,"^38",6,"^32",["^1E",[["~$g","^3V","^3W","^3X"],["~$g","^3V","^3W","^3X","~$q","~$explored"]]],"^2Y",["^1E",[["~$g","^3V","^3W","^3X"],["~$g","^3V","^3W","^3X","~$q","^5I"]]],"^34",["^1E",[null,null]]],"^8",7,"^7",598,"^9",598,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^3V","^3W","^3X"],["~$g","^3V","^3W","^3X","~$q","^5I"]]]]],"^;","Returns the shortest path using A* algorithm. Returns a map of predecessors.","^3A",["^1E",["@param {...*} var_args"]]],"^K","~$loom.alg/astar-path","^6","loom/alg.cljc","^:",17,"^3?",["^ ","^35",false,"^3@",6,"^38",6,"^32",["^1E",[["~$g","^3V","^3W","^3X"],["~$g","^3V","^3W","^3X","~$q","^5I"]]],"^2Y",["^1E",[["~$g","^3V","^3W","^3X"],["~$g","^3V","^3W","^3X","~$q","^5I"]]],"^34",["^1E",[null,null]]],"^32",["^1E",[["~$g","^3V","^3W","^3X"],["~$g","^3V","^3W","^3X","~$q","^5I"]]],"^33",null,"^3@",6,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^3C",[["^ ","^3@",4,"^35",false,"^3D","^37"],["^ ","^3@",6,"^35",false,"^3D",["^J",["^3<","^37"]]]],"^7",598,"^9",598,"^38",6,"^39",true,"^2Y",["^1E",[["~$g","^3V","^3W","^3X"],["~$g","^3V","^3W","^3X","~$q","^5I"]]],"^;","Returns the shortest path using A* algorithm. Returns a map of predecessors.","^3A",["^1E",["@param {...*} var_args"]]],"~$max-flow",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^:",15,"^3?",["^ ","^35",true,"^3@",3,"^38",3,"^32",[["^1E",["~$g","~$source","~$sink",["^ ","^3N",["~$method"],"^3P",["^ ","^5N","~:edmonds-karp"]]]]],"^2Y",["^1E",[["~$g","^5L","^5M","~$&",["^ ","^3N",["^5N"],"^3P",["^ ","^5N","^5O"]]]]],"^34",["^1E",[null]]],"^8",7,"^7",517,"^9",517,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^5L","^5M","~$&",["^ ","^3N",["^5N"],"^3P",["^ ","^5N","^5O"]]]]]]],"^;","Returns [flow-map flow-value], where flow-map is a weighted adjacency map\n   representing the maximum flow.  The argument should be a weighted digraph,\n   where the edge weights are flow capacities.  Source and sink are the vertices\n   representing the flow source and sink vertices.  Optionally, pass in\n     :method :algorithm to use.  Currently, the only option is :edmonds-karp .","^3A",["^1E",["@param {...*} var_args"]]],"^K","~$loom.alg/max-flow","^6","loom/alg.cljc","^:",15,"^3?",["^ ","^35",true,"^3@",3,"^38",3,"^32",[["^1E",["~$g","^5L","^5M",["^ ","^3N",["^5N"],"^3P",["^ ","^5N","^5O"]]]]],"^2Y",["^1E",[["~$g","^5L","^5M","~$&",["^ ","^3N",["^5N"],"^3P",["^ ","^5N","^5O"]]]]],"^34",["^1E",[null]]],"^32",[["^1E",["~$g","^5L","^5M",["^ ","^3N",["^5N"],"^3P",["^ ","^5N","^5O"]]]]],"^33",null,"^3@",3,"^34",["^1E",[null]],"^8",1,"^35",true,"^3C",[["^ ","^3@",3,"^35",true,"^3D","^3="]],"^7",517,"^36","^37","^9",517,"^38",3,"^39",true,"^2Y",["^1E",[["~$g","^5L","^5M","~$&",["^ ","^3N",["^5N"],"^3P",["^ ","^5N","^5O"]]]]],"^;","Returns [flow-map flow-value], where flow-map is a weighted adjacency map\n   representing the maximum flow.  The argument should be a weighted digraph,\n   where the edge weights are flow capacities.  Source and sink are the vertices\n   representing the flow source and sink vertices.  Optionally, pass in\n     :method :algorithm to use.  Currently, the only option is :edmonds-karp .","^3A",["^1E",["@param {...*} var_args"]]],"~$connect",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",388,"^8",7,"^9",388,"^:",14,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns graph g with all connected components connected to each other"],"^K","~$loom.alg/connect","^6","loom/alg.cljc","^:",14,"^32",["^1E",[["~$g"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",388,"^36",["^J",[null,"^37"]],"^9",388,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Returns graph g with all connected components connected to each other"],"~$coloring?",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",486,"^8",7,"^9",486,"^:",16,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^4J"]]]]],"^;","Returns true if a map of nodes to colors is a proper coloring of a graph."],"^K","~$loom.alg/coloring?","^6","loom/alg.cljc","^:",16,"^32",["^1E",[["~$g","^4J"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",486,"^9",486,"^38",2,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^4J"]]]]],"^;","Returns true if a map of nodes to colors is a proper coloring of a graph."],"~$can-relax-edge?",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",169,"^8",8,"^9",169,"^:",23,"^2X",true,"^2Y",["^1E",["^2Z",["^1E",[[["~$u","~$v","^1G","^5:"],"^1@","^5;"]]]]],"^;","Tests for whether we can improve the shortest path to v found so far\n   by going through u."],"^2X",true,"^K","~$loom.alg/can-relax-edge?","^6","loom/alg.cljc","^:",23,"^32",["^1E",[["~$p__30127","^1@","^5;"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",169,"^36","^3L","^9",169,"^38",3,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[[["~$u","~$v","^1G","^5:"],"^1@","^5;"]]]]],"^;","Tests for whether we can improve the shortest path to v found so far\n   by going through u."],"~$bipartite-color",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",426,"^8",7,"^9",426,"^:",22,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Attempts a two-coloring of graph g. When successful, returns a map of\n  nodes to colors (1 or 0). Otherwise, returns nil."],"^K","~$loom.alg/bipartite-color","^6","loom/alg.cljc","^:",22,"^32",["^1E",[["~$g"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",426,"^9",426,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Attempts a two-coloring of graph g. When successful, returns a map of\n  nodes to colors (1 or 0). Otherwise, returns nil."],"~$prim-mst",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",587,"^8",7,"^9",587,"^:",15,"^2Y",["^1E",["^2Z",["^1E",[["^4Q"]]]]],"^;","Minimum spanning tree of given graph. If the graph contains more than one\n   component then returns a spanning forest of minimum spanning trees."],"^K","~$loom.alg/prim-mst","^6","loom/alg.cljc","^:",15,"^32",["^1E",[["^4Q"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",587,"^36","^37","^9",587,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["^4Q"]]]]],"^;","Minimum spanning tree of given graph. If the graph contains more than one\n   component then returns a spanning forest of minimum spanning trees."],"~$dijkstra-span",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^:",20,"^3?",["^ ","^35",false,"^3@",2,"^38",2,"^32",["^1E",[["~$g"],["~$g","^2["]]],"^2Y",["^1E",[["~$g"],["~$g","^2["]]],"^34",["^1E",[null,null]]],"^8",7,"^7",149,"^9",149,"^2Y",["^1E",["^2Z",["^1E",[["~$g"],["~$g","^2["]]]]],"^;","Finds all shortest distances from start. Returns a map in the\n  format {node {successor distance}}","^3A",["^1E",["@param {...*} var_args"]]],"^K","~$loom.alg/dijkstra-span","^6","loom/alg.cljc","^:",20,"^3?",["^ ","^35",false,"^3@",2,"^38",2,"^32",["^1E",[["~$g"],["~$g","^2["]]],"^2Y",["^1E",[["~$g"],["~$g","^2["]]],"^34",["^1E",[null,null]]],"^32",["^1E",[["~$g"],["~$g","^2["]]],"^33",null,"^3@",2,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^3C",[["^ ","^3@",1,"^35",false,"^3D",["^J",[null,"^37"]]],["^ ","^3@",2,"^35",false,"^3D",["^J",[null,"^37"]]]],"^7",149,"^9",149,"^38",2,"^39",true,"^2Y",["^1E",[["~$g"],["~$g","^2["]]],"^;","Finds all shortest distances from start. Returns a map in the\n  format {node {successor distance}}","^3A",["^1E",["@param {...*} var_args"]]],"~$all-pairs-shortest-paths",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",332,"^8",7,"^9",332,"^:",31,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Finds all-pairs shortest paths in a graph. Uses Johnson's algorithm for weighted graphs\n  which is efficient for sparse graphs. Breadth-first spans are used for unweighted graphs."],"^K","~$loom.alg/all-pairs-shortest-paths","^6","loom/alg.cljc","^:",31,"^32",["^1E",[["~$g"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",332,"^36",["^J",[null,"^3L","^37"]],"^9",332,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]],"^;","Finds all-pairs shortest paths in a graph. Uses Johnson's algorithm for weighted graphs\n  which is efficient for sparse graphs. Breadth-first spans are used for unweighted graphs."],"~$isomorphism?",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",784,"^8",7,"^9",784,"^:",19,"^2Y",["^1E",["^2Z",["^1E",[["^3I","^3J","~$phi"]]]]],"^;","Given a mapping phi between the vertices of two graphs, determine\n  if the mapping is an isomorphism, e.g., {(phi x), (phi y)} connected\n  in g2 iff {x, y} are connected in g1."],"^K","~$loom.alg/isomorphism?","^6","loom/alg.cljc","^:",19,"^32",["^1E",[["^3I","^3J","^65"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",784,"^36","^3L","^9",784,"^38",3,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["^3I","^3J","^65"]]]]],"^;","Given a mapping phi between the vertices of two graphs, determine\n  if the mapping is an isomorphism, e.g., {(phi x), (phi y)} connected\n  in g2 iff {x, y} are connected in g1."],"~$edge-weights",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",543,"^8",8,"^9",543,"^:",20,"^2X",true,"^2Y",["^1E",["^2Z",["^1E",[["^4Q","~$v"]]]]],"^;","Wrapper function to return edges along with weights for a given graph.\n   For un-weighted graphs a default value of one is produced. The function\n   returns values of the form [[[u v] 10] [[x y] 20] ...]"],"^2X",true,"^K","~$loom.alg/edge-weights","^6","loom/alg.cljc","^:",20,"^32",["^1E",[["^4Q","~$v"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",543,"^36","^4A","^9",543,"^38",2,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["^4Q","~$v"]]]]],"^;","Wrapper function to return edges along with weights for a given graph.\n   For un-weighted graphs a default value of one is produced. The function\n   returns values of the form [[[u v] 10] [[x y] 20] ...]"],"~$strongly-connected?",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",384,"^8",7,"^9",384,"^:",26,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]]],"^K","~$loom.alg/strongly-connected?","^6","loom/alg.cljc","^:",26,"^32",["^1E",[["~$g"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",384,"^36","^3L","^9",384,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g"]]]]]],"~$bellman-ford-transform",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",286,"^8",8,"^9",286,"^:",30,"^2X",true,"^2Y",["^1E",["^2Z",["^1E",[["^4Q"]]]]],"^;","Helper function for Johnson's algorithm. Uses Bellman-Ford to remove negative weights."],"^2X",true,"^K","~$loom.alg/bellman-ford-transform","^6","loom/alg.cljc","^:",30,"^32",["^1E",[["^4Q"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",286,"^36",["^J",["^3L","^37"]],"^9",286,"^38",1,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["^4Q"]]]]],"^;","Helper function for Johnson's algorithm. Uses Bellman-Ford to remove negative weights."],"~$pre-traverse",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^:",19,"^3?",["^ ","^35",false,"^3@",2,"^38",2,"^32",["^1E",[["~$g"],["~$g","^2["]]],"^2Y",["^1E",[["~$g"],["~$g","^2["]]],"^34",["^1E",[null,null]]],"^8",7,"^7",32,"^9",32,"^2Y",["^1E",["^2Z",["^1E",[["~$g"],["~$g","^2["]]]]],"^;","Traverses graph g depth-first from start. Returns a lazy seq of nodes.\n  When no starting node is provided, traverses the entire graph, connected\n  or not.","^3A",["^1E",["@param {...*} var_args"]]],"^K","~$loom.alg/pre-traverse","^6","loom/alg.cljc","^:",19,"^3?",["^ ","^35",false,"^3@",2,"^38",2,"^32",["^1E",[["~$g"],["~$g","^2["]]],"^2Y",["^1E",[["~$g"],["~$g","^2["]]],"^34",["^1E",[null,null]]],"^32",["^1E",[["~$g"],["~$g","^2["]]],"^33",null,"^3@",2,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^3C",[["^ ","^3@",1,"^35",false,"^3D","^3<"],["^ ","^3@",2,"^35",false,"^3D","^37"]],"^7",32,"^9",32,"^38",2,"^39",true,"^2Y",["^1E",[["~$g"],["~$g","^2["]]],"^;","Traverses graph g depth-first from start. Returns a lazy seq of nodes.\n  When no starting node is provided, traverses the entire graph, connected\n  or not.","^3A",["^1E",["@param {...*} var_args"]]],"~$bf-span",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^:",14,"^3?",["^ ","^35",false,"^3@",2,"^38",2,"^32",["^1E",[["~$g"],["~$g","^2["]]],"^2Y",["^1E",[["~$g"],["~$g","^2["]]],"^34",["^1E",[null,null]]],"^8",7,"^7",106,"^9",106,"^2Y",["^1E",["^2Z",["^1E",[["~$g"],["~$g","^2["]]]]],"^;","Returns a breadth-first spanning tree of the form {node [successors]}","^3A",["^1E",["@param {...*} var_args"]]],"^K","~$loom.alg/bf-span","^6","loom/alg.cljc","^:",14,"^3?",["^ ","^35",false,"^3@",2,"^38",2,"^32",["^1E",[["~$g"],["~$g","^2["]]],"^2Y",["^1E",[["~$g"],["~$g","^2["]]],"^34",["^1E",[null,null]]],"^32",["^1E",[["~$g"],["~$g","^2["]]],"^33",null,"^3@",2,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^3C",[["^ ","^3@",1,"^35",false,"^3D",["^J",[null,"^37"]]],["^ ","^3@",2,"^35",false,"^3D",["^J",[null,"^37"]]]],"^7",106,"^9",106,"^38",2,"^39",true,"^2Y",["^1E",[["~$g"],["~$g","^2["]]],"^;","Returns a breadth-first spanning tree of the form {node [successors]}","^3A",["^1E",["@param {...*} var_args"]]],"~$bf-traverse",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^:",18,"^3?",["^ ","^35",true,"^3@",2,"^38",2,"^32",["^1E",[["~$g"],["~$g","^2["]]],"^2Y",["^1E",[["~$g"],["~$g","^2["],["~$g","^2[","~$&","^5A"]]],"^34",["^1E",[null,null,null]]],"^8",7,"^7",83,"^9",83,"^2Y",["^1E",["^2Z",["^1E",[["~$g"],["~$g","^2["],["~$g","^2[","~$&","^5A"]]]]],"^;","Traverses graph g breadth-first from start. When option :f is provided,\n  returns a lazy seq of (f node predecessor-map depth) for each node traversed.\n  Otherwise, returns a lazy seq of the nodes. When option :when is provided,\n  filters successors with (f neighbor predecessor depth).","^3A",["^1E",["@param {...*} var_args"]]],"^K","~$loom.alg/bf-traverse","^6","loom/alg.cljc","^:",18,"^3?",["^ ","^35",true,"^3@",2,"^38",2,"^32",["^1E",[["~$g"],["~$g","^2["]]],"^2Y",["^1E",[["~$g"],["~$g","^2["],["~$g","^2[","~$&","^5A"]]],"^34",["^1E",[null,null,null]]],"^32",["^1E",[["~$g"],["~$g","^2["]]],"^33",null,"^3@",2,"^34",["^1E",[null,null,null]],"^8",1,"^35",true,"^3C",[["^ ","^3@",1,"^35",false,"^3D",["^J",["^37","^3E"]]],["^ ","^3@",2,"^35",false,"^3D","^37"],["^ ","^3@",2,"^35",true,"^3D","^37"]],"^7",83,"^9",83,"^38",2,"^39",true,"^2Y",["^1E",[["~$g"],["~$g","^2["],["~$g","^2[","~$&","^5A"]]],"^;","Traverses graph g breadth-first from start. When option :f is provided,\n  returns a lazy seq of (f node predecessor-map depth) for each node traversed.\n  Otherwise, returns a lazy seq of the nodes. When option :when is provided,\n  filters successors with (f neighbor predecessor depth).","^3A",["^1E",["@param {...*} var_args"]]],"~$post-traverse",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^:",20,"^3?",["^ ","^35",true,"^3@",2,"^38",2,"^32",["^1E",[["~$g"]]],"^2Y",["^1E",[["~$g"],["~$g","^2[","~$&","^5A"]]],"^34",["^1E",[null,null]]],"^8",7,"^7",58,"^9",58,"^2Y",["^1E",["^2Z",["^1E",[["~$g"],["~$g","^2[","~$&","^5A"]]]]],"^;","Traverses graph g depth-first, post-order from start. Returns a\n  vector of the nodes.","^3A",["^1E",["@param {...*} var_args"]]],"^K","~$loom.alg/post-traverse","^6","loom/alg.cljc","^:",20,"^3?",["^ ","^35",true,"^3@",2,"^38",2,"^32",["^1E",[["~$g"]]],"^2Y",["^1E",[["~$g"],["~$g","^2[","~$&","^5A"]]],"^34",["^1E",[null,null]]],"^32",["^1E",[["~$g"]]],"^33",null,"^3@",2,"^34",["^1E",[null,null]],"^8",1,"^35",true,"^3C",[["^ ","^3@",1,"^35",false,"^3D","^3<"],["^ ","^3@",2,"^35",true,"^3D","^37"]],"^7",58,"^9",58,"^38",2,"^39",true,"^2Y",["^1E",[["~$g"],["~$g","^2[","~$&","^5A"]]],"^;","Traverses graph g depth-first, post-order from start. Returns a\n  vector of the nodes.","^3A",["^1E",["@param {...*} var_args"]]],"~$topsort",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^:",14,"^3?",["^ ","^35",false,"^3@",2,"^38",2,"^32",["^1E",[["~$g"],["~$g","^2["]]],"^2Y",["^1E",[["~$g"],["~$g","^2["]]],"^34",["^1E",[null,null]]],"^8",7,"^7",66,"^9",66,"^2Y",["^1E",["^2Z",["^1E",[["~$g"],["~$g","^2["]]]]],"^;","Topological sort of a directed acyclic graph (DAG). Returns nil if\n  g contains any cycles.","^3A",["^1E",["@param {...*} var_args"]]],"^K","~$loom.alg/topsort","^6","loom/alg.cljc","^:",14,"^3?",["^ ","^35",false,"^3@",2,"^38",2,"^32",["^1E",[["~$g"],["~$g","^2["]]],"^2Y",["^1E",[["~$g"],["~$g","^2["]]],"^34",["^1E",[null,null]]],"^32",["^1E",[["~$g"],["~$g","^2["]]],"^33",null,"^3@",2,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^3C",[["^ ","^3@",1,"^35",false,"^3D",["^J",["^4G","^4A","^3E"]]],["^ ","^3@",2,"^35",false,"^3D","^37"]],"^7",66,"^9",66,"^38",2,"^39",true,"^2Y",["^1E",[["~$g"],["~$g","^2["]]],"^;","Topological sort of a directed acyclic graph (DAG). Returns nil if\n  g contains any cycles.","^3A",["^1E",["@param {...*} var_args"]]],"~$eql?",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",778,"^8",7,"^9",778,"^:",11,"^2Y",["^1E",["^2Z",["^1E",[["^3I","^3J"]]]]],"^;","Returns true iff g1 is a subgraph of g2 and g2 is a subgraph of g1"],"^K","~$loom.alg/eql?","^6","loom/alg.cljc","^:",11,"^32",["^1E",[["^3I","^3J"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",778,"^36","^3L","^9",778,"^38",2,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["^3I","^3J"]]]]],"^;","Returns true iff g1 is a subgraph of g2 and g2 is a subgraph of g1"],"~$dijkstra-path",["^ ","^2W",null,"^5",["^ ","^6","loom/alg.cljc","^7",164,"^8",7,"^9",164,"^:",20,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^2[","^49"]]]]],"^;","Finds the shortest path from start to end"],"^K","~$loom.alg/dijkstra-path","^6","loom/alg.cljc","^:",20,"^32",["^1E",[["~$g","^2[","^49"]]],"^33",null,"^34",["^1E",[null,null]],"^8",1,"^35",false,"^7",164,"^36",["^J",["^37","^3E"]],"^9",164,"^38",3,"^39",true,"^2Y",["^1E",["^2Z",["^1E",[["~$g","^2[","^49"]]]]],"^;","Finds the shortest path from start to end"]],"^1C",["^ ","^Q","^Q"],"~:cljs.analyzer/constants",["^ ","^11",["^J",["^5O","~:method-set","~:else","~:method","~:loops","^11","~:return-seen","~:f"]],"~:order",["^11","^6P","~:f","^6O","^6N","^5O","^6L","^6M"]],"^1I",["^ ","^12",["^J",[]]],"^1J",["^ "],"^1K",["^T","^Q","^R","^Y","^S","^Z","^V"]],"^N","^L","~:ns-specs",["^ "],"~:ns-speced-vars",[],"~:compiler-options",["^1Y",[["^6T","~:static-fns"],true,["^6T","~:elide-asserts"],true,["^6T","~:optimize-constants"],null,["^6T","^1P"],null,["^6T","~:external-config"],null,["^6T","~:tooling-config"],null,["^6T","~:emit-constants"],null,["^6T","~:load-tests"],false,["^6T","~:infer-externs"],true,["^6T","^1R"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:release",["^6T","~:fn-invoke-direct"],null,["^6T","~:source-map"],"/dev/null"]]]