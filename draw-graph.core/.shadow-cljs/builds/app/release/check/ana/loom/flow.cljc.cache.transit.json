["^ ","~:output",["^ ","~:js","goog.provide('loom.flow');\n/**\n * Computes the residual capacity between nodes v1 and v2. Capacity\n * is a function that takes two nodes, and returns the capacity on the\n * edge between them, if any. Flow is the adjacency map which\n * represents the current flow in the network.\n */\nloom.flow.residual_capacity = (function loom$flow$residual_capacity(capacity,flow,v1,v2){\nreturn ((function (){var or__4131__auto__ = cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(flow,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [v2,v1], null));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (0);\n}\n})() + ((function (){var or__4131__auto__ = (capacity.cljs$core$IFn$_invoke$arity$2 ? capacity.cljs$core$IFn$_invoke$arity$2(v1,v2) : capacity.call(null,v1,v2));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (0);\n}\n})() - (function (){var or__4131__auto__ = cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(flow,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [v1,v2], null));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (0);\n}\n})()));\n});\n/**\n * Given a flow, returns a map of {node (sum(in weight) - sum(out weight))}\n */\nloom.flow.flow_balance = (function loom$flow$flow_balance(flow){\nvar out = cljs.core.PersistentArrayMap.EMPTY;\nvar in$ = cljs.core.PersistentArrayMap.EMPTY;\nvar adj_list = cljs.core.seq(flow);\nwhile(true){\nvar temp__5718__auto__ = cljs.core.first(adj_list);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar vec__29864 = temp__5718__auto__;\nvar node = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__29864,(0),null);\nvar neighbours = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__29864,(1),null);\nvar G__29910 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(out,node,(- cljs.core.reduce.cljs$core$IFn$_invoke$arity$2(cljs.core._PLUS_,cljs.core.vals(neighbours))));\nvar G__29911 = cljs.core.merge_with.cljs$core$IFn$_invoke$arity$variadic(cljs.core._PLUS_,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([in$,neighbours], 0));\nvar G__29912 = cljs.core.next(adj_list);\nout = G__29910;\nin$ = G__29911;\nadj_list = G__29912;\ncontinue;\n} else {\nreturn cljs.core.merge_with.cljs$core$IFn$_invoke$arity$variadic(cljs.core._PLUS_,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([out,in$], 0));\n}\nbreak;\n}\n});\n/**\n * Given a flow, verifies whether at each node the sum of in edge\n * weights is equal to the sum of out edge weights, except at the\n * source and sink. The source should have positive net outflow, the\n * sink negative, and together they should balance.\n */\nloom.flow.satisfies_mass_balance_QMARK_ = (function loom$flow$satisfies_mass_balance_QMARK_(flow,source,sink){\nvar balance = loom.flow.flow_balance(flow);\nreturn ((((function (){var or__4131__auto__ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(balance,source);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (0);\n}\n})() <= (0))) && ((((function (){var or__4131__auto__ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(balance,source);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (0);\n}\n})() + (function (){var or__4131__auto__ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(balance,sink);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (0);\n}\n})()) === (0))) && (cljs.core.every_QMARK_(cljs.core.zero_QMARK_,cljs.core.vals(cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic(balance,source,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([sink], 0))))));\n});\n/**\n * Given a flow map, and a capacity function, verifies that the flow\n * on each edge is <= capacity of that edge.\n */\nloom.flow.satisfies_capacity_constraints_QMARK_ = (function loom$flow$satisfies_capacity_constraints_QMARK_(flow,capacity){\nreturn cljs.core.every_QMARK_((function (p__29870){\nvar vec__29877 = p__29870;\nvar node = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__29877,(0),null);\nvar flow_to_successors = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__29877,(1),null);\nreturn cljs.core.every_QMARK_(((function (vec__29877,node,flow_to_successors){\nreturn (function (p__29880){\nvar vec__29881 = p__29880;\nvar neighbor = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__29881,(0),null);\nvar flow_value = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__29881,(1),null);\nreturn (flow_value <= (capacity.cljs$core$IFn$_invoke$arity$2 ? capacity.cljs$core$IFn$_invoke$arity$2(node,neighbor) : capacity.call(null,node,neighbor)));\n});})(vec__29877,node,flow_to_successors))\n,cljs.core.seq(flow_to_successors));\n}),cljs.core.seq(flow));\n});\n/**\n * Verifies that a flow satisfies capacity and mass balance\n * constraints. Does verify that a flow is maximum.\n */\nloom.flow.is_admissible_flow_QMARK_ = (function loom$flow$is_admissible_flow_QMARK_(flow,capacity,source,sink){\nreturn ((loom.flow.satisfies_mass_balance_QMARK_(flow,source,sink)) && (loom.flow.satisfies_capacity_constraints_QMARK_(flow,capacity)));\n});\n/**\n * Given a path, represented by a sequence of nodes, and\n * weight-function, computes the minimum of the edge weights along the\n * path. If an edge on the path is missing, returns 0.\n */\nloom.flow.min_weight_along_path = (function loom$flow$min_weight_along_path(path,weight_fn){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$2(cljs.core.min,cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__29888_SHARP_){\nvar or__4131__auto__ = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(weight_fn,p1__29888_SHARP_);\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (0);\n}\n}),cljs.core.partition.cljs$core$IFn$_invoke$arity$3((2),(1),path)));\n});\n/**\n * Finds a shortest path in the flow network along which there remains\n * residual capacity. Successors is a function which, given a vertex,\n * returns the vertices connected by outgoing edges. Predecessors,\n * similarly is a function to get vertices connected by incoming\n * edges. Capacity is a function which takes two vertices and returns\n * the capacity between them. Flow is an adjacency map which contains\n * the current value of network flow. s is the source node, t the\n * sink.\n */\nloom.flow.bf_find_augmenting_path = (function loom$flow$bf_find_augmenting_path(successors,predecessors,capacity,flow,s,t){\nreturn loom.alg_generic.bf_path((function (vertex){\nreturn cljs.core.distinct.cljs$core$IFn$_invoke$arity$1(cljs.core.filter.cljs$core$IFn$_invoke$arity$2((function (p1__29889_SHARP_){\nreturn (loom.flow.residual_capacity(capacity,flow,vertex,p1__29889_SHARP_) > (0));\n}),cljs.core.concat.cljs$core$IFn$_invoke$arity$2((successors.cljs$core$IFn$_invoke$arity$1 ? successors.cljs$core$IFn$_invoke$arity$1(vertex) : successors.call(null,vertex)),(predecessors.cljs$core$IFn$_invoke$arity$1 ? predecessors.cljs$core$IFn$_invoke$arity$1(vertex) : predecessors.call(null,vertex)))));\n}),s,t);\n});\n/**\n * Given a flow represented as an adjacency map, returns an updated flow.\n * Capacity is a function of two vertices, path is a sequence of\n * nodes, and increase is the amount by which the flow should be\n * augmented on this path. If at any point the increase exceeds forward\n * capacity, the excess is pushed in the reverse direction. An exception\n * is thrown if the augmentation is impossible given capacity constraints.\n */\nloom.flow.augment_along_path = (function loom$flow$augment_along_path(flow,capacity,path,increase){\nwhile(true){\nvar vn0 = cljs.core.first(path);\nvar vn1 = cljs.core.second(path);\nvar forward_flow = (function (){var or__4131__auto__ = cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(flow,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [vn0,vn1], null));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (0);\n}\n})();\nvar forward_capacity = ((function (){var or__4131__auto__ = (capacity.cljs$core$IFn$_invoke$arity$2 ? capacity.cljs$core$IFn$_invoke$arity$2(vn0,vn1) : capacity.call(null,vn0,vn1));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (0);\n}\n})() - forward_flow);\nvar reverse_flow = (function (){var or__4131__auto__ = cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(flow,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [vn1,vn0], null));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn (0);\n}\n})();\nvar forward_increase = (function (){var x__4222__auto__ = forward_capacity;\nvar y__4223__auto__ = increase;\nreturn ((x__4222__auto__ < y__4223__auto__) ? x__4222__auto__ : y__4223__auto__);\n})();\nvar pushback = (increase - forward_increase);\nvar flow_1 = (((forward_increase > (0)))?cljs.core.assoc_in(flow,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [vn0,vn1], null),(forward_flow + forward_increase)):flow);\nvar flow_2 = (((pushback > (0)))?cljs.core.assoc_in(flow_1,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [vn1,vn0], null),(reverse_flow - pushback)):flow_1);\nif((pushback > reverse_flow)){\nthrow Object([\"Path augmentation failure: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(vn0),\" \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(vn1)].join(''));\n} else {\nif((cljs.core.count(path) > (2))){\nvar G__29925 = flow_2;\nvar G__29926 = capacity;\nvar G__29927 = cljs.core.next(path);\nvar G__29928 = increase;\nflow = G__29925;\ncapacity = G__29926;\npath = G__29927;\nincrease = G__29928;\ncontinue;\n} else {\nreturn flow_2;\n\n}\n}\nbreak;\n}\n});\n/**\n * Computes the maximum flow on a network, using the edmonds-karp algorithm.\n * Successors is a function that returns the outgoing neighbor\n * vertices of a vertex. Predecessors is a function that returns the\n * incoming neighbor vertices for a vertex. Capacity is a function of\n * two vertices that returns the capacity on the edge between them.\n * Source and sink are the unique vertices which supply and consume\n * flow respectively.\n * \n * Returns a vector [flow value], where flow is an adjacency map that\n * represents flows between vertices, and value is the quantity of\n * flow passing from source to sink.\n * @param {...*} var_args\n */\nloom.flow.edmonds_karp = (function loom$flow$edmonds_karp(var_args){\nvar G__29903 = arguments.length;\nswitch (G__29903) {\ncase 5:\nreturn loom.flow.edmonds_karp.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase 6:\nreturn loom.flow.edmonds_karp.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nloom.flow.edmonds_karp.cljs$core$IFn$_invoke$arity$5 = (function (successors,predecessors,capacity,source,sink){\nreturn loom.flow.edmonds_karp.cljs$core$IFn$_invoke$arity$6(successors,predecessors,capacity,source,sink,cljs.core.PersistentArrayMap.EMPTY);\n});\n\nloom.flow.edmonds_karp.cljs$core$IFn$_invoke$arity$6 = (function (successors,predecessors,capacity,source,sink,flow){\nwhile(true){\nvar temp__5718__auto__ = loom.flow.bf_find_augmenting_path(successors,predecessors,capacity,flow,source,sink);\nif(cljs.core.truth_(temp__5718__auto__)){\nvar path = temp__5718__auto__;\nvar G__29930 = successors;\nvar G__29931 = predecessors;\nvar G__29932 = capacity;\nvar G__29933 = source;\nvar G__29934 = sink;\nvar G__29935 = loom.flow.augment_along_path(flow,capacity,path,loom.flow.min_weight_along_path(path,cljs.core.partial.cljs$core$IFn$_invoke$arity$3(loom.flow.residual_capacity,capacity,flow)));\nsuccessors = G__29930;\npredecessors = G__29931;\ncapacity = G__29932;\nsource = G__29933;\nsink = G__29934;\nflow = G__29935;\ncontinue;\n} else {\nvar value = cljs.core.reduce.cljs$core$IFn$_invoke$arity$2(cljs.core._PLUS_,cljs.core.vals(cljs.core.get.cljs$core$IFn$_invoke$arity$2(flow,source)));\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [flow,value], null);\n}\nbreak;\n}\n});\n\nloom.flow.edmonds_karp.cljs$lang$maxFixedArity = 6;\n\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","loom/flow.cljc","~:line",3,"~:column",3,"~:end-line",3,"~:end-column",12,"~:doc","Algorithms for solving network flow","~:author","Robert Lachlan"],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$create-react-class","~$module$node_modules$create_react_class$index","~$react-dom","~$module$node_modules$react_dom$index","~$clojure.spec.alpha","~$cljs.spec.alpha"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$loom.flow","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$loom.alg-generic","^Q","~$gen","^Q","~$cljs.core","^S","~$goog","^T"],"~:seen",["^J",["~:require"]],"~:uses",["^ ","~$bf-path","^Q"],"~:require-macros",["^ ","^S","^S"],"~:form",["~#list",["~$ns","^L",["^[",["^V",["^Q","~:as","^R","~:refer",["^X"]]]]]],"~:flags",["^ ","^V",["^J",[]]],"~:js-deps",["^ "],"~:deps",["^T","^S","^Q"]],"^N","^L","~:resource-id",["~:shadow.build.classpath/resource","loom/flow.cljc"],"~:compiled-at",1560578450646,"~:resource-name","loom/flow.cljc","~:warnings",[],"~:source","(ns ^{:doc \"Algorithms for solving network flow\"\n      :author \"Robert Lachlan\"}\n  loom.flow\n  (:require [loom.alg-generic :as gen :refer [bf-path]]))\n\n\n(defn residual-capacity\n  \"Computes the residual capacity between nodes v1 and v2. Capacity\n   is a function that takes two nodes, and returns the capacity on the\n   edge between them, if any. Flow is the adjacency map which\n   represents the current flow in the network.\"\n  [capacity flow v1 v2]\n  (+\n   (or (get-in flow [v2 v1]) 0)\n   (- (or (capacity v1 v2) 0)\n      (or (get-in flow [v1 v2]) 0))))\n\n(defn flow-balance\n  \"Given a flow, returns a map of {node (sum(in weight) - sum(out weight))}\"\n  [flow]\n  (loop [out {}, in {}, adj-list (seq flow)]\n    (if-let [[node neighbours] (first adj-list)]\n      (recur (assoc out node (- (reduce + (vals neighbours))))\n             (merge-with + in neighbours)\n             (next adj-list))\n      (merge-with + out in))))\n\n(defn satisfies-mass-balance?\n  \"Given a flow, verifies whether at each node the sum of in edge\n   weights is equal to the sum of out edge weights, except at the\n   source and sink. The source should have positive net outflow, the\n   sink negative, and together they should balance.\"\n  [flow source sink]\n  (let [balance (flow-balance flow)]\n    (and (<= (or (get balance source) 0) 0)\n         (zero? (+ (or (get balance source) 0)\n                   (or (get balance sink) 0)))\n         (every? zero? (vals (dissoc balance source sink))))))\n\n(defn satisfies-capacity-constraints?\n  \"Given a flow map, and a capacity function, verifies that the flow\n   on each edge is <= capacity of that edge.\"\n  [flow capacity]\n  (every? (fn [[node flow-to-successors]]\n            (every?\n             (fn [[neighbor flow-value]]\n               (<= flow-value (capacity node neighbor)))\n             (seq flow-to-successors)))\n          (seq flow)))\n\n(defn is-admissible-flow?\n  \"Verifies that a flow satisfies capacity and mass balance\n   constraints. Does verify that a flow is maximum.\"\n  [flow capacity source sink]\n  (and (satisfies-mass-balance? flow source sink)\n       (satisfies-capacity-constraints? flow capacity)))\n\n(defn min-weight-along-path\n  \"Given a path, represented by a sequence of nodes, and\n   weight-function, computes the minimum of the edge weights along the\n   path. If an edge on the path is missing, returns 0.\"\n  [path weight-fn]\n  (reduce min (map #(or (apply weight-fn %) 0)  (partition 2 1 path))))\n\n(defn bf-find-augmenting-path\n  \"Finds a shortest path in the flow network along which there remains\n   residual capacity. Successors is a function which, given a vertex,\n   returns the vertices connected by outgoing edges. Predecessors,\n   similarly is a function to get vertices connected by incoming\n   edges. Capacity is a function which takes two vertices and returns\n   the capacity between them. Flow is an adjacency map which contains\n   the current value of network flow. s is the source node, t the\n   sink.\"\n  [successors predecessors capacity flow s t]\n  (gen/bf-path\n   (fn [vertex]\n     (distinct (filter #(pos? (residual-capacity capacity flow vertex %))\n                       (concat (successors vertex) (predecessors vertex)))))\n   s t))\n\n(defn augment-along-path\n  \"Given a flow represented as an adjacency map, returns an updated flow.\n   Capacity is a function of two vertices, path is a sequence of\n   nodes, and increase is the amount by which the flow should be\n   augmented on this path. If at any point the increase exceeds forward\n   capacity, the excess is pushed in the reverse direction. An exception\n   is thrown if the augmentation is impossible given capacity constraints.\"\n  [flow capacity path increase]\n  (let [vn0 (first path)\n        vn1 (second path)\n        forward-flow (or (get-in flow [vn0 vn1]) 0)\n        forward-capacity (- (or (capacity vn0 vn1) 0) forward-flow)\n        reverse-flow (or (get-in flow [vn1 vn0]) 0)\n        forward-increase (min forward-capacity increase)\n        pushback (- increase forward-increase)\n        flow_1 (if (pos? forward-increase)\n                 (assoc-in flow [vn0 vn1] (+ forward-flow forward-increase))\n                 flow)\n        flow_2 (if (pos? pushback)\n                 (assoc-in flow_1 [vn1 vn0] (- reverse-flow pushback))\n                 flow_1)]\n    (cond (> pushback reverse-flow) (throw\n                                     (#?(:clj java.lang.RuntimeException.\n                                         :cljs js/Object)\n                                      (str \"Path augmentation failure: \"\n                                           vn0 \" \" vn1)))\n          (> (count path) 2) (recur flow_2 capacity (next path) increase)\n          :else flow_2)))\n\n(defn edmonds-karp\n  \"Computes the maximum flow on a network, using the edmonds-karp algorithm.\n   Successors is a function that returns the outgoing neighbor\n   vertices of a vertex. Predecessors is a function that returns the\n   incoming neighbor vertices for a vertex. Capacity is a function of\n   two vertices that returns the capacity on the edge between them.\n   Source and sink are the unique vertices which supply and consume\n   flow respectively.\n\n   Returns a vector [flow value], where flow is an adjacency map that\n   represents flows between vertices, and value is the quantity of\n   flow passing from source to sink.\"\n  ([successors predecessors capacity source sink]\n     (edmonds-karp successors predecessors capacity source sink {}))\n  ([successors predecessors capacity source sink flow]\n     (if-let [path (bf-find-augmenting-path\n                    successors predecessors capacity flow source sink)]\n       (recur successors predecessors capacity source sink\n              (augment-along-path\n               flow capacity path\n               (min-weight-along-path\n                path (partial residual-capacity capacity flow))))\n       (let [value (reduce + (vals (get flow source)))]\n         [flow value]))))\n","~:reader-features",["^J",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["loom.flow/residual-capacity","capacity","flow","v1","v2","or__4131__auto__","cljs.core.get_in.cljs$core$IFn$_invoke$arity$2","loom.flow/flow-balance","out","in","adj-list","cljs.core/seq","temp__5718__auto__","vec__29864","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","node","neighbours","cljs.core/first","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","cljs.core.reduce.cljs$core$IFn$_invoke$arity$2","cljs.core/+","cljs.core/vals","cljs.core.merge_with.cljs$core$IFn$_invoke$arity$variadic","cljs.core/next","loom.flow/satisfies-mass-balance?","source","sink","balance","cljs.core.get.cljs$core$IFn$_invoke$arity$2","cljs.core/every?","cljs.core/zero?","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic","loom.flow/satisfies-capacity-constraints?","p__29870","vec__29877","flow-to-successors","p__29880","vec__29881","neighbor","flow-value","loom.flow/is-admissible-flow?","loom.flow/min-weight-along-path","path","weight-fn","cljs.core/min","p1__29888#","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core.partition.cljs$core$IFn$_invoke$arity$3","loom.flow/bf-find-augmenting-path","successors","predecessors","s","t","loom.alg-generic/bf-path","vertex","cljs.core.distinct.cljs$core$IFn$_invoke$arity$1","p1__29889#","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","loom.flow/augment-along-path","increase","vn0","vn1","cljs.core/second","forward-flow","forward-capacity","reverse-flow","forward-increase","x__4222__auto__","y__4223__auto__","pushback","flow_1","cljs.core/assoc-in","flow_2","js/Object","cljs.core/count","var_args","G__29903","loom.flow/edmonds-karp","js/Error","loom.flow.edmonds_karp.cljs$core$IFn$_invoke$arity$6","cljs.core.partial.cljs$core$IFn$_invoke$arity$3","value"]]],"~:cache-keys",["~#cmap",[["~:macro","^S"],[1559826623000],["^17","goog/math/math.js"],[1560546089000,"~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^J",[]],"~:deps-syms",["^T","~$goog.array","~$goog.asserts"]]],["^17","goog/array/array.js"],[1560546089000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T","^1J"]]],["^17","goog/debug/error.js"],[1560546089000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T"]]],["^17","goog/dom/nodetype.js"],[1560546089000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T"]]],["^17","goog/object/object.js"],[1560546089000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T"]]],"~:SHADOW-TIMESTAMP",[1560546091000,1559826623000],["^17","goog/math/long.js"],[1560546089000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T","^1J","~$goog.reflect"]]],["^17","goog/string/internal.js"],[1560546089000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T"]]],["^17","goog/functions/functions.js"],[1560546089000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T"]]],["^17","goog/structs/map.js"],[1560546089000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^17","goog/asserts/asserts.js"],[1560546089000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^17","goog/uri/uri.js"],[1560546089000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T","^1I","^1J","~$goog.string","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^17","loom/flow.cljc"],[1545217035000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T","^S","^Q"]]],["^17","goog/base.js"],[1560546089000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",[]]],["^17","goog/structs/structs.js"],[1560546089000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T","^1I","~$goog.object"]]],["^17","goog/string/string.js"],[1560546089000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T","~$goog.string.internal"]]],["^17","goog/reflect/reflect.js"],[1560546089000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T"]]],["^17","goog/string/stringbuffer.js"],[1560546089000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T"]]],["^17","goog/iter/iter.js"],[1560546089000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T","^1I","^1J","~$goog.functions","~$goog.math"]]],["^17","loom/alg_generic.cljc"],[1545217035000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T","^S"]]],["^17","cljs/core.cljs"],[1559826623000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["~$goog.math.Long","~$goog.math.Integer","^1Q","^1W","^1I","~$goog.Uri","~$goog.string.StringBuffer"]]],["^17","goog/math/integer.js"],[1560546089000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T"]]],["^17","goog/uri/utils.js"],[1560546089000,"^1E",["^ ","^1F",null,"^1G",["^J",[]],"^1H",["^T","^1I","^1J","^1Q"]]]]],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","loom/flow.cljc","^7",3,"^8",3,"^9",3,"^:",12,"^;","Algorithms for solving network flow","^<","Robert Lachlan"],"^=",["^ ","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G"],"^H",null,"^I",["^J",[]],"^K","^L","^O",null,"^P",["^ ","^Q","^Q","^R","^Q","^S","^S","^T","^T"],"^U",["^J",["^V"]],"~:shadow/js-access-global",["^J",["Object","Error"]],"^W",["^ ","^X","^Q"],"~:defs",["^ ","~$satisfies-mass-balance?",["^ ","~:protocol-inline",null,"^5",["^ ","^6","loom/flow.cljc","^7",28,"^8",7,"^9",28,"^:",30,"~:arglists",["^[",["~$quote",["^[",[["~$flow","~$source","~$sink"]]]]],"^;","Given a flow, verifies whether at each node the sum of in edge\n   weights is equal to the sum of out edge weights, except at the\n   source and sink. The source should have positive net outflow, the\n   sink negative, and together they should balance."],"^K","~$loom.flow/satisfies-mass-balance?","^6","loom/flow.cljc","^:",30,"~:method-params",["^[",[["^2:","^2;","^2<"]]],"~:protocol-impl",null,"~:arglists-meta",["^[",[null,null]],"^8",1,"~:variadic?",false,"^7",28,"~:ret-tag","~$boolean","^9",28,"~:max-fixed-arity",3,"~:fn-var",true,"^28",["^[",["^29",["^[",[["^2:","^2;","^2<"]]]]],"^;","Given a flow, verifies whether at each node the sum of in edge\n   weights is equal to the sum of out edge weights, except at the\n   source and sink. The source should have positive net outflow, the\n   sink negative, and together they should balance."],"~$bf-find-augmenting-path",["^ ","^27",null,"^5",["^ ","^6","loom/flow.cljc","^7",65,"^8",7,"^9",65,"^:",30,"^28",["^[",["^29",["^[",[["~$successors","~$predecessors","~$capacity","^2:","~$s","~$t"]]]]],"^;","Finds a shortest path in the flow network along which there remains\n   residual capacity. Successors is a function which, given a vertex,\n   returns the vertices connected by outgoing edges. Predecessors,\n   similarly is a function to get vertices connected by incoming\n   edges. Capacity is a function which takes two vertices and returns\n   the capacity between them. Flow is an adjacency map which contains\n   the current value of network flow. s is the source node, t the\n   sink."],"^K","~$loom.flow/bf-find-augmenting-path","^6","loom/flow.cljc","^:",30,"^2>",["^[",[["^2G","^2H","^2I","^2:","~$s","~$t"]]],"^2?",null,"^2@",["^[",[null,null]],"^8",1,"^2A",false,"^7",65,"^2B",["^J",[null,"~$seq","~$cljs.core/IList","~$any","~$clj-nil"]],"^9",65,"^2D",6,"^2E",true,"^28",["^[",["^29",["^[",[["^2G","^2H","^2I","^2:","~$s","~$t"]]]]],"^;","Finds a shortest path in the flow network along which there remains\n   residual capacity. Successors is a function which, given a vertex,\n   returns the vertices connected by outgoing edges. Predecessors,\n   similarly is a function to get vertices connected by incoming\n   edges. Capacity is a function which takes two vertices and returns\n   the capacity between them. Flow is an adjacency map which contains\n   the current value of network flow. s is the source node, t the\n   sink."],"~$edmonds-karp",["^ ","^27",null,"^5",["^ ","^6","loom/flow.cljc","^:",19,"~:top-fn",["^ ","^2A",false,"~:fixed-arity",6,"^2D",6,"^2>",["^[",[["^2G","^2H","^2I","^2;","^2<"],["^2G","^2H","^2I","^2;","^2<","^2:"]]],"^28",["^[",[["^2G","^2H","^2I","^2;","^2<"],["^2G","^2H","^2I","^2;","^2<","^2:"]]],"^2@",["^[",[null,null]]],"^8",7,"^7",110,"^9",110,"^28",["^[",["^29",["^[",[["^2G","^2H","^2I","^2;","^2<"],["^2G","^2H","^2I","^2;","^2<","^2:"]]]]],"^;","Computes the maximum flow on a network, using the edmonds-karp algorithm.\n   Successors is a function that returns the outgoing neighbor\n   vertices of a vertex. Predecessors is a function that returns the\n   incoming neighbor vertices for a vertex. Capacity is a function of\n   two vertices that returns the capacity on the edge between them.\n   Source and sink are the unique vertices which supply and consume\n   flow respectively.\n\n   Returns a vector [flow value], where flow is an adjacency map that\n   represents flows between vertices, and value is the quantity of\n   flow passing from source to sink.","~:jsdoc",["^[",["@param {...*} var_args"]]],"^K","~$loom.flow/edmonds-karp","^6","loom/flow.cljc","^:",19,"^2P",["^ ","^2A",false,"^2Q",6,"^2D",6,"^2>",["^[",[["^2G","^2H","^2I","^2;","^2<"],["^2G","^2H","^2I","^2;","^2<","^2:"]]],"^28",["^[",[["^2G","^2H","^2I","^2;","^2<"],["^2G","^2H","^2I","^2;","^2<","^2:"]]],"^2@",["^[",[null,null]]],"^2>",["^[",[["^2G","^2H","^2I","^2;","^2<"],["^2G","^2H","^2I","^2;","^2<","^2:"]]],"^2?",null,"^2Q",6,"^2@",["^[",[null,null]],"^8",1,"^2A",false,"~:methods",[["^ ","^2Q",5,"^2A",false,"~:tag","^2M"],["^ ","^2Q",6,"^2A",false,"^2U","~$cljs.core/IVector"]],"^7",110,"^9",110,"^2D",6,"^2E",true,"^28",["^[",[["^2G","^2H","^2I","^2;","^2<"],["^2G","^2H","^2I","^2;","^2<","^2:"]]],"^;","Computes the maximum flow on a network, using the edmonds-karp algorithm.\n   Successors is a function that returns the outgoing neighbor\n   vertices of a vertex. Predecessors is a function that returns the\n   incoming neighbor vertices for a vertex. Capacity is a function of\n   two vertices that returns the capacity on the edge between them.\n   Source and sink are the unique vertices which supply and consume\n   flow respectively.\n\n   Returns a vector [flow value], where flow is an adjacency map that\n   represents flows between vertices, and value is the quantity of\n   flow passing from source to sink.","^2R",["^[",["@param {...*} var_args"]]],"~$residual-capacity",["^ ","^27",null,"^5",["^ ","^6","loom/flow.cljc","^7",7,"^8",7,"^9",7,"^:",24,"^28",["^[",["^29",["^[",[["^2I","^2:","~$v1","~$v2"]]]]],"^;","Computes the residual capacity between nodes v1 and v2. Capacity\n   is a function that takes two nodes, and returns the capacity on the\n   edge between them, if any. Flow is the adjacency map which\n   represents the current flow in the network."],"^K","~$loom.flow/residual-capacity","^6","loom/flow.cljc","^:",24,"^2>",["^[",[["^2I","^2:","^2X","^2Y"]]],"^2?",null,"^2@",["^[",[null,null]],"^8",1,"^2A",false,"^7",7,"^2B","~$number","^9",7,"^2D",4,"^2E",true,"^28",["^[",["^29",["^[",[["^2I","^2:","^2X","^2Y"]]]]],"^;","Computes the residual capacity between nodes v1 and v2. Capacity\n   is a function that takes two nodes, and returns the capacity on the\n   edge between them, if any. Flow is the adjacency map which\n   represents the current flow in the network."],"~$augment-along-path",["^ ","^27",null,"^5",["^ ","^6","loom/flow.cljc","^7",81,"^8",7,"^9",81,"^:",25,"^28",["^[",["^29",["^[",[["^2:","^2I","~$path","~$increase"]]]]],"^;","Given a flow represented as an adjacency map, returns an updated flow.\n   Capacity is a function of two vertices, path is a sequence of\n   nodes, and increase is the amount by which the flow should be\n   augmented on this path. If at any point the increase exceeds forward\n   capacity, the excess is pushed in the reverse direction. An exception\n   is thrown if the augmentation is impossible given capacity constraints."],"^K","~$loom.flow/augment-along-path","^6","loom/flow.cljc","^:",25,"^2>",["^[",[["^2:","^2I","^31","^32"]]],"^2?",null,"^2@",["^[",[null,null]],"^8",1,"^2A",false,"^7",81,"^2B",["^J",[null,"~$clj","^2M"]],"^9",81,"^2D",4,"^2E",true,"^28",["^[",["^29",["^[",[["^2:","^2I","^31","^32"]]]]],"^;","Given a flow represented as an adjacency map, returns an updated flow.\n   Capacity is a function of two vertices, path is a sequence of\n   nodes, and increase is the amount by which the flow should be\n   augmented on this path. If at any point the increase exceeds forward\n   capacity, the excess is pushed in the reverse direction. An exception\n   is thrown if the augmentation is impossible given capacity constraints."],"~$is-admissible-flow?",["^ ","^27",null,"^5",["^ ","^6","loom/flow.cljc","^7",51,"^8",7,"^9",51,"^:",26,"^28",["^[",["^29",["^[",[["^2:","^2I","^2;","^2<"]]]]],"^;","Verifies that a flow satisfies capacity and mass balance\n   constraints. Does verify that a flow is maximum."],"^K","~$loom.flow/is-admissible-flow?","^6","loom/flow.cljc","^:",26,"^2>",["^[",[["^2:","^2I","^2;","^2<"]]],"^2?",null,"^2@",["^[",[null,null]],"^8",1,"^2A",false,"^7",51,"^2B","^2C","^9",51,"^2D",4,"^2E",true,"^28",["^[",["^29",["^[",[["^2:","^2I","^2;","^2<"]]]]],"^;","Verifies that a flow satisfies capacity and mass balance\n   constraints. Does verify that a flow is maximum."],"~$min-weight-along-path",["^ ","^27",null,"^5",["^ ","^6","loom/flow.cljc","^7",58,"^8",7,"^9",58,"^:",28,"^28",["^[",["^29",["^[",[["^31","~$weight-fn"]]]]],"^;","Given a path, represented by a sequence of nodes, and\n   weight-function, computes the minimum of the edge weights along the\n   path. If an edge on the path is missing, returns 0."],"^K","~$loom.flow/min-weight-along-path","^6","loom/flow.cljc","^:",28,"^2>",["^[",[["^31","^38"]]],"^2?",null,"^2@",["^[",[null,null]],"^8",1,"^2A",false,"^7",58,"^2B","^2M","^9",58,"^2D",2,"^2E",true,"^28",["^[",["^29",["^[",[["^31","^38"]]]]],"^;","Given a path, represented by a sequence of nodes, and\n   weight-function, computes the minimum of the edge weights along the\n   path. If an edge on the path is missing, returns 0."],"~$flow-balance",["^ ","^27",null,"^5",["^ ","^6","loom/flow.cljc","^7",18,"^8",7,"^9",18,"^:",19,"^28",["^[",["^29",["^[",[["^2:"]]]]],"^;","Given a flow, returns a map of {node (sum(in weight) - sum(out weight))}"],"^K","~$loom.flow/flow-balance","^6","loom/flow.cljc","^:",19,"^2>",["^[",[["^2:"]]],"^2?",null,"^2@",["^[",[null,null]],"^8",1,"^2A",false,"^7",18,"^2B",["^J",["^2M","^2N"]],"^9",18,"^2D",1,"^2E",true,"^28",["^[",["^29",["^[",[["^2:"]]]]],"^;","Given a flow, returns a map of {node (sum(in weight) - sum(out weight))}"],"~$satisfies-capacity-constraints?",["^ ","^27",null,"^5",["^ ","^6","loom/flow.cljc","^7",40,"^8",7,"^9",40,"^:",38,"^28",["^[",["^29",["^[",[["^2:","^2I"]]]]],"^;","Given a flow map, and a capacity function, verifies that the flow\n   on each edge is <= capacity of that edge."],"^K","~$loom.flow/satisfies-capacity-constraints?","^6","loom/flow.cljc","^:",38,"^2>",["^[",[["^2:","^2I"]]],"^2?",null,"^2@",["^[",[null,null]],"^8",1,"^2A",false,"^7",40,"^2B","^2C","^9",40,"^2D",2,"^2E",true,"^28",["^[",["^29",["^[",[["^2:","^2I"]]]]],"^;","Given a flow map, and a capacity function, verifies that the flow\n   on each edge is <= capacity of that edge."]],"^Y",["^ ","^S","^S"],"~:cljs.analyzer/constants",["^ ","^U",["^J",["~:else"]],"~:order",["^3?"]],"^13",["^ ","^V",["^J",[]]],"^14",["^ "],"^15",["^T","^S","^Q"]],"^N","^L","~:ns-specs",["^ "],"~:ns-speced-vars",[],"~:compiler-options",["^1C",[["^3C","~:static-fns"],true,["^3C","~:elide-asserts"],true,["^3C","~:optimize-constants"],null,["^3C","^1:"],null,["^3C","~:external-config"],null,["^3C","~:tooling-config"],null,["^3C","~:emit-constants"],null,["^3C","~:load-tests"],false,["^3C","~:infer-externs"],true,["^3C","^1<"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:release",["^3C","~:fn-invoke-direct"],null,["^3C","~:source-map"],"/dev/null"]]]