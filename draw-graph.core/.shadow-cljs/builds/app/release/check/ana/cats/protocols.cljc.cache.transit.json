["^ ","~:output",["^ ","~:js","goog.provide('cats.protocols');\n\n/**\n * A marker protocol for identifying the valid context types.\n * @interface\n */\ncats.protocols.Context = function(){};\n\n\n/**\n * Abstraction that establishes a concrete type as a member of a context.\n * \n *   A great example is the Maybe monad type Just. It implements\n *   this abstraction to establish that Just is part of\n *   the Maybe monad.\n * @interface\n */\ncats.protocols.Contextual = function(){};\n\n/**\n * Get the context associated with the type.\n */\ncats.protocols._get_context = (function cats$protocols$_get_context(_){\nif((((!((_ == null)))) && ((!((_.cats$protocols$Contextual$_get_context$arity$1 == null)))))){\nreturn _.cats$protocols$Contextual$_get_context$arity$1(_);\n} else {\nvar x__4433__auto__ = (((_ == null))?null:_);\nvar m__4434__auto__ = (cats.protocols._get_context[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(_) : m__4434__auto__.call(null,_));\n} else {\nvar m__4431__auto__ = (cats.protocols._get_context[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(_) : m__4431__auto__.call(null,_));\n} else {\nthrow cljs.core.missing_protocol(\"Contextual.-get-context\",_);\n}\n}\n}\n});\n\n\n/**\n * An abstraction to make a type printable in a platform\n *   independent manner.\n * @interface\n */\ncats.protocols.Printable = function(){};\n\n/**\n * Get the repl ready representation of the object.\n */\ncats.protocols._repr = (function cats$protocols$_repr(_){\nif((((!((_ == null)))) && ((!((_.cats$protocols$Printable$_repr$arity$1 == null)))))){\nreturn _.cats$protocols$Printable$_repr$arity$1(_);\n} else {\nvar x__4433__auto__ = (((_ == null))?null:_);\nvar m__4434__auto__ = (cats.protocols._repr[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(_) : m__4434__auto__.call(null,_));\n} else {\nvar m__4431__auto__ = (cats.protocols._repr[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(_) : m__4431__auto__.call(null,_));\n} else {\nthrow cljs.core.missing_protocol(\"Printable.-repr\",_);\n}\n}\n}\n});\n\n\n/**\n * A structure with an associative binary operation.\n * @interface\n */\ncats.protocols.Semigroup = function(){};\n\n/**\n * An associative addition operation.\n */\ncats.protocols._mappend = (function cats$protocols$_mappend(s,sv,sv_SINGLEQUOTE_){\nif((((!((s == null)))) && ((!((s.cats$protocols$Semigroup$_mappend$arity$3 == null)))))){\nreturn s.cats$protocols$Semigroup$_mappend$arity$3(s,sv,sv_SINGLEQUOTE_);\n} else {\nvar x__4433__auto__ = (((s == null))?null:s);\nvar m__4434__auto__ = (cats.protocols._mappend[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(s,sv,sv_SINGLEQUOTE_) : m__4434__auto__.call(null,s,sv,sv_SINGLEQUOTE_));\n} else {\nvar m__4431__auto__ = (cats.protocols._mappend[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(s,sv,sv_SINGLEQUOTE_) : m__4431__auto__.call(null,s,sv,sv_SINGLEQUOTE_));\n} else {\nthrow cljs.core.missing_protocol(\"Semigroup.-mappend\",s);\n}\n}\n}\n});\n\n\n/**\n * A Semigroup which has an identity element with respect to an associative binary operation.\n * @interface\n */\ncats.protocols.Monoid = function(){};\n\n/**\n * The identity element for the given monoid.\n */\ncats.protocols._mempty = (function cats$protocols$_mempty(s){\nif((((!((s == null)))) && ((!((s.cats$protocols$Monoid$_mempty$arity$1 == null)))))){\nreturn s.cats$protocols$Monoid$_mempty$arity$1(s);\n} else {\nvar x__4433__auto__ = (((s == null))?null:s);\nvar m__4434__auto__ = (cats.protocols._mempty[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(s) : m__4434__auto__.call(null,s));\n} else {\nvar m__4431__auto__ = (cats.protocols._mempty[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(s) : m__4431__auto__.call(null,s));\n} else {\nthrow cljs.core.missing_protocol(\"Monoid.-mempty\",s);\n}\n}\n}\n});\n\n\n/**\n * A type class to extract the\n *   value from a monad context.\n * @interface\n */\ncats.protocols.Extract = function(){};\n\n/**\n * Extract the value from monad context.\n */\ncats.protocols._extract = (function cats$protocols$_extract(mv){\nif((((!((mv == null)))) && ((!((mv.cats$protocols$Extract$_extract$arity$1 == null)))))){\nreturn mv.cats$protocols$Extract$_extract$arity$1(mv);\n} else {\nvar x__4433__auto__ = (((mv == null))?null:mv);\nvar m__4434__auto__ = (cats.protocols._extract[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(mv) : m__4434__auto__.call(null,mv));\n} else {\nvar m__4431__auto__ = (cats.protocols._extract[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(mv) : m__4431__auto__.call(null,mv));\n} else {\nthrow cljs.core.missing_protocol(\"Extract.-extract\",mv);\n}\n}\n}\n});\n\n\n/**\n * A data type that can be mapped over without altering its context.\n * @interface\n */\ncats.protocols.Functor = function(){};\n\n/**\n * Applies function f to the value(s) inside the context of the functor fv.\n */\ncats.protocols._fmap = (function cats$protocols$_fmap(ftor,f,fv){\nif((((!((ftor == null)))) && ((!((ftor.cats$protocols$Functor$_fmap$arity$3 == null)))))){\nreturn ftor.cats$protocols$Functor$_fmap$arity$3(ftor,f,fv);\n} else {\nvar x__4433__auto__ = (((ftor == null))?null:ftor);\nvar m__4434__auto__ = (cats.protocols._fmap[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(ftor,f,fv) : m__4434__auto__.call(null,ftor,f,fv));\n} else {\nvar m__4431__auto__ = (cats.protocols._fmap[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(ftor,f,fv) : m__4431__auto__.call(null,ftor,f,fv));\n} else {\nthrow cljs.core.missing_protocol(\"Functor.-fmap\",ftor);\n}\n}\n}\n});\n\n\n/**\n * A 'Functor' of two arguments.\n * @interface\n */\ncats.protocols.Bifunctor = function(){};\n\n/**\n * Map over both arguments at the same time.\n */\ncats.protocols._bimap = (function cats$protocols$_bimap(btor,f,g,bv){\nif((((!((btor == null)))) && ((!((btor.cats$protocols$Bifunctor$_bimap$arity$4 == null)))))){\nreturn btor.cats$protocols$Bifunctor$_bimap$arity$4(btor,f,g,bv);\n} else {\nvar x__4433__auto__ = (((btor == null))?null:btor);\nvar m__4434__auto__ = (cats.protocols._bimap[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$4(btor,f,g,bv) : m__4434__auto__.call(null,btor,f,g,bv));\n} else {\nvar m__4431__auto__ = (cats.protocols._bimap[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$4(btor,f,g,bv) : m__4431__auto__.call(null,btor,f,g,bv));\n} else {\nthrow cljs.core.missing_protocol(\"Bifunctor.-bimap\",btor);\n}\n}\n}\n});\n\n\n/**\n * The Applicative abstraction.\n * @interface\n */\ncats.protocols.Applicative = function(){};\n\n/**\n * Applies the function(s) inside af's context to the value(s)\n *   inside av's context while preserving the context.\n */\ncats.protocols._fapply = (function cats$protocols$_fapply(app,af,av){\nif((((!((app == null)))) && ((!((app.cats$protocols$Applicative$_fapply$arity$3 == null)))))){\nreturn app.cats$protocols$Applicative$_fapply$arity$3(app,af,av);\n} else {\nvar x__4433__auto__ = (((app == null))?null:app);\nvar m__4434__auto__ = (cats.protocols._fapply[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(app,af,av) : m__4434__auto__.call(null,app,af,av));\n} else {\nvar m__4431__auto__ = (cats.protocols._fapply[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(app,af,av) : m__4431__auto__.call(null,app,af,av));\n} else {\nthrow cljs.core.missing_protocol(\"Applicative.-fapply\",app);\n}\n}\n}\n});\n\n/**\n * Takes any context or monadic value `app` and any value `v`, and puts\n *   the value `v` in the most minimal context (normally `mempty`) of same type of `app`\n */\ncats.protocols._pure = (function cats$protocols$_pure(app,v){\nif((((!((app == null)))) && ((!((app.cats$protocols$Applicative$_pure$arity$2 == null)))))){\nreturn app.cats$protocols$Applicative$_pure$arity$2(app,v);\n} else {\nvar x__4433__auto__ = (((app == null))?null:app);\nvar m__4434__auto__ = (cats.protocols._pure[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(app,v) : m__4434__auto__.call(null,app,v));\n} else {\nvar m__4431__auto__ = (cats.protocols._pure[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(app,v) : m__4431__auto__.call(null,app,v));\n} else {\nthrow cljs.core.missing_protocol(\"Applicative.-pure\",app);\n}\n}\n}\n});\n\n\n/**\n * Abstraction of data structures that can be folded to a summary value.\n * @interface\n */\ncats.protocols.Foldable = function(){};\n\n/**\n * Left-associative fold of a structure.\n */\ncats.protocols._foldl = (function cats$protocols$_foldl(fctx,f,z,xs){\nif((((!((fctx == null)))) && ((!((fctx.cats$protocols$Foldable$_foldl$arity$4 == null)))))){\nreturn fctx.cats$protocols$Foldable$_foldl$arity$4(fctx,f,z,xs);\n} else {\nvar x__4433__auto__ = (((fctx == null))?null:fctx);\nvar m__4434__auto__ = (cats.protocols._foldl[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$4(fctx,f,z,xs) : m__4434__auto__.call(null,fctx,f,z,xs));\n} else {\nvar m__4431__auto__ = (cats.protocols._foldl[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$4(fctx,f,z,xs) : m__4431__auto__.call(null,fctx,f,z,xs));\n} else {\nthrow cljs.core.missing_protocol(\"Foldable.-foldl\",fctx);\n}\n}\n}\n});\n\n/**\n * Right-associative fold of a structure.\n */\ncats.protocols._foldr = (function cats$protocols$_foldr(fctx,f,z,xs){\nif((((!((fctx == null)))) && ((!((fctx.cats$protocols$Foldable$_foldr$arity$4 == null)))))){\nreturn fctx.cats$protocols$Foldable$_foldr$arity$4(fctx,f,z,xs);\n} else {\nvar x__4433__auto__ = (((fctx == null))?null:fctx);\nvar m__4434__auto__ = (cats.protocols._foldr[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$4(fctx,f,z,xs) : m__4434__auto__.call(null,fctx,f,z,xs));\n} else {\nvar m__4431__auto__ = (cats.protocols._foldr[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$4 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$4(fctx,f,z,xs) : m__4431__auto__.call(null,fctx,f,z,xs));\n} else {\nthrow cljs.core.missing_protocol(\"Foldable.-foldr\",fctx);\n}\n}\n}\n});\n\n\n/**\n * Abstraction of data structures that can be traversed from left to right\n *   performing an action on every element.\n * @interface\n */\ncats.protocols.Traversable = function(){};\n\n/**\n * Map each element to an Applicative, evaluate the applicatives from left\n *   to right and collect the results.\n */\ncats.protocols._traverse = (function cats$protocols$_traverse(tctx,f,tv){\nif((((!((tctx == null)))) && ((!((tctx.cats$protocols$Traversable$_traverse$arity$3 == null)))))){\nreturn tctx.cats$protocols$Traversable$_traverse$arity$3(tctx,f,tv);\n} else {\nvar x__4433__auto__ = (((tctx == null))?null:tctx);\nvar m__4434__auto__ = (cats.protocols._traverse[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(tctx,f,tv) : m__4434__auto__.call(null,tctx,f,tv));\n} else {\nvar m__4431__auto__ = (cats.protocols._traverse[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(tctx,f,tv) : m__4431__auto__.call(null,tctx,f,tv));\n} else {\nthrow cljs.core.missing_protocol(\"Traversable.-traverse\",tctx);\n}\n}\n}\n});\n\n\n/**\n * The Monad abstraction.\n * @interface\n */\ncats.protocols.Monad = function(){};\n\ncats.protocols._mreturn = (function cats$protocols$_mreturn(m,v){\nif((((!((m == null)))) && ((!((m.cats$protocols$Monad$_mreturn$arity$2 == null)))))){\nreturn m.cats$protocols$Monad$_mreturn$arity$2(m,v);\n} else {\nvar x__4433__auto__ = (((m == null))?null:m);\nvar m__4434__auto__ = (cats.protocols._mreturn[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$2(m,v) : m__4434__auto__.call(null,m,v));\n} else {\nvar m__4431__auto__ = (cats.protocols._mreturn[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$2 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$2(m,v) : m__4431__auto__.call(null,m,v));\n} else {\nthrow cljs.core.missing_protocol(\"Monad.-mreturn\",m);\n}\n}\n}\n});\n\ncats.protocols._mbind = (function cats$protocols$_mbind(m,mv,f){\nif((((!((m == null)))) && ((!((m.cats$protocols$Monad$_mbind$arity$3 == null)))))){\nreturn m.cats$protocols$Monad$_mbind$arity$3(m,mv,f);\n} else {\nvar x__4433__auto__ = (((m == null))?null:m);\nvar m__4434__auto__ = (cats.protocols._mbind[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(m,mv,f) : m__4434__auto__.call(null,m,mv,f));\n} else {\nvar m__4431__auto__ = (cats.protocols._mbind[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(m,mv,f) : m__4431__auto__.call(null,m,mv,f));\n} else {\nthrow cljs.core.missing_protocol(\"Monad.-mbind\",m);\n}\n}\n}\n});\n\n\n/**\n * A complement abstraction for monad that\n *   supports the notion of an identity element.\n * @interface\n */\ncats.protocols.MonadZero = function(){};\n\n/**\n * The identity element for the given monadzero.\n */\ncats.protocols._mzero = (function cats$protocols$_mzero(m){\nif((((!((m == null)))) && ((!((m.cats$protocols$MonadZero$_mzero$arity$1 == null)))))){\nreturn m.cats$protocols$MonadZero$_mzero$arity$1(m);\n} else {\nvar x__4433__auto__ = (((m == null))?null:m);\nvar m__4434__auto__ = (cats.protocols._mzero[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$1(m) : m__4434__auto__.call(null,m));\n} else {\nvar m__4431__auto__ = (cats.protocols._mzero[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$1 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$1(m) : m__4431__auto__.call(null,m));\n} else {\nthrow cljs.core.missing_protocol(\"MonadZero.-mzero\",m);\n}\n}\n}\n});\n\n\n/**\n * A complement abstraction for Monad that\n *   supports the notion of addition.\n * @interface\n */\ncats.protocols.MonadPlus = function(){};\n\n/**\n * An associative addition operation.\n */\ncats.protocols._mplus = (function cats$protocols$_mplus(m,mv,mv_SINGLEQUOTE_){\nif((((!((m == null)))) && ((!((m.cats$protocols$MonadPlus$_mplus$arity$3 == null)))))){\nreturn m.cats$protocols$MonadPlus$_mplus$arity$3(m,mv,mv_SINGLEQUOTE_);\n} else {\nvar x__4433__auto__ = (((m == null))?null:m);\nvar m__4434__auto__ = (cats.protocols._mplus[goog.typeOf(x__4433__auto__)]);\nif((!((m__4434__auto__ == null)))){\nreturn (m__4434__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4434__auto__.cljs$core$IFn$_invoke$arity$3(m,mv,mv_SINGLEQUOTE_) : m__4434__auto__.call(null,m,mv,mv_SINGLEQUOTE_));\n} else {\nvar m__4431__auto__ = (cats.protocols._mplus[\"_\"]);\nif((!((m__4431__auto__ == null)))){\nreturn (m__4431__auto__.cljs$core$IFn$_invoke$arity$3 ? m__4431__auto__.cljs$core$IFn$_invoke$arity$3(m,mv,mv_SINGLEQUOTE_) : m__4431__auto__.call(null,m,mv,mv_SINGLEQUOTE_));\n} else {\nthrow cljs.core.missing_protocol(\"MonadPlus.-mplus\",m);\n}\n}\n}\n});\n\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:doc","A collection of protocols upon which the cats abstractions are built.\n\n  NOTE: Functions of this namespace are not intended to be used directly.\n  It is considered internal api.","~:file","cats/protocols.cljc","~:line",26,"~:column",5,"~:end-line",26,"~:end-column",19],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$create-react-class","~$module$node_modules$create_react_class$index","~$react-dom","~$module$node_modules$react_dom$index","~$clojure.spec.alpha","~$cljs.spec.alpha"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$cats.protocols","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$cljs.core","^P","~$goog","^Q"],"~:seen",["^I",[]],"~:uses",null,"~:require-macros",["^ ","^P","^P"],"~:form",["~#list",["~$ns","^K","A collection of protocols upon which the cats abstractions are built.\n\n  NOTE: Functions of this namespace are not intended to be used directly.\n  It is considered internal api."]],"~:flags",["^ "],"~:js-deps",["^ "],"~:deps",["^Q","^P"]],"^M","^K","~:resource-id",["~:shadow.build.classpath/resource","cats/protocols.cljc"],"~:compiled-at",1560578445233,"~:resource-name","cats/protocols.cljc","~:warnings",[],"~:source",";; Copyright (c) 2014-2016 Andrey Antukh <niwi@niwi.nz>\n;; Copyright (c) 2014-2016 Alejandro GÃ³mez <alejandro@dialelo.com>\n;; All rights reserved.\n;;\n;; Redistribution and use in source and binary forms, with or without\n;; modification, are permitted provided that the following conditions\n;; are met:\n;;\n;; 1. Redistributions of source code must retain the above copyright\n;;    notice, this list of conditions and the following disclaimer.\n;; 2. Redistributions in binary form must reproduce the above copyright\n;;    notice, this list of conditions and the following disclaimer in the\n;;    documentation and/or other materials provided with the distribution.\n;;\n;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n;; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n;; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n;; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n;; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n;; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n;; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n(ns cats.protocols\n  \"A collection of protocols upon which the cats abstractions are built.\n\n  NOTE: Functions of this namespace are not intended to be used directly.\n  It is considered internal api.\")\n\n(defprotocol Context\n  \"A marker protocol for identifying the valid context types.\")\n\n(defprotocol Contextual\n  \"Abstraction that establishes a concrete type as a member of a context.\n\n  A great example is the Maybe monad type Just. It implements\n  this abstraction to establish that Just is part of\n  the Maybe monad.\"\n  (-get-context [_] \"Get the context associated with the type.\"))\n\n(defprotocol Printable\n  \"An abstraction to make a type printable in a platform\n  independent manner.\"\n  (-repr ^String [_] \"Get the repl ready representation of the object.\"))\n\n(defprotocol Semigroup\n  \"A structure with an associative binary operation.\"\n  (-mappend [s sv sv'] \"An associative addition operation.\"))\n\n(defprotocol Monoid\n  \"A Semigroup which has an identity element with respect to an associative binary operation.\"\n  (-mempty [s] \"The identity element for the given monoid.\"))\n\n(defprotocol Extract\n  \"A type class to extract the\n  value from a monad context.\"\n  (-extract [mv] \"Extract the value from monad context.\"))\n\n(defprotocol Functor\n  \"A data type that can be mapped over without altering its context.\"\n  (-fmap [ftor f fv] \"Applies function f to the value(s) inside the context of the functor fv.\"))\n\n(defprotocol Bifunctor\n  \"A 'Functor' of two arguments.\"\n  (-bimap  [btor f g bv] \"Map over both arguments at the same time.\"))\n\n(defprotocol Applicative\n  \"The Applicative abstraction.\"\n  (-fapply [app af av]\n    \"Applies the function(s) inside af's context to the value(s)\n     inside av's context while preserving the context.\")\n  (-pure [app v]\n    \"Takes any context or monadic value `app` and any value `v`, and puts\n     the value `v` in the most minimal context (normally `mempty`) of same type of `app`\"))\n\n(defprotocol Foldable\n  \"Abstraction of data structures that can be folded to a summary value.\"\n  (-foldl [fctx f z xs] \"Left-associative fold of a structure.\")\n  (-foldr [fctx f z xs] \"Right-associative fold of a structure.\"))\n\n(defprotocol Traversable\n  \"Abstraction of data structures that can be traversed from left to right\n  performing an action on every element.\"\n  (-traverse [tctx f tv]\n    \"Map each element to an Applicative, evaluate the applicatives from left\n     to right and collect the results.\"))\n\n(defprotocol Monad\n  \"The Monad abstraction.\"\n  (-mreturn [m v])\n  (-mbind [m mv f]))\n\n(defprotocol MonadZero\n  \"A complement abstraction for monad that\n  supports the notion of an identity element.\"\n  (-mzero [m] \"The identity element for the given monadzero.\"))\n\n(defprotocol MonadPlus\n  \"A complement abstraction for Monad that\n  supports the notion of addition.\"\n  (-mplus [m mv mv'] \"An associative addition operation.\"))\n","~:reader-features",["^I",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["cats.protocols/Context","x__4433__auto__","m__4434__auto__","cats.protocols/-get-context","goog/typeOf","m__4431__auto__","cljs.core/missing-protocol","cats.protocols/Contextual","_","cats.protocols/-repr","cats.protocols/Printable","cats.protocols/-mappend","cats.protocols/Semigroup","s","sv","sv'","cats.protocols/-mempty","cats.protocols/Monoid","cats.protocols/-extract","cats.protocols/Extract","mv","cats.protocols/-fmap","cats.protocols/Functor","ftor","f","fv","cats.protocols/-bimap","cats.protocols/Bifunctor","btor","g","bv","cats.protocols/-fapply","cats.protocols/-pure","cats.protocols/Applicative","app","af","av","v","cats.protocols/-foldl","cats.protocols/-foldr","cats.protocols/Foldable","fctx","z","xs","cats.protocols/-traverse","cats.protocols/Traversable","tctx","tv","cats.protocols/-mreturn","cats.protocols/-mbind","cats.protocols/Monad","m","cats.protocols/-mzero","cats.protocols/MonadZero","cats.protocols/-mplus","cats.protocols/MonadPlus","mv'"]]],"~:cache-keys",["~#cmap",[["~:macro","^P"],[1559826623000],["^10","goog/math/math.js"],[1560546089000,"~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^I",[]],"~:deps-syms",["^Q","~$goog.array","~$goog.asserts"]]],["^10","goog/array/array.js"],[1560546089000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["^Q","^1C"]]],["^10","goog/debug/error.js"],[1560546089000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["^Q"]]],["^10","cats/protocols.cljc"],[1547383501000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["^Q","^P"]]],["^10","goog/dom/nodetype.js"],[1560546089000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["^Q"]]],["^10","goog/object/object.js"],[1560546089000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["^Q"]]],"~:SHADOW-TIMESTAMP",[1560546091000,1559826623000],["^10","goog/math/long.js"],[1560546089000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["^Q","^1C","~$goog.reflect"]]],["^10","goog/string/internal.js"],[1560546089000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["^Q"]]],["^10","goog/functions/functions.js"],[1560546089000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["^Q"]]],["^10","goog/structs/map.js"],[1560546089000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["^Q","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^10","goog/asserts/asserts.js"],[1560546089000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["^Q","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^10","goog/uri/uri.js"],[1560546089000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["^Q","^1B","^1C","~$goog.string","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^10","goog/base.js"],[1560546089000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",[]]],["^10","goog/structs/structs.js"],[1560546089000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["^Q","^1B","~$goog.object"]]],["^10","goog/string/string.js"],[1560546089000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["^Q","~$goog.string.internal"]]],["^10","goog/reflect/reflect.js"],[1560546089000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["^Q"]]],["^10","goog/string/stringbuffer.js"],[1560546089000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["^Q"]]],["^10","goog/iter/iter.js"],[1560546089000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["^Q","^1B","^1C","~$goog.functions","~$goog.math"]]],["^10","cljs/core.cljs"],[1559826623000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["~$goog.math.Long","~$goog.math.Integer","^1J","^1P","^1B","~$goog.Uri","~$goog.string.StringBuffer"]]],["^10","goog/math/integer.js"],[1560546089000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["^Q"]]],["^10","goog/uri/utils.js"],[1560546089000,"^1>",["^ ","^1?",null,"^1@",["^I",[]],"^1A",["^Q","^1B","^1C","^1J"]]]]],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","A collection of protocols upon which the cats abstractions are built.\n\n  NOTE: Functions of this namespace are not intended to be used directly.\n  It is considered internal api.","^7","cats/protocols.cljc","^8",26,"^9",5,"^:",26,"^;",19],"^<",["^ ","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F"],"~:shadow/protocol-prefixes",["^I",["cats$protocols$MonadPlus$","cats$protocols$Semigroup$","cats$protocols$Bifunctor$","cats$protocols$Extract$","cats$protocols$Foldable$","cats$protocols$Monad$","cats$protocols$Functor$","cats$protocols$Printable$","cats$protocols$MonadZero$","cats$protocols$Applicative$","cats$protocols$Contextual$","cats$protocols$Monoid$","cats$protocols$Traversable$"]],"^G",null,"^H",["^I",[]],"^J","^K","^N",null,"^O",["^ ","^P","^P","^Q","^Q"],"^R",["^I",[]],"^S",null,"~:defs",["^ ","~$Monad",["^ ","^5",["^ ","~:protocol-symbol",true,"^7","cats/protocols.cljc","^;",19,"^9",14,"^8",90,"~:protocol-info",["^ ","~:methods",["^ ","~$-mreturn",[["~$m","~$v"]],"~$-mbind",[["~$m","~$mv","~$f"]]]],"^:",90,"^6","The Monad abstraction.","~:jsdoc",["^V",["@interface"]]],"^20",true,"^J","~$cats.protocols/Monad","^7","cats/protocols.cljc","^;",19,"^9",1,"^8",90,"^21",["^ ","^22",["^ ","^23",[["~$m","~$v"]],"^24",[["~$m","^25","~$f"]]]],"~:info",null,"^:",90,"~:tag","~$any","~:impls",["^I",[]],"^6","The Monad abstraction.","^26",["^V",["@interface"]]],"~$Functor",["^ ","^5",["^ ","^20",true,"^7","cats/protocols.cljc","^;",21,"^9",14,"^8",61,"^21",["^ ","^22",["^ ","~$-fmap",[["~$ftor","~$f","~$fv"]]]],"^:",61,"^6","A data type that can be mapped over without altering its context.","^26",["^V",["@interface"]]],"^20",true,"^J","~$cats.protocols/Functor","^7","cats/protocols.cljc","^;",21,"^9",1,"^8",61,"^21",["^ ","^22",["^ ","^2=",[["^2>","~$f","^2?"]]]],"^28",null,"^:",61,"^29","^2:","^2;",["^I",[]],"^6","A data type that can be mapped over without altering its context.","^26",["^V",["@interface"]]],"~$-mempty",["^ ","~:protocol-inline",null,"^5",["^ ","^7","cats/protocols.cljc","^8",54,"^9",4,"^:",54,"^;",11,"~:protocol","~$cats.protocols/Monoid","^6","The identity element for the given monoid.","~:arglists",["^V",["~$quote",["^V",[["~$s"]]]]]],"^2C","^2D","^J","~$cats.protocols/-mempty","^7","cats/protocols.cljc","^;",11,"~:method-params",["^V",[["~$s"]]],"~:protocol-impl",null,"~:arglists-meta",["^V",[null,null]],"^9",1,"~:variadic?",false,"^8",52,"~:ret-tag","^2:","^:",54,"~:max-fixed-arity",1,"~:fn-var",true,"^2E",["^V",["^2F",["^V",[["~$s"]]]]],"^6","The identity element for the given monoid."],"~$-fapply",["^ ","^2B",null,"^5",["^ ","^7","cats/protocols.cljc","^8",71,"^9",4,"^:",71,"^;",11,"^2C","~$cats.protocols/Applicative","^6","Applies the function(s) inside af's context to the value(s)\n     inside av's context while preserving the context.","^2E",["^V",["^2F",["^V",[["~$app","~$af","~$av"]]]]]],"^2C","^2P","^J","~$cats.protocols/-fapply","^7","cats/protocols.cljc","^;",11,"^2H",["^V",[["^2Q","^2R","^2S"]]],"^2I",null,"^2J",["^V",[null,null]],"^9",1,"^2K",false,"^8",69,"^2L","^2:","^:",71,"^2M",3,"^2N",true,"^2E",["^V",["^2F",["^V",[["^2Q","^2R","^2S"]]]]],"^6","Applies the function(s) inside af's context to the value(s)\n     inside av's context while preserving the context."],"~$Applicative",["^ ","^5",["^ ","^20",true,"^7","cats/protocols.cljc","^;",25,"^9",14,"^8",69,"^21",["^ ","^22",["^ ","^2O",[["^2Q","^2R","^2S"]],"~$-pure",[["^2Q","~$v"]]]],"^:",69,"^6","The Applicative abstraction.","^26",["^V",["@interface"]]],"^20",true,"^J","^2P","^7","cats/protocols.cljc","^;",25,"^9",1,"^8",69,"^21",["^ ","^22",["^ ","^2O",[["^2Q","^2R","^2S"]],"^2V",[["^2Q","~$v"]]]],"^28",null,"^:",69,"^29","^2:","^2;",["^I",[]],"^6","The Applicative abstraction.","^26",["^V",["@interface"]]],"~$-foldl",["^ ","^2B",null,"^5",["^ ","^7","cats/protocols.cljc","^8",80,"^9",4,"^:",80,"^;",10,"^2C","~$cats.protocols/Foldable","^6","Left-associative fold of a structure.","^2E",["^V",["^2F",["^V",[["~$fctx","~$f","~$z","~$xs"]]]]]],"^2C","^2X","^J","~$cats.protocols/-foldl","^7","cats/protocols.cljc","^;",10,"^2H",["^V",[["^2Y","~$f","~$z","^2Z"]]],"^2I",null,"^2J",["^V",[null,null]],"^9",1,"^2K",false,"^8",78,"^2L","^2:","^:",80,"^2M",4,"^2N",true,"^2E",["^V",["^2F",["^V",[["^2Y","~$f","~$z","^2Z"]]]]],"^6","Left-associative fold of a structure."],"~$Bifunctor",["^ ","^5",["^ ","^20",true,"^7","cats/protocols.cljc","^;",23,"^9",14,"^8",65,"^21",["^ ","^22",["^ ","~$-bimap",[["~$btor","~$f","~$g","~$bv"]]]],"^:",65,"^6","A 'Functor' of two arguments.","^26",["^V",["@interface"]]],"^20",true,"^J","~$cats.protocols/Bifunctor","^7","cats/protocols.cljc","^;",23,"^9",1,"^8",65,"^21",["^ ","^22",["^ ","^31",[["^32","~$f","~$g","^33"]]]],"^28",null,"^:",65,"^29","^2:","^2;",["^I",[]],"^6","A 'Functor' of two arguments.","^26",["^V",["@interface"]]],"^24",["^ ","^2B",null,"^5",["^ ","^7","cats/protocols.cljc","^8",93,"^9",4,"^:",93,"^;",10,"^2C","^27","^6",null,"^2E",["^V",["^2F",["^V",[["~$m","^25","~$f"]]]]]],"^2C","^27","^J","~$cats.protocols/-mbind","^7","cats/protocols.cljc","^;",10,"^2H",["^V",[["~$m","^25","~$f"]]],"^2I",null,"^2J",["^V",[null,null]],"^9",1,"^2K",false,"^8",90,"^2L","^2:","^:",93,"^2M",3,"^2N",true,"^2E",["^V",["^2F",["^V",[["~$m","^25","~$f"]]]]],"^6",null],"~$Printable",["^ ","^5",["^ ","^20",true,"^7","cats/protocols.cljc","^;",23,"^9",14,"^8",43,"^21",["^ ","^22",["^ ","~$-repr",[["~$_"]]]],"^:",43,"^6","An abstraction to make a type printable in a platform\n  independent manner.","^26",["^V",["@interface"]]],"^20",true,"^J","~$cats.protocols/Printable","^7","cats/protocols.cljc","^;",23,"^9",1,"^8",43,"^21",["^ ","^22",["^ ","^37",[["~$_"]]]],"^28",null,"^:",43,"^29","^2:","^2;",["^I",[]],"^6","An abstraction to make a type printable in a platform\n  independent manner.","^26",["^V",["@interface"]]],"~$Contextual",["^ ","^5",["^ ","^20",true,"^7","cats/protocols.cljc","^;",24,"^9",14,"^8",35,"^21",["^ ","^22",["^ ","~$-get-context",[["~$_"]]]],"^:",35,"^6","Abstraction that establishes a concrete type as a member of a context.\n\n  A great example is the Maybe monad type Just. It implements\n  this abstraction to establish that Just is part of\n  the Maybe monad.","^26",["^V",["@interface"]]],"^20",true,"^J","~$cats.protocols/Contextual","^7","cats/protocols.cljc","^;",24,"^9",1,"^8",35,"^21",["^ ","^22",["^ ","^3:",[["~$_"]]]],"^28",null,"^:",35,"^29","^2:","^2;",["^I",[]],"^6","Abstraction that establishes a concrete type as a member of a context.\n\n  A great example is the Maybe monad type Just. It implements\n  this abstraction to establish that Just is part of\n  the Maybe monad.","^26",["^V",["@interface"]]],"~$-traverse",["^ ","^2B",null,"^5",["^ ","^7","cats/protocols.cljc","^8",86,"^9",4,"^:",86,"^;",13,"^2C","~$cats.protocols/Traversable","^6","Map each element to an Applicative, evaluate the applicatives from left\n     to right and collect the results.","^2E",["^V",["^2F",["^V",[["~$tctx","~$f","~$tv"]]]]]],"^2C","^3=","^J","~$cats.protocols/-traverse","^7","cats/protocols.cljc","^;",13,"^2H",["^V",[["^3>","~$f","^3?"]]],"^2I",null,"^2J",["^V",[null,null]],"^9",1,"^2K",false,"^8",83,"^2L","^2:","^:",86,"^2M",3,"^2N",true,"^2E",["^V",["^2F",["^V",[["^3>","~$f","^3?"]]]]],"^6","Map each element to an Applicative, evaluate the applicatives from left\n     to right and collect the results."],"~$-foldr",["^ ","^2B",null,"^5",["^ ","^7","cats/protocols.cljc","^8",81,"^9",4,"^:",81,"^;",10,"^2C","^2X","^6","Right-associative fold of a structure.","^2E",["^V",["^2F",["^V",[["^2Y","~$f","~$z","^2Z"]]]]]],"^2C","^2X","^J","~$cats.protocols/-foldr","^7","cats/protocols.cljc","^;",10,"^2H",["^V",[["^2Y","~$f","~$z","^2Z"]]],"^2I",null,"^2J",["^V",[null,null]],"^9",1,"^2K",false,"^8",78,"^2L","^2:","^:",81,"^2M",4,"^2N",true,"^2E",["^V",["^2F",["^V",[["^2Y","~$f","~$z","^2Z"]]]]],"^6","Right-associative fold of a structure."],"~$-extract",["^ ","^2B",null,"^5",["^ ","^7","cats/protocols.cljc","^8",59,"^9",4,"^:",59,"^;",12,"^2C","~$cats.protocols/Extract","^6","Extract the value from monad context.","^2E",["^V",["^2F",["^V",[["^25"]]]]]],"^2C","^3D","^J","~$cats.protocols/-extract","^7","cats/protocols.cljc","^;",12,"^2H",["^V",[["^25"]]],"^2I",null,"^2J",["^V",[null,null]],"^9",1,"^2K",false,"^8",56,"^2L","^2:","^:",59,"^2M",1,"^2N",true,"^2E",["^V",["^2F",["^V",[["^25"]]]]],"^6","Extract the value from monad context."],"~$MonadPlus",["^ ","^5",["^ ","^20",true,"^7","cats/protocols.cljc","^;",23,"^9",14,"^8",100,"^21",["^ ","^22",["^ ","~$-mplus",[["~$m","^25","~$mv'"]]]],"^:",100,"^6","A complement abstraction for Monad that\n  supports the notion of addition.","^26",["^V",["@interface"]]],"^20",true,"^J","~$cats.protocols/MonadPlus","^7","cats/protocols.cljc","^;",23,"^9",1,"^8",100,"^21",["^ ","^22",["^ ","^3G",[["~$m","^25","^3H"]]]],"^28",null,"^:",100,"^29","^2:","^2;",["^I",[]],"^6","A complement abstraction for Monad that\n  supports the notion of addition.","^26",["^V",["@interface"]]],"^37",["^ ","^2B",null,"^5",["^ ","^7","cats/protocols.cljc","^8",46,"^9",4,"^:",46,"^;",9,"^2C","^38","^6","Get the repl ready representation of the object.","^2E",["^V",["^2F",["^V",[["~$_"]]]]]],"^2C","^38","^J","~$cats.protocols/-repr","^7","cats/protocols.cljc","^;",9,"^2H",["^V",[["~$_"]]],"^2I",null,"^2J",["^V",[null,null]],"^9",1,"^2K",false,"^8",43,"^2L","^2:","^:",46,"^2M",1,"^2N",true,"^2E",["^V",["^2F",["^V",[["~$_"]]]]],"^6","Get the repl ready representation of the object."],"~$-mzero",["^ ","^2B",null,"^5",["^ ","^7","cats/protocols.cljc","^8",98,"^9",4,"^:",98,"^;",10,"^2C","~$cats.protocols/MonadZero","^6","The identity element for the given monadzero.","^2E",["^V",["^2F",["^V",[["~$m"]]]]]],"^2C","^3L","^J","~$cats.protocols/-mzero","^7","cats/protocols.cljc","^;",10,"^2H",["^V",[["~$m"]]],"^2I",null,"^2J",["^V",[null,null]],"^9",1,"^2K",false,"^8",95,"^2L","^2:","^:",98,"^2M",1,"^2N",true,"^2E",["^V",["^2F",["^V",[["~$m"]]]]],"^6","The identity element for the given monadzero."],"^23",["^ ","^2B",null,"^5",["^ ","^7","cats/protocols.cljc","^8",92,"^9",4,"^:",92,"^;",12,"^2C","^27","^6",null,"^2E",["^V",["^2F",["^V",[["~$m","~$v"]]]]]],"^2C","^27","^J","~$cats.protocols/-mreturn","^7","cats/protocols.cljc","^;",12,"^2H",["^V",[["~$m","~$v"]]],"^2I",null,"^2J",["^V",[null,null]],"^9",1,"^2K",false,"^8",90,"^2L","^2:","^:",92,"^2M",2,"^2N",true,"^2E",["^V",["^2F",["^V",[["~$m","~$v"]]]]],"^6",null],"^2V",["^ ","^2B",null,"^5",["^ ","^7","cats/protocols.cljc","^8",74,"^9",4,"^:",74,"^;",9,"^2C","^2P","^6","Takes any context or monadic value `app` and any value `v`, and puts\n     the value `v` in the most minimal context (normally `mempty`) of same type of `app`","^2E",["^V",["^2F",["^V",[["^2Q","~$v"]]]]]],"^2C","^2P","^J","~$cats.protocols/-pure","^7","cats/protocols.cljc","^;",9,"^2H",["^V",[["^2Q","~$v"]]],"^2I",null,"^2J",["^V",[null,null]],"^9",1,"^2K",false,"^8",69,"^2L","^2:","^:",74,"^2M",2,"^2N",true,"^2E",["^V",["^2F",["^V",[["^2Q","~$v"]]]]],"^6","Takes any context or monadic value `app` and any value `v`, and puts\n     the value `v` in the most minimal context (normally `mempty`) of same type of `app`"],"^2=",["^ ","^2B",null,"^5",["^ ","^7","cats/protocols.cljc","^8",63,"^9",4,"^:",63,"^;",9,"^2C","^2@","^6","Applies function f to the value(s) inside the context of the functor fv.","^2E",["^V",["^2F",["^V",[["^2>","~$f","^2?"]]]]]],"^2C","^2@","^J","~$cats.protocols/-fmap","^7","cats/protocols.cljc","^;",9,"^2H",["^V",[["^2>","~$f","^2?"]]],"^2I",null,"^2J",["^V",[null,null]],"^9",1,"^2K",false,"^8",61,"^2L","^2:","^:",63,"^2M",3,"^2N",true,"^2E",["^V",["^2F",["^V",[["^2>","~$f","^2?"]]]]],"^6","Applies function f to the value(s) inside the context of the functor fv."],"~$MonadZero",["^ ","^5",["^ ","^20",true,"^7","cats/protocols.cljc","^;",23,"^9",14,"^8",95,"^21",["^ ","^22",["^ ","^3K",[["~$m"]]]],"^:",95,"^6","A complement abstraction for monad that\n  supports the notion of an identity element.","^26",["^V",["@interface"]]],"^20",true,"^J","^3L","^7","cats/protocols.cljc","^;",23,"^9",1,"^8",95,"^21",["^ ","^22",["^ ","^3K",[["~$m"]]]],"^28",null,"^:",95,"^29","^2:","^2;",["^I",[]],"^6","A complement abstraction for monad that\n  supports the notion of an identity element.","^26",["^V",["@interface"]]],"~$Semigroup",["^ ","^5",["^ ","^20",true,"^7","cats/protocols.cljc","^;",23,"^9",14,"^8",48,"^21",["^ ","^22",["^ ","~$-mappend",[["~$s","~$sv","~$sv'"]]]],"^:",48,"^6","A structure with an associative binary operation.","^26",["^V",["@interface"]]],"^20",true,"^J","~$cats.protocols/Semigroup","^7","cats/protocols.cljc","^;",23,"^9",1,"^8",48,"^21",["^ ","^22",["^ ","^3S",[["~$s","^3T","^3U"]]]],"^28",null,"^:",48,"^29","^2:","^2;",["^I",[]],"^6","A structure with an associative binary operation.","^26",["^V",["@interface"]]],"~$Traversable",["^ ","^5",["^ ","^20",true,"^7","cats/protocols.cljc","^;",25,"^9",14,"^8",83,"^21",["^ ","^22",["^ ","^3<",[["^3>","~$f","^3?"]]]],"^:",83,"^6","Abstraction of data structures that can be traversed from left to right\n  performing an action on every element.","^26",["^V",["@interface"]]],"^20",true,"^J","^3=","^7","cats/protocols.cljc","^;",25,"^9",1,"^8",83,"^21",["^ ","^22",["^ ","^3<",[["^3>","~$f","^3?"]]]],"^28",null,"^:",83,"^29","^2:","^2;",["^I",[]],"^6","Abstraction of data structures that can be traversed from left to right\n  performing an action on every element.","^26",["^V",["@interface"]]],"~$Monoid",["^ ","^5",["^ ","^20",true,"^7","cats/protocols.cljc","^;",20,"^9",14,"^8",52,"^21",["^ ","^22",["^ ","^2A",[["~$s"]]]],"^:",52,"^6","A Semigroup which has an identity element with respect to an associative binary operation.","^26",["^V",["@interface"]]],"^20",true,"^J","^2D","^7","cats/protocols.cljc","^;",20,"^9",1,"^8",52,"^21",["^ ","^22",["^ ","^2A",[["~$s"]]]],"^28",null,"^:",52,"^29","^2:","^2;",["^I",[]],"^6","A Semigroup which has an identity element with respect to an associative binary operation.","^26",["^V",["@interface"]]],"~$Context",["^ ","^5",["^ ","^20",true,"^7","cats/protocols.cljc","^;",21,"^9",14,"^8",32,"^21",["^ ","^22",["^ "]],"^:",32,"^6","A marker protocol for identifying the valid context types.","^26",["^V",["@interface"]]],"^20",true,"^J","~$cats.protocols/Context","^7","cats/protocols.cljc","^;",21,"^9",1,"^8",32,"^21",["^ ","^22",["^ "]],"^28",null,"^:",32,"^29","^2:","^2;",["^I",[]],"^6","A marker protocol for identifying the valid context types.","^26",["^V",["@interface"]]],"~$Extract",["^ ","^5",["^ ","^20",true,"^7","cats/protocols.cljc","^;",21,"^9",14,"^8",56,"^21",["^ ","^22",["^ ","^3C",[["^25"]]]],"^:",56,"^6","A type class to extract the\n  value from a monad context.","^26",["^V",["@interface"]]],"^20",true,"^J","^3D","^7","cats/protocols.cljc","^;",21,"^9",1,"^8",56,"^21",["^ ","^22",["^ ","^3C",[["^25"]]]],"^28",null,"^:",56,"^29","^2:","^2;",["^I",[]],"^6","A type class to extract the\n  value from a monad context.","^26",["^V",["@interface"]]],"~$Foldable",["^ ","^5",["^ ","^20",true,"^7","cats/protocols.cljc","^;",22,"^9",14,"^8",78,"^21",["^ ","^22",["^ ","^2W",[["^2Y","~$f","~$z","^2Z"]],"^3A",[["^2Y","~$f","~$z","^2Z"]]]],"^:",78,"^6","Abstraction of data structures that can be folded to a summary value.","^26",["^V",["@interface"]]],"^20",true,"^J","^2X","^7","cats/protocols.cljc","^;",22,"^9",1,"^8",78,"^21",["^ ","^22",["^ ","^2W",[["^2Y","~$f","~$z","^2Z"]],"^3A",[["^2Y","~$f","~$z","^2Z"]]]],"^28",null,"^:",78,"^29","^2:","^2;",["^I",[]],"^6","Abstraction of data structures that can be folded to a summary value.","^26",["^V",["@interface"]]],"^3S",["^ ","^2B",null,"^5",["^ ","^7","cats/protocols.cljc","^8",50,"^9",4,"^:",50,"^;",12,"^2C","^3V","^6","An associative addition operation.","^2E",["^V",["^2F",["^V",[["~$s","^3T","^3U"]]]]]],"^2C","^3V","^J","~$cats.protocols/-mappend","^7","cats/protocols.cljc","^;",12,"^2H",["^V",[["~$s","^3T","^3U"]]],"^2I",null,"^2J",["^V",[null,null]],"^9",1,"^2K",false,"^8",48,"^2L","^2:","^:",50,"^2M",3,"^2N",true,"^2E",["^V",["^2F",["^V",[["~$s","^3T","^3U"]]]]],"^6","An associative addition operation."],"^31",["^ ","^2B",null,"^5",["^ ","^7","cats/protocols.cljc","^8",67,"^9",4,"^:",67,"^;",10,"^2C","^34","^6","Map over both arguments at the same time.","^2E",["^V",["^2F",["^V",[["^32","~$f","~$g","^33"]]]]]],"^2C","^34","^J","~$cats.protocols/-bimap","^7","cats/protocols.cljc","^;",10,"^2H",["^V",[["^32","~$f","~$g","^33"]]],"^2I",null,"^2J",["^V",[null,null]],"^9",1,"^2K",false,"^8",65,"^2L","^2:","^:",67,"^2M",4,"^2N",true,"^2E",["^V",["^2F",["^V",[["^32","~$f","~$g","^33"]]]]],"^6","Map over both arguments at the same time."],"^3G",["^ ","^2B",null,"^5",["^ ","^7","cats/protocols.cljc","^8",103,"^9",4,"^:",103,"^;",10,"^2C","^3I","^6","An associative addition operation.","^2E",["^V",["^2F",["^V",[["~$m","^25","^3H"]]]]]],"^2C","^3I","^J","~$cats.protocols/-mplus","^7","cats/protocols.cljc","^;",10,"^2H",["^V",[["~$m","^25","^3H"]]],"^2I",null,"^2J",["^V",[null,null]],"^9",1,"^2K",false,"^8",100,"^2L","^2:","^:",103,"^2M",3,"^2N",true,"^2E",["^V",["^2F",["^V",[["~$m","^25","^3H"]]]]],"^6","An associative addition operation."],"^3:",["^ ","^2B",null,"^5",["^ ","^7","cats/protocols.cljc","^8",41,"^9",4,"^:",41,"^;",16,"^2C","^3;","^6","Get the context associated with the type.","^2E",["^V",["^2F",["^V",[["~$_"]]]]]],"^2C","^3;","^J","~$cats.protocols/-get-context","^7","cats/protocols.cljc","^;",16,"^2H",["^V",[["~$_"]]],"^2I",null,"^2J",["^V",[null,null]],"^9",1,"^2K",false,"^8",35,"^2L","^2:","^:",41,"^2M",1,"^2N",true,"^2E",["^V",["^2F",["^V",[["~$_"]]]]],"^6","Get the context associated with the type."]],"^T",["^ ","^P","^P"],"^X",["^ "],"^Y",["^ "],"^Z",["^Q","^P"]],"^M","^K","~:ns-specs",["^ "],"~:ns-speced-vars",[],"~:compiler-options",["^1<",[["^47","~:static-fns"],true,["^47","~:elide-asserts"],true,["^47","~:optimize-constants"],null,["^47","^13"],null,["^47","~:external-config"],null,["^47","~:tooling-config"],null,["^47","~:emit-constants"],null,["^47","~:load-tests"],false,["^47","~:infer-externs"],true,["^47","^15"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:release",["^47","~:fn-invoke-direct"],null,["^47","~:source-map"],"/dev/null"]]]