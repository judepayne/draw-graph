["^ ","~:output",["^ ","~:js","goog.provide('clojure.data.zip');\nclojure.data.zip.auto = (function clojure$data$zip$auto(v,x){\nreturn cljs.core.with_meta(x,(function (){var G__29888 = cljs.core.meta(x);\nvar G__29889 = new cljs.core.Keyword(\"zip-filter\",\"no-auto?\",\"zip-filter/no-auto?\",1861656504);\nvar G__29890 = true;\nvar fexpr__29887 = (cljs.core.truth_(v)?cljs.core.dissoc:cljs.core.assoc);\nreturn (fexpr__29887.cljs$core$IFn$_invoke$arity$3 ? fexpr__29887.cljs$core$IFn$_invoke$arity$3(G__29888,G__29889,G__29890) : fexpr__29887.call(null,G__29888,G__29889,G__29890));\n})());\n});\nclojure.data.zip.auto_QMARK_ = (function clojure$data$zip$auto_QMARK_(x){\nreturn cljs.core.not(new cljs.core.Keyword(\"zip-filter\",\"no-auto?\",\"zip-filter/no-auto?\",1861656504).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(x)));\n});\n/**\n * Returns a lazy sequence of locations to the right of loc, starting with loc.\n */\nclojure.data.zip.right_locs = (function clojure$data$zip$right_locs(loc){\nreturn (new cljs.core.LazySeq(null,(function (){\nif(cljs.core.truth_(loc)){\nreturn cljs.core.cons(clojure.data.zip.auto(false,loc),(function (){var G__29891 = clojure.zip.right(loc);\nreturn (clojure.data.zip.right_locs.cljs$core$IFn$_invoke$arity$1 ? clojure.data.zip.right_locs.cljs$core$IFn$_invoke$arity$1(G__29891) : clojure.data.zip.right_locs.call(null,G__29891));\n})());\n} else {\nreturn null;\n}\n}),null,null));\n});\n/**\n * Returns a lazy sequence of locations to the left of loc, starting with loc.\n */\nclojure.data.zip.left_locs = (function clojure$data$zip$left_locs(loc){\nreturn (new cljs.core.LazySeq(null,(function (){\nif(cljs.core.truth_(loc)){\nreturn cljs.core.cons(clojure.data.zip.auto(false,loc),(function (){var G__29893 = clojure.zip.left(loc);\nreturn (clojure.data.zip.left_locs.cljs$core$IFn$_invoke$arity$1 ? clojure.data.zip.left_locs.cljs$core$IFn$_invoke$arity$1(G__29893) : clojure.data.zip.left_locs.call(null,G__29893));\n})());\n} else {\nreturn null;\n}\n}),null,null));\n});\n/**\n * Returns true if there are no more nodes to the left of location loc.\n */\nclojure.data.zip.leftmost_QMARK_ = (function clojure$data$zip$leftmost_QMARK_(loc){\nreturn (clojure.zip.left(loc) == null);\n});\n/**\n * Returns true if there are no more nodes to the right of location loc.\n */\nclojure.data.zip.rightmost_QMARK_ = (function clojure$data$zip$rightmost_QMARK_(loc){\nreturn (clojure.zip.right(loc) == null);\n});\n/**\n * Returns a lazy sequence of all immediate children of location loc,\n *   left-to-right.\n */\nclojure.data.zip.children = (function clojure$data$zip$children(loc){\nif(cljs.core.truth_(clojure.zip.branch_QMARK_(loc))){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__29894_SHARP_){\nreturn clojure.data.zip.auto(false,p1__29894_SHARP_);\n}),clojure.data.zip.right_locs(clojure.zip.down(loc)));\n} else {\nreturn null;\n}\n});\n/**\n * Returns a lazy sequence of all immediate children of location loc,\n *   left-to-right, marked so that a following tag= predicate will auto-descend.\n */\nclojure.data.zip.children_auto = (function clojure$data$zip$children_auto(loc){\nif(cljs.core.truth_(clojure.zip.branch_QMARK_(loc))){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__29895_SHARP_){\nreturn clojure.data.zip.auto(true,p1__29895_SHARP_);\n}),clojure.data.zip.right_locs(clojure.zip.down(loc)));\n} else {\nreturn null;\n}\n});\n/**\n * Returns a lazy sequence of all descendants of location loc, in\n *   depth-first order, left-to-right, starting with loc.\n */\nclojure.data.zip.descendants = (function clojure$data$zip$descendants(loc){\nreturn (new cljs.core.LazySeq(null,(function (){\nreturn cljs.core.cons(clojure.data.zip.auto(false,loc),cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic(clojure.data.zip.descendants,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([clojure.data.zip.children(loc)], 0)));\n}),null,null));\n});\n/**\n * Returns a lazy sequence of all ancestors of location loc, starting\n *   with loc and proceeding to loc's parent node and on through to the\n *   root of the tree.\n */\nclojure.data.zip.ancestors = (function clojure$data$zip$ancestors(loc){\nreturn (new cljs.core.LazySeq(null,(function (){\nif(cljs.core.truth_(loc)){\nreturn cljs.core.cons(clojure.data.zip.auto(false,loc),(function (){var G__29905 = clojure.zip.up(loc);\nreturn (clojure.data.zip.ancestors.cljs$core$IFn$_invoke$arity$1 ? clojure.data.zip.ancestors.cljs$core$IFn$_invoke$arity$1(G__29905) : clojure.data.zip.ancestors.call(null,G__29905));\n})());\n} else {\nreturn null;\n}\n}),null,null));\n});\n/**\n * Calls (pred loc), and then converts the result to the 'appropriate'\n *   sequence.\n */\nclojure.data.zip.fixup_apply = (function clojure$data$zip$fixup_apply(pred,loc){\nvar rtn = (pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(loc) : pred.call(null,loc));\nif(cljs.core.truth_((function (){var and__4120__auto__ = cljs.core.map_QMARK_(cljs.core.meta(rtn));\nif(and__4120__auto__){\nreturn new cljs.core.Keyword(\"zip-filter\",\"is-node?\",\"zip-filter/is-node?\",-1966970687).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(rtn));\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn (new cljs.core.List(null,rtn,null,(1),null));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rtn,true)){\nreturn (new cljs.core.List(null,loc,null,(1),null));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rtn,false)){\nreturn null;\n} else {\nif((rtn == null)){\nreturn null;\n} else {\nif(cljs.core.sequential_QMARK_(rtn)){\nreturn rtn;\n} else {\nreturn (new cljs.core.List(null,rtn,null,(1),null));\n\n}\n}\n}\n}\n}\n});\nclojure.data.zip.mapcat_chain = (function clojure$data$zip$mapcat_chain(loc,preds,mkpred){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (prevseq,expr){\nreturn cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic((function (p1__29915_SHARP_){\nreturn clojure.data.zip.fixup_apply((function (){var or__4131__auto__ = (mkpred.cljs$core$IFn$_invoke$arity$1 ? mkpred.cljs$core$IFn$_invoke$arity$1(expr) : mkpred.call(null,expr));\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn expr;\n}\n})(),p1__29915_SHARP_);\n}),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([prevseq], 0));\n}),(new cljs.core.List(null,cljs.core.with_meta(loc,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.meta(loc),new cljs.core.Keyword(\"zip-filter\",\"is-node?\",\"zip-filter/is-node?\",-1966970687),true)),null,(1),null)),preds);\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","clojure/data/zip.cljs","~:line",14,"~:column",3,"~:end-line",14,"~:end-column",19,"~:author","Chris Houser","~:doc","System for filtering trees and nodes generated by zip.clj in\n           general, and xml trees in particular."],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$create-react-class","~$module$node_modules$create_react_class$index","~$react-dom","~$module$node_modules$react_dom$index","~$clojure.spec.alpha","~$cljs.spec.alpha"],"~:use-macros",null,"~:excludes",["~#set",["~$descendants","~$ancestors"]],"~:name","~$clojure.data.zip","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$clojure.zip","^S","~$zip","^S","~$cljs.core","^U","~$goog","^V"],"~:seen",["^J",["~:require"]],"~:uses",null,"~:require-macros",["^ ","^U","^U"],"~:form",["~#list",["~$ns","^N",["^10",["~:refer-clojure","~:exclude",["^10",["^K","^L"]]]],["^10",["^X",["^S","~:as","^T"]]]]],"~:flags",["^ ","^X",["^J",[]]],"~:js-deps",["^ "],"~:deps",["^V","^U","^S"]],"^P","^N","~:resource-id",["~:shadow.build.classpath/resource","clojure/data/zip.cljs"],"~:compiled-at",1560836580772,"~:resource-name","clojure/data/zip.cljs","~:warnings",[],"~:source","; Copyright (c) Chris Houser, April 2008. All rights reserved.\n; The use and distribution terms for this software are covered by the\n; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n; which can be found in the file epl-v10.html at the root of this distribution.\n; By using this software in any fashion, you are agreeing to be bound by\n; the terms of this license.\n; You must not remove this notice, or any other, from this software.\n; System for filtering trees and nodes generated by zip.clj in\n; general, and xml trees in particular.\n\n(ns ^{:author \"Chris Houser\",\n      :doc \"System for filtering trees and nodes generated by zip.clj in\n           general, and xml trees in particular.\"}\n  clojure.data.zip\n  (:refer-clojure :exclude (descendants ancestors))\n  (:require [clojure.zip :as zip]))\n\n; This uses the negative form (no-auto) so that the result from any\n; naive function, including user functions, defaults to \"auto\".\n(defn auto\n  [v x] (with-meta x ((if v dissoc assoc) (meta x) :zip-filter/no-auto? true)))\n\n(defn auto?\n  [x] (not (:zip-filter/no-auto? (meta x))))\n\n(defn right-locs\n  \"Returns a lazy sequence of locations to the right of loc, starting with loc.\"\n  [loc] (lazy-seq (when loc (cons (auto false loc) (right-locs (zip/right loc))))))\n\n(defn left-locs\n  \"Returns a lazy sequence of locations to the left of loc, starting with loc.\"\n  [loc] (lazy-seq (when loc (cons (auto false loc) (left-locs (zip/left loc))))))\n\n(defn leftmost?\n  \"Returns true if there are no more nodes to the left of location loc.\"\n  [loc] (nil? (zip/left loc)))\n\n(defn rightmost?\n  \"Returns true if there are no more nodes to the right of location loc.\"\n  [loc] (nil? (zip/right loc)))\n\n(defn children\n  \"Returns a lazy sequence of all immediate children of location loc,\n  left-to-right.\"\n  [loc]\n  (when (zip/branch? loc)\n    (map #(auto false %) (right-locs (zip/down loc)))))\n\n(defn children-auto\n  \"Returns a lazy sequence of all immediate children of location loc,\n  left-to-right, marked so that a following tag= predicate will auto-descend.\"\n  ^{:private true}\n  [loc]\n  (when (zip/branch? loc)\n    (map #(auto true %) (right-locs (zip/down loc)))))\n\n(defn descendants\n  \"Returns a lazy sequence of all descendants of location loc, in\n  depth-first order, left-to-right, starting with loc.\"\n  [loc] (lazy-seq (cons (auto false loc) (mapcat descendants (children loc)))))\n\n(defn ancestors\n  \"Returns a lazy sequence of all ancestors of location loc, starting\n  with loc and proceeding to loc's parent node and on through to the\n  root of the tree.\"\n  [loc] (lazy-seq (when loc (cons (auto false loc) (ancestors (zip/up loc))))))\n\n(defn- fixup-apply\n  \"Calls (pred loc), and then converts the result to the 'appropriate'\n  sequence.\"\n  ^{:private true}\n  [pred loc]\n  (let [rtn (pred loc)]\n    (cond (and (map? (meta rtn)) (:zip-filter/is-node? (meta rtn))) (list rtn)\n          (= rtn true)                (list loc)\n          (= rtn false)               nil\n          (nil? rtn)                  nil\n          (sequential? rtn)           rtn\n          :else                       (list rtn))))\n\n(defn mapcat-chain\n  ^{:private true}\n  [loc preds mkpred]\n  (reduce (fn [prevseq expr]\n            (mapcat #(fixup-apply (or (mkpred expr) expr) %) prevseq))\n          (list (with-meta loc (assoc (meta loc) :zip-filter/is-node? true)))\n          preds))\n","~:reader-features",["^J",["~:cljs"]],"~:cljc",false,"~:source-map-compact",["^ ","mappings","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","names",["clojure.data.zip/auto","v","x","cljs.core/with-meta","G__29888","G__29889","G__29890","fexpr__29887","cljs.core/dissoc","cljs.core/assoc","cljs.core/meta","clojure.data.zip/auto?","cljs.core/not","clojure.data.zip/right-locs","loc","cljs.core/LazySeq","cljs.core/cons","G__29891","clojure.zip/right","clojure.data.zip/left-locs","G__29893","clojure.zip/left","clojure.data.zip/leftmost?","clojure.data.zip/rightmost?","clojure.data.zip/children","clojure.zip/branch?","p1__29894#","cljs.core.map.cljs$core$IFn$_invoke$arity$2","clojure.zip/down","clojure.data.zip/children-auto","p1__29895#","clojure.data.zip/descendants","cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic","clojure.data.zip/ancestors","G__29905","clojure.zip/up","clojure.data.zip/fixup-apply","pred","rtn","and__4120__auto__","cljs.core/map?","cljs.core/List","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/sequential?","clojure.data.zip/mapcat-chain","preds","mkpred","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","prevseq","expr","p1__29915#","or__4131__auto__","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3"]]],"~:cache-keys",["~#cmap",[["~:macro","^U"],[1559826623000],["^19","goog/math/math.js"],[1560546089000,"~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^J",[]],"~:deps-syms",["^V","~$goog.array","~$goog.asserts"]]],["^19","goog/array/array.js"],[1560546089000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V","^1L"]]],["^19","goog/debug/error.js"],[1560546089000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V"]]],["^19","goog/dom/nodetype.js"],[1560546089000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V"]]],["^19","goog/object/object.js"],[1560546089000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V"]]],"~:SHADOW-TIMESTAMP",[1560546091000,1559826623000],["^19","goog/math/long.js"],[1560546089000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V","^1L","~$goog.reflect"]]],["^19","goog/string/internal.js"],[1560546089000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V"]]],["^19","goog/functions/functions.js"],[1560546089000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V"]]],["^19","goog/structs/map.js"],[1560546089000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^19","goog/asserts/asserts.js"],[1560546089000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^19","goog/uri/uri.js"],[1560546089000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V","^1K","^1L","~$goog.string","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^19","goog/base.js"],[1560546089000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",[]]],["^19","goog/structs/structs.js"],[1560546089000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V","^1K","~$goog.object"]]],["^19","goog/string/string.js"],[1560546089000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V","~$goog.string.internal"]]],["^19","goog/reflect/reflect.js"],[1560546089000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V"]]],["^19","clojure/zip.cljs"],[1559826623000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V","^U"]]],["^19","goog/string/stringbuffer.js"],[1560546089000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V"]]],["^19","goog/iter/iter.js"],[1560546089000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V","^1K","^1L","~$goog.functions","~$goog.math"]]],["^19","clojure/data/zip.cljs"],[1551120970000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V","^U","^S"]]],["^19","cljs/core.cljs"],[1559826623000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["~$goog.math.Long","~$goog.math.Integer","^1S","^1Y","^1K","~$goog.Uri","~$goog.string.StringBuffer"]]],["^19","goog/math/integer.js"],[1560546089000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V"]]],["^19","goog/uri/utils.js"],[1560546089000,"^1G",["^ ","^1H",null,"^1I",["^J",[]],"^1J",["^V","^1K","^1L","^1S"]]]]],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","clojure/data/zip.cljs","^7",14,"^8",3,"^9",14,"^:",19,"^;","Chris Houser","^<","System for filtering trees and nodes generated by zip.clj in\n           general, and xml trees in particular."],"^=",["^ ","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G"],"^H",null,"^I",["^J",["^K","^L"]],"^M","^N","^Q",null,"^R",["^ ","^S","^S","^T","^S","^U","^U","^V","^V"],"^W",["^J",["^X"]],"^Y",null,"~:defs",["^ ","~$right-locs",["^ ","~:protocol-inline",null,"^5",["^ ","^6","clojure/data/zip.cljs","^7",26,"^8",7,"^9",26,"^:",17,"~:arglists",["^10",["~$quote",["^10",[["~$loc"]]]]],"^<","Returns a lazy sequence of locations to the right of loc, starting with loc."],"^M","~$clojure.data.zip/right-locs","^6","clojure/data/zip.cljs","^:",17,"~:method-params",["^10",[["^2;"]]],"~:protocol-impl",null,"~:arglists-meta",["^10",[null,null]],"^8",1,"~:variadic?",false,"^7",26,"~:ret-tag","~$cljs.core/LazySeq","^9",26,"~:max-fixed-arity",1,"~:fn-var",true,"^29",["^10",["^2:",["^10",[["^2;"]]]]],"^<","Returns a lazy sequence of locations to the right of loc, starting with loc."],"~$auto",["^ ","^28",null,"^5",["^ ","^6","clojure/data/zip.cljs","^7",20,"^8",7,"^9",20,"^:",11,"^29",["^10",["^2:",["^10",[["~$v","~$x"]]]]]],"^M","~$clojure.data.zip/auto","^6","clojure/data/zip.cljs","^:",11,"^2=",["^10",[["~$v","~$x"]]],"^2>",null,"^2?",["^10",[null,null]],"^8",1,"^2@",false,"^7",20,"^2A",["^J",["~$clj","~$cljs.core/MetaFn","~$clj-nil"]],"^9",20,"^2C",2,"^2D",true,"^29",["^10",["^2:",["^10",[["~$v","~$x"]]]]]],"~$fixup-apply",["^ ","^28",null,"^5",["^ ","^6","clojure/data/zip.cljs","^7",68,"^8",8,"^9",68,"^:",19,"~:private",true,"^29",["^10",["^2:",["^10",[["~$pred","^2;"]]]]],"^<","Calls (pred loc), and then converts the result to the 'appropriate'\n  sequence."],"^2K",true,"^M","~$clojure.data.zip/fixup-apply","^6","clojure/data/zip.cljs","^:",19,"^2=",["^10",[["^2L","^2;"]]],"^2>",null,"^2?",["^10",[null,null]],"^8",1,"^2@",false,"^7",68,"^2A",["^J",["^2G","~$cljs.core/List","^2I"]],"^9",68,"^2C",2,"^2D",true,"^29",["^10",["^2:",["^10",[["^2L","^2;"]]]]],"^<","Calls (pred loc), and then converts the result to the 'appropriate'\n  sequence."],"~$children-auto",["^ ","^28",null,"^5",["^ ","^6","clojure/data/zip.cljs","^7",49,"^8",7,"^9",49,"^:",20,"^29",["^10",["^2:",["^10",[["^2;"]]]]],"^<","Returns a lazy sequence of all immediate children of location loc,\n  left-to-right, marked so that a following tag= predicate will auto-descend."],"^M","~$clojure.data.zip/children-auto","^6","clojure/data/zip.cljs","^:",20,"^2=",["^10",[["^2;"]]],"^2>",null,"^2?",["^10",[null,null]],"^8",1,"^2@",false,"^7",49,"^2A",["^J",["^2B","^2I"]],"^9",49,"^2C",1,"^2D",true,"^29",["^10",["^2:",["^10",[["^2;"]]]]],"^<","Returns a lazy sequence of all immediate children of location loc,\n  left-to-right, marked so that a following tag= predicate will auto-descend."],"~$children",["^ ","^28",null,"^5",["^ ","^6","clojure/data/zip.cljs","^7",42,"^8",7,"^9",42,"^:",15,"^29",["^10",["^2:",["^10",[["^2;"]]]]],"^<","Returns a lazy sequence of all immediate children of location loc,\n  left-to-right."],"^M","~$clojure.data.zip/children","^6","clojure/data/zip.cljs","^:",15,"^2=",["^10",[["^2;"]]],"^2>",null,"^2?",["^10",[null,null]],"^8",1,"^2@",false,"^7",42,"^2A",["^J",["^2B","^2I"]],"^9",42,"^2C",1,"^2D",true,"^29",["^10",["^2:",["^10",[["^2;"]]]]],"^<","Returns a lazy sequence of all immediate children of location loc,\n  left-to-right."],"~$rightmost?",["^ ","^28",null,"^5",["^ ","^6","clojure/data/zip.cljs","^7",38,"^8",7,"^9",38,"^:",17,"^29",["^10",["^2:",["^10",[["^2;"]]]]],"^<","Returns true if there are no more nodes to the right of location loc."],"^M","~$clojure.data.zip/rightmost?","^6","clojure/data/zip.cljs","^:",17,"^2=",["^10",[["^2;"]]],"^2>",null,"^2?",["^10",[null,null]],"^8",1,"^2@",false,"^7",38,"^2A","~$boolean","^9",38,"^2C",1,"^2D",true,"^29",["^10",["^2:",["^10",[["^2;"]]]]],"^<","Returns true if there are no more nodes to the right of location loc."],"~$mapcat-chain",["^ ","^28",null,"^5",["^ ","^6","clojure/data/zip.cljs","^7",81,"^8",7,"^9",81,"^:",19,"^29",["^10",["^2:",["^10",[["^2;","~$preds","~$mkpred"]]]]]],"^M","~$clojure.data.zip/mapcat-chain","^6","clojure/data/zip.cljs","^:",19,"^2=",["^10",[["^2;","^2W","^2X"]]],"^2>",null,"^2?",["^10",[null,null]],"^8",1,"^2@",false,"^7",81,"^2A",["^J",[null,"~$any"]],"^9",81,"^2C",3,"^2D",true,"^29",["^10",["^2:",["^10",[["^2;","^2W","^2X"]]]]]],"~$auto?",["^ ","^28",null,"^5",["^ ","^6","clojure/data/zip.cljs","^7",23,"^8",7,"^9",23,"^:",12,"^29",["^10",["^2:",["^10",[["~$x"]]]]]],"^M","~$clojure.data.zip/auto?","^6","clojure/data/zip.cljs","^:",12,"^2=",["^10",[["~$x"]]],"^2>",null,"^2?",["^10",[null,null]],"^8",1,"^2@",false,"^7",23,"^2A","^2U","^9",23,"^2C",1,"^2D",true,"^29",["^10",["^2:",["^10",[["~$x"]]]]]],"~$left-locs",["^ ","^28",null,"^5",["^ ","^6","clojure/data/zip.cljs","^7",30,"^8",7,"^9",30,"^:",16,"^29",["^10",["^2:",["^10",[["^2;"]]]]],"^<","Returns a lazy sequence of locations to the left of loc, starting with loc."],"^M","~$clojure.data.zip/left-locs","^6","clojure/data/zip.cljs","^:",16,"^2=",["^10",[["^2;"]]],"^2>",null,"^2?",["^10",[null,null]],"^8",1,"^2@",false,"^7",30,"^2A","^2B","^9",30,"^2C",1,"^2D",true,"^29",["^10",["^2:",["^10",[["^2;"]]]]],"^<","Returns a lazy sequence of locations to the left of loc, starting with loc."],"^K",["^ ","^28",null,"^5",["^ ","^6","clojure/data/zip.cljs","^7",57,"^8",7,"^9",57,"^:",18,"^29",["^10",["^2:",["^10",[["^2;"]]]]],"^<","Returns a lazy sequence of all descendants of location loc, in\n  depth-first order, left-to-right, starting with loc."],"^M","~$clojure.data.zip/descendants","^6","clojure/data/zip.cljs","^:",18,"^2=",["^10",[["^2;"]]],"^2>",null,"^2?",["^10",[null,null]],"^8",1,"^2@",false,"^7",57,"^2A","^2B","^9",57,"^2C",1,"^2D",true,"^29",["^10",["^2:",["^10",[["^2;"]]]]],"^<","Returns a lazy sequence of all descendants of location loc, in\n  depth-first order, left-to-right, starting with loc."],"^L",["^ ","^28",null,"^5",["^ ","^6","clojure/data/zip.cljs","^7",62,"^8",7,"^9",62,"^:",16,"^29",["^10",["^2:",["^10",[["^2;"]]]]],"^<","Returns a lazy sequence of all ancestors of location loc, starting\n  with loc and proceeding to loc's parent node and on through to the\n  root of the tree."],"^M","~$clojure.data.zip/ancestors","^6","clojure/data/zip.cljs","^:",16,"^2=",["^10",[["^2;"]]],"^2>",null,"^2?",["^10",[null,null]],"^8",1,"^2@",false,"^7",62,"^2A","^2B","^9",62,"^2C",1,"^2D",true,"^29",["^10",["^2:",["^10",[["^2;"]]]]],"^<","Returns a lazy sequence of all ancestors of location loc, starting\n  with loc and proceeding to loc's parent node and on through to the\n  root of the tree."],"~$leftmost?",["^ ","^28",null,"^5",["^ ","^6","clojure/data/zip.cljs","^7",34,"^8",7,"^9",34,"^:",16,"^29",["^10",["^2:",["^10",[["^2;"]]]]],"^<","Returns true if there are no more nodes to the left of location loc."],"^M","~$clojure.data.zip/leftmost?","^6","clojure/data/zip.cljs","^:",16,"^2=",["^10",[["^2;"]]],"^2>",null,"^2?",["^10",[null,null]],"^8",1,"^2@",false,"^7",34,"^2A","^2U","^9",34,"^2C",1,"^2D",true,"^29",["^10",["^2:",["^10",[["^2;"]]]]],"^<","Returns true if there are no more nodes to the left of location loc."]],"^Z",["^ ","^U","^U"],"~:cljs.analyzer/constants",["^ ","^W",["^J",["~:zip-filter/is-node?","~:else","~:zip-filter/no-auto?"]],"~:order",["^3:","^38","^39"]],"^15",["^ ","^X",["^J",[]]],"^16",["^ "],"^17",["^V","^U","^S"]],"^P","^N","~:ns-specs",["^ "],"~:ns-speced-vars",[],"~:compiler-options",["^1E",[["^3>","~:static-fns"],true,["^3>","~:elide-asserts"],true,["^3>","~:optimize-constants"],null,["^3>","^1<"],null,["^3>","~:external-config"],null,["^3>","~:tooling-config"],null,["^3>","~:emit-constants"],null,["^3>","~:load-tests"],false,["^3>","~:infer-externs"],"~:auto",["^3>","^1>"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:release",["^3>","~:fn-invoke-direct"],null,["^3>","~:source-map"],null]]]