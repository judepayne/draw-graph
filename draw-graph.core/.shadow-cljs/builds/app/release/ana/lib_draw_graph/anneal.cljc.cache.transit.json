["^ ","~:output",["^ ","~:js","goog.provide('lib_draw_graph.anneal');\nlib_draw_graph.anneal.max_move_default = (14);\nlib_draw_graph.anneal.PEN = (1000000);\nlib_draw_graph.anneal.annealing = (function lib_draw_graph$anneal$annealing(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___36551 = arguments.length;\nvar i__4731__auto___36552 = (0);\nwhile(true){\nif((i__4731__auto___36552 < len__4730__auto___36551)){\nargs__4736__auto__.push((arguments[i__4731__auto___36552]));\n\nvar G__36553 = (i__4731__auto___36552 + (1));\ni__4731__auto___36552 = G__36553;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((8) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((8)),(0),null)):null);\nreturn lib_draw_graph.anneal.annealing.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),argseq__4737__auto__);\n});\n\nlib_draw_graph.anneal.annealing.cljs$core$IFn$_invoke$arity$variadic = (function (initial,max_iter,min_cost,constraints,neighbor_fn,cost_fn,p_fn,temp_fn,p__36481){\nvar map__36482 = p__36481;\nvar map__36482__$1 = (((((!((map__36482 == null))))?(((((map__36482.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__36482.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__36482):map__36482);\nvar dims = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__36482__$1,new cljs.core.Keyword(null,\"dims\",\"dims\",-466522889),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"x\",\"x\",2099068185),new cljs.core.Keyword(null,\"y\",\"y\",-1757859776),new cljs.core.Keyword(null,\"w\",\"w\",354169001),new cljs.core.Keyword(null,\"h\",\"h\",1109658740)], null));\nvar terminate_early_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__36482__$1,new cljs.core.Keyword(null,\"terminate-early?\",\"terminate-early?\",-74748151),false);\nvar x_retard = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__36482__$1,new cljs.core.Keyword(null,\"x-retard\",\"x-retard\",1308817436),null);\nvar y_retard = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__36482__$1,new cljs.core.Keyword(null,\"y-retard\",\"y-retard\",1549838503),null);\nvar max_move = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__36482__$1,new cljs.core.Keyword(null,\"max-move\",\"max-move\",-879805405),(14));\nvar cost = (cost_fn.cljs$core$IFn$_invoke$arity$2 ? cost_fn.cljs$core$IFn$_invoke$arity$2(constraints,initial) : cost_fn.call(null,constraints,initial));\nvar last_cost = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cost);\nvar state = initial;\nvar cost__$1 = cost;\nvar k = (1);\nwhile(true){\nif(cljs.core.truth_((function (){var and__4120__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((0),cljs.core.rem(k,(500)));\nif(and__4120__auto__){\nvar and__4120__auto____$1 = terminate_early_QMARK_;\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn (1.0E-4 > (function (){var lc = cljs.core.deref(last_cost);\nvar del_cost = ((lc - cost__$1) / cost__$1);\ncljs.core.reset_BANG_(last_cost,cost__$1);\n\nreturn del_cost;\n})());\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn state;\n} else {\nif((((k < max_iter)) && ((cost__$1 > min_cost)))){\nvar t = (function (){var G__36491 = (k / max_iter);\nreturn (temp_fn.cljs$core$IFn$_invoke$arity$1 ? temp_fn.cljs$core$IFn$_invoke$arity$1(G__36491) : temp_fn.call(null,G__36491));\n})();\nvar next_state = (neighbor_fn.cljs$core$IFn$_invoke$arity$5 ? neighbor_fn.cljs$core$IFn$_invoke$arity$5(state,dims,x_retard,y_retard,max_move) : neighbor_fn.call(null,state,dims,x_retard,y_retard,max_move));\nvar next_cost = (function (){var G__36492 = constraints;\nvar G__36493 = state;\nvar G__36494 = cljs.core.second(next_state);\nvar G__36495 = cljs.core.first(next_state);\nreturn (cost_fn.cljs$core$IFn$_invoke$arity$4 ? cost_fn.cljs$core$IFn$_invoke$arity$4(G__36492,G__36493,G__36494,G__36495) : cost_fn.call(null,G__36492,G__36493,G__36494,G__36495));\n})();\nif(((p_fn.cljs$core$IFn$_invoke$arity$3 ? p_fn.cljs$core$IFn$_invoke$arity$3(cost__$1,next_cost,t) : p_fn.call(null,cost__$1,next_cost,t)) > cljs.core.rand.cljs$core$IFn$_invoke$arity$0())){\nvar G__36554 = cljs.core.second(next_state);\nvar G__36555 = next_cost;\nvar G__36556 = (k + (1));\nstate = G__36554;\ncost__$1 = G__36555;\nk = G__36556;\ncontinue;\n} else {\nvar G__36557 = state;\nvar G__36558 = cost__$1;\nvar G__36559 = (k + (1));\nstate = G__36557;\ncost__$1 = G__36558;\nk = G__36559;\ncontinue;\n}\n} else {\nreturn state;\n}\n}\nbreak;\n}\n});\n\nlib_draw_graph.anneal.annealing.cljs$lang$maxFixedArity = (8);\n\n/** @this {Function} */\nlib_draw_graph.anneal.annealing.cljs$lang$applyTo = (function (seq36467){\nvar G__36468 = cljs.core.first(seq36467);\nvar seq36467__$1 = cljs.core.next(seq36467);\nvar G__36469 = cljs.core.first(seq36467__$1);\nvar seq36467__$2 = cljs.core.next(seq36467__$1);\nvar G__36470 = cljs.core.first(seq36467__$2);\nvar seq36467__$3 = cljs.core.next(seq36467__$2);\nvar G__36471 = cljs.core.first(seq36467__$3);\nvar seq36467__$4 = cljs.core.next(seq36467__$3);\nvar G__36472 = cljs.core.first(seq36467__$4);\nvar seq36467__$5 = cljs.core.next(seq36467__$4);\nvar G__36473 = cljs.core.first(seq36467__$5);\nvar seq36467__$6 = cljs.core.next(seq36467__$5);\nvar G__36474 = cljs.core.first(seq36467__$6);\nvar seq36467__$7 = cljs.core.next(seq36467__$6);\nvar G__36475 = cljs.core.first(seq36467__$7);\nvar seq36467__$8 = cljs.core.next(seq36467__$7);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__36468,G__36469,G__36470,G__36471,G__36472,G__36473,G__36474,G__36475,seq36467__$8);\n});\n\nlib_draw_graph.anneal.random_move = (function lib_draw_graph$anneal$random_move(max_move){\n\nvar small_move_prob = (3);\nvar small_move = (5);\nvar mm = ((((cljs.core.rand_int(small_move_prob) + (1)) > (small_move_prob - (1))))?small_move:max_move);\nreturn (cljs.core.rand_int(((2) * mm)) - mm);\n});\n/**\n * When a rectangle/ polygon is defined with a point, width and height\n *   (as opposed to two points), when varying the x or y of the point, it\n *   is necessary to adjust the width or height as well to be consistent\n *   with a rectangle/ polygon specified as two x,y points.\n */\nlib_draw_graph.anneal.vary_rect = (function lib_draw_graph$anneal$vary_rect(rect,dims,x_retard,y_retard,max_move){\nvar dim = cljs.core.rand_nth(dims);\nvar delta = lib_draw_graph.anneal.random_move(max_move);\nvar G__36507 = dim;\nvar G__36507__$1 = (((G__36507 instanceof cljs.core.Keyword))?G__36507.fqn:null);\nswitch (G__36507__$1) {\ncase \"x\":\nif(cljs.core.truth_((function (){var and__4120__auto__ = x_retard;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (!((x_retard === (0))));\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(rect,new cljs.core.Keyword(null,\"x\",\"x\",2099068185),(new cljs.core.Keyword(null,\"x\",\"x\",2099068185).cljs$core$IFn$_invoke$arity$1(rect) + cljs.core.quot(delta,x_retard))),new cljs.core.Keyword(null,\"w\",\"w\",354169001),(new cljs.core.Keyword(null,\"w\",\"w\",354169001).cljs$core$IFn$_invoke$arity$1(rect) - cljs.core.quot(delta,x_retard)));\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(rect,new cljs.core.Keyword(null,\"x\",\"x\",2099068185),(new cljs.core.Keyword(null,\"x\",\"x\",2099068185).cljs$core$IFn$_invoke$arity$1(rect) + delta)),new cljs.core.Keyword(null,\"w\",\"w\",354169001),(new cljs.core.Keyword(null,\"w\",\"w\",354169001).cljs$core$IFn$_invoke$arity$1(rect) - delta));\n}\n\nbreak;\ncase \"y\":\nif(cljs.core.truth_((function (){var and__4120__auto__ = y_retard;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (!((y_retard === (0))));\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(rect,new cljs.core.Keyword(null,\"y\",\"y\",-1757859776),(new cljs.core.Keyword(null,\"y\",\"y\",-1757859776).cljs$core$IFn$_invoke$arity$1(rect) + cljs.core.quot(delta,y_retard))),new cljs.core.Keyword(null,\"h\",\"h\",1109658740),(new cljs.core.Keyword(null,\"h\",\"h\",1109658740).cljs$core$IFn$_invoke$arity$1(rect) - cljs.core.quot(delta,y_retard)));\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(rect,new cljs.core.Keyword(null,\"y\",\"y\",-1757859776),(new cljs.core.Keyword(null,\"y\",\"y\",-1757859776).cljs$core$IFn$_invoke$arity$1(rect) + delta)),new cljs.core.Keyword(null,\"h\",\"h\",1109658740),(new cljs.core.Keyword(null,\"h\",\"h\",1109658740).cljs$core$IFn$_invoke$arity$1(rect) - delta));\n}\n\nbreak;\ncase \"w\":\nif(cljs.core.truth_((function (){var and__4120__auto__ = x_retard;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (!((x_retard === (0))));\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(rect,new cljs.core.Keyword(null,\"w\",\"w\",354169001),(new cljs.core.Keyword(null,\"w\",\"w\",354169001).cljs$core$IFn$_invoke$arity$1(rect) + cljs.core.quot(delta,x_retard)));\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(rect,new cljs.core.Keyword(null,\"w\",\"w\",354169001),(new cljs.core.Keyword(null,\"w\",\"w\",354169001).cljs$core$IFn$_invoke$arity$1(rect) + delta));\n}\n\nbreak;\ndefault:\nif(cljs.core.truth_((function (){var and__4120__auto__ = y_retard;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn (!((y_retard === (0))));\n} else {\nreturn and__4120__auto__;\n}\n})())){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(rect,new cljs.core.Keyword(null,\"h\",\"h\",1109658740),(new cljs.core.Keyword(null,\"h\",\"h\",1109658740).cljs$core$IFn$_invoke$arity$1(rect) + cljs.core.quot(delta,y_retard)));\n} else {\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(rect,new cljs.core.Keyword(null,\"h\",\"h\",1109658740),(new cljs.core.Keyword(null,\"h\",\"h\",1109658740).cljs$core$IFn$_invoke$arity$1(rect) + delta));\n}\n\n}\n});\n/**\n * Varies a random item from state and returns the new state\n *   after checking that the new state passes constraints.\n */\nlib_draw_graph.anneal.neighbor_fn = (function lib_draw_graph$anneal$neighbor_fn(state,dims,x_retard,y_retard,max_move){\nvar k = cljs.core.rand_nth(cljs.core.keys(state));\nvar next = lib_draw_graph.anneal.vary_rect(cljs.core.get.cljs$core$IFn$_invoke$arity$2(state,k),dims,x_retard,y_retard,max_move);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [k,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(state,k,next)], null);\n});\n/**\n * Checks that the new (proposed) state item satisfies constraints.\n */\nlib_draw_graph.anneal.passes_constraints_QMARK_ = (function lib_draw_graph$anneal$passes_constraints_QMARK_(constraints,state,next_state,varied){\nvar prev_item = cljs.core.get.cljs$core$IFn$_invoke$arity$2(state,varied);\nvar item = cljs.core.get.cljs$core$IFn$_invoke$arity$2(next_state,varied);\nvar others = cljs.core.vals(cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(next_state,varied));\nvar sep = new cljs.core.Keyword(null,\"collision\",\"collision\",-201625508).cljs$core$IFn$_invoke$arity$1(constraints);\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (prev_item,item,others,sep){\nreturn (function (a,p__36526){\nvar vec__36527 = p__36526;\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__36527,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__36527,(1),null);\nvar and__4120__auto__ = a;\nif(cljs.core.truth_(and__4120__auto__)){\nvar G__36531 = k;\nvar G__36531__$1 = (((G__36531 instanceof cljs.core.Keyword))?G__36531.fqn:null);\nswitch (G__36531__$1) {\ncase \"grow\":\nif(cljs.core.truth_(v)){\nreturn lib_draw_graph.geometry.bigger_QMARK_(prev_item,item);\n} else {\nreturn true;\n}\n\nbreak;\ncase \"boundary\":\nreturn lib_draw_graph.geometry.inside_QMARK_(v,item);\n\nbreak;\ncase \"collision\":\nif(cljs.core.truth_(sep)){\nreturn cljs.core.not_any_QMARK_(((function (G__36531,G__36531__$1,and__4120__auto__,vec__36527,k,v,prev_item,item,others,sep){\nreturn (function (p1__36517_SHARP_){\nreturn lib_draw_graph.geometry.overlaps_QMARK_(sep,item,p1__36517_SHARP_);\n});})(G__36531,G__36531__$1,and__4120__auto__,vec__36527,k,v,prev_item,item,others,sep))\n,others);\n} else {\nreturn true;\n}\n\nbreak;\ncase \"obstacles\":\nif(cljs.core.truth_((function (){var and__4120__auto____$1 = v;\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn sep;\n} else {\nreturn and__4120__auto____$1;\n}\n})())){\nreturn cljs.core.not_any_QMARK_(((function (G__36531,G__36531__$1,and__4120__auto__,vec__36527,k,v,prev_item,item,others,sep){\nreturn (function (p1__36518_SHARP_){\nreturn lib_draw_graph.geometry.overlaps_QMARK_(sep,item,p1__36518_SHARP_);\n});})(G__36531,G__36531__$1,and__4120__auto__,vec__36527,k,v,prev_item,item,others,sep))\n,cljs.core.vals(v));\n} else {\nreturn true;\n}\n\nbreak;\ndefault:\nthrow (new Error([\"No matching clause: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(G__36531__$1)].join('')));\n\n}\n} else {\nreturn and__4120__auto__;\n}\n});})(prev_item,item,others,sep))\n,true,constraints);\n});\n/**\n * Calculates cost, which is total bounded area minus sum of current areas.\n *   For the initial call to calculate the system's cost, requires only constraints and state.\n *   Subsequent calls require the state, next-state and k, the key of the entry that has\n *   changed between them.\n */\nlib_draw_graph.anneal.cost_fn = (function lib_draw_graph$anneal$cost_fn(var_args){\nvar G__36543 = arguments.length;\nswitch (G__36543) {\ncase 2:\nreturn lib_draw_graph.anneal.cost_fn.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 4:\nreturn lib_draw_graph.anneal.cost_fn.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nlib_draw_graph.anneal.cost_fn.cljs$core$IFn$_invoke$arity$2 = (function (constraints,state){\nvar boundary = new cljs.core.Keyword(null,\"boundary\",\"boundary\",-2000996754).cljs$core$IFn$_invoke$arity$1(constraints);\nif(cljs.core.empty_QMARK_(boundary)){\nthrow lib_draw_graph.util.err(\"no boundary condition!\");\n} else {\nvar bounded_area = lib_draw_graph.geometry.area(boundary);\nreturn (bounded_area - cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (bounded_area,boundary){\nreturn (function (a,c){\nreturn (a + lib_draw_graph.geometry.area(c));\n});})(bounded_area,boundary))\n,(0),cljs.core.vals(state)));\n}\n});\n\nlib_draw_graph.anneal.cost_fn.cljs$core$IFn$_invoke$arity$4 = (function (constraints,state,next_state,k){\nvar bounded_area = lib_draw_graph.geometry.area(new cljs.core.Keyword(null,\"boundary\",\"boundary\",-2000996754).cljs$core$IFn$_invoke$arity$1(constraints));\nvar cost = (bounded_area - cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(((function (bounded_area){\nreturn (function (a,c){\nreturn (a + lib_draw_graph.geometry.area(c));\n});})(bounded_area))\n,(0),cljs.core.vals(next_state)));\nvar penalty = (cljs.core.truth_(lib_draw_graph.anneal.passes_constraints_QMARK_(constraints,state,next_state,k))?(0):(1000000));\nreturn (cost + penalty);\n});\n\nlib_draw_graph.anneal.cost_fn.cljs$lang$maxFixedArity = 4;\n\n/**\n * the temperature. r should be between 0 and 1\n */\nlib_draw_graph.anneal.temp_fn = (function lib_draw_graph$anneal$temp_fn(r){\nreturn (1.0 - r);\n});\n/**\n * the probability of a move function, using Boltzmann\n */\nlib_draw_graph.anneal.p_fn = (function lib_draw_graph$anneal$p_fn(c0,c1,t){\nvar diff = (c1 - c0);\nif((c1 < c0)){\nreturn (1);\n} else {\nvar G__36550 = ((-1) * (diff / t));\nreturn Math.exp(G__36550);\n}\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","lib_draw_graph/anneal.cljc","~:line",3,"~:column",3,"~:end-line",3,"~:end-column",24,"~:doc","Simulated annealing for cluster layout.","~:author","Jude Payne"],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$create-react-class","~$module$node_modules$create_react_class$index","~$react-dom","~$module$node_modules$react_dom$index","~$clojure.spec.alpha","~$cljs.spec.alpha"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$lib-draw-graph.anneal","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$lib-draw-graph.geometry","^Q","~$lib-draw-graph.util","^R","~$util","^R","~$cljs.core","^T","~$goog","^U"],"~:seen",["^J",["~:require"]],"~:uses",["^ ","~$overlaps?","^Q","~$inside?","^Q","~$bigger?","^Q","~$area","^Q"],"~:require-macros",["^ ","^T","^T"],"~:form",["~#list",["~$ns","^L",["^13",["^W",["^Q","~:refer",["^Y","^Z","^[","^10"]],["^R","~:as","^S"]]]]],"~:flags",["^ ","^W",["^J",[]]],"~:js-deps",["^ "],"~:deps",["^U","^T","^Q","^R"]],"^N","^L","~:resource-id",["~:shadow.build.classpath/resource","lib_draw_graph/anneal.cljc"],"~:compiled-at",1560888084614,"~:resource-name","lib_draw_graph/anneal.cljc","~:warnings",[],"~:source","(ns ^{:doc \"Simulated annealing for cluster layout.\"\n      :author \"Jude Payne\"}\n  lib-draw-graph.anneal\n  (:require [lib-draw-graph.geometry :refer [overlaps? inside? bigger? area]]\n            [lib-draw-graph.util     :as util]))\n\n\n#?(:clj (import [java.lang Math]))\n\n\n;; Annealing constants\n\n(def ^:const max-move-default 14)         ;; default move amount +/- dim can be changed by\n(def ^:const PEN 1000000)                ;; Penalty cost amount\n\n\n;; From Clojure data analysis cookbook\n(defn annealing\n\n  ([initial          ;; the initial state of the system\n    max-iter         ;; maximum numbers of iterations\n    min-cost         ;; the target minimum cost of the system\n    constraints      ;; constraints that a new state must satisfy\n    neighbor-fn      ;; the 'next-step' function\n    cost-fn          ;; the cost function\n    p-fn             ;; the probability of a move function\n    temp-fn          ;; the temperature of the system\n    & {:keys [dims terminate-early? x-retard y-retard max-move]\n       :or {dims [:x :y :w :h] terminate-early? false\n            x-retard nil y-retard nil\n            max-move max-move-default}}]\n   (let [cost (cost-fn constraints initial)\n         last-cost (atom cost)]\n     (loop [state initial\n            cost cost\n            k 1]\n       ;; check every 500 reps that cost has changed more than 0.01%\n       (if (and (= 0 (rem k 500))\n                terminate-early?\n                (> 0.0001 (let [lc @last-cost\n                              del-cost (/ (- lc cost) cost)]\n                            (reset! last-cost cost)\n                            del-cost)))\n         state\n\n         ;; if it hasn't, loop the annealing function\n         (if (and (< k max-iter)\n                  (> cost min-cost))\n           (let [t (temp-fn (/ k max-iter))\n                 next-state (neighbor-fn state dims x-retard y-retard max-move)\n                 next-cost (cost-fn constraints state\n                                    (second next-state) (first next-state))]\n             (if (> (p-fn cost next-cost t) (rand))\n               (recur (second next-state) next-cost (inc k))\n               (recur state cost (inc k))))\n           state))))))\n\n\n(defn random-move\n  [max-move]\n  \"Returns a random +/- amount less than max-move. Every so often, we\n   throw in small amounts to help fine tuning at the end of annealing.\"\n  (let [small-move-prob 3      ;; i.e. 1 in n chance\n        small-move 5\n        mm (if (> (inc (rand-int small-move-prob)) (dec small-move-prob))\n             small-move\n             max-move)]\n    (- (rand-int (* 2 mm)) mm)))\n\n\n(defn- vary-rect\n  \"When a rectangle/ polygon is defined with a point, width and height\n  (as opposed to two points), when varying the x or y of the point, it\n  is necessary to adjust the width or height as well to be consistent\n  with a rectangle/ polygon specified as two x,y points.\"\n  [rect dims x-retard y-retard max-move]\n  (let [dim (rand-nth dims)\n        delta (random-move max-move)]\n    (case dim\n      :x (if (and x-retard (not (zero? x-retard)))\n           (-> rect\n               (assoc :x (+ (:x rect) (quot delta x-retard))) \n               (assoc :w (- (:w rect) (quot delta x-retard))))\n           (-> rect\n               (assoc :x (+ (:x rect) delta)) \n               (assoc :w (- (:w rect) delta))))\n      :y (if (and y-retard (not (zero? y-retard)))\n           (-> rect\n               (assoc :y (+ (:y rect) (quot delta y-retard)))\n               (assoc :h (- (:h rect) (quot delta y-retard))))\n           (-> rect\n               (assoc :y (+ (:y rect) delta))\n               (assoc :h (- (:h rect) delta))))\n      :w (if (and x-retard (not (zero? x-retard)))\n           (-> rect\n               (assoc :w (+ (:w rect) (quot delta x-retard))))\n           (-> rect\n               (assoc :w (+ (:w rect) delta))))\n      (if (and y-retard (not (zero? y-retard)))\n        (-> rect (assoc :h (+ (:h rect) (quot delta y-retard))))\n        (-> rect (assoc :h (+ (:h rect) delta)))))))\n\n\n(defn neighbor-fn\n  \"Varies a random item from state and returns the new state\n  after checking that the new state passes constraints.\"\n  [state dims x-retard y-retard max-move]\n  (let [k (rand-nth (keys state))\n        next (vary-rect (get state k) dims x-retard y-retard max-move)]\n    [k (assoc state k next)]))\n\n\n(defn- passes-constraints?\n  \"Checks that the new (proposed) state item satisfies constraints.\"\n  [constraints state next-state varied]\n  (let [prev-item (get state varied)\n        item (get next-state varied)\n        others (vals (dissoc next-state varied))\n        sep (:collision constraints)]\n    (reduce\n     (fn [a [k v]]\n       (and a\n            (case k\n              :grow      (if v (bigger? prev-item item) true)\n              :boundary  (inside? v item)\n              :collision (if sep (not-any? #(overlaps? sep item %) others) true)\n              :obstacles (if (and v sep) (not-any? #(overlaps? sep item %) (vals v)) true))))\n     true\n     constraints)))\n\n\n\n\n(defn cost-fn\n  \"Calculates cost, which is total bounded area minus sum of current areas.\n  For the initial call to calculate the system's cost, requires only constraints and state.\n  Subsequent calls require the state, next-state and k, the key of the entry that has\n  changed between them.\"\n  ([constraints state]\n   (let [boundary (:boundary constraints)]\n     (if (empty? boundary)\n       (throw (util/err \"no boundary condition!\"))\n       (let [bounded-area (area boundary)]\n         (- bounded-area (reduce (fn [a c] (+ a (area c))) 0 (vals state)))))))\n\n  ([constraints state next-state k]\n   (let [bounded-area (area (:boundary constraints))\n         cost (- bounded-area (reduce (fn [a c] (+ a (area c))) 0 (vals next-state)))\n         penalty (if (passes-constraints? constraints state next-state k) 0 PEN)]\n     (+ cost penalty))))\n\n\n(defn temp-fn\n  \"the temperature. r should be between 0 and 1\"\n  [r]\n  (- 1.0 (float r)))\n\n\n(defn p-fn  \"the probability of a move function, using Boltzmann\"\n  [c0 c1 t]\n  (let [diff (- c1 c0)]\n    (if (< c1 c0)\n      1\n      (Math/exp (* -1 (/ diff t))))))\n","~:reader-features",["^J",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["lib-draw-graph.anneal/max-move-default","lib-draw-graph.anneal/PEN","var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","lib-draw-graph.anneal/annealing","p__36481","map__36482","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$3","seq36467","G__36468","cljs.core/first","cljs.core/next","G__36469","G__36470","G__36471","G__36472","G__36473","G__36474","G__36475","self__4717__auto__","initial","max-iter","min-cost","constraints","neighbor-fn","cost-fn","p-fn","temp-fn","dims","terminate-early?","x-retard","y-retard","max-move","cost","last-cost","cljs.core.atom.cljs$core$IFn$_invoke$arity$1","state","k","and__4120__auto__","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/rem","cljs.core/deref","lc","del-cost","cljs.core/reset!","t","G__36491","next-state","next-cost","G__36492","G__36493","G__36494","G__36495","cljs.core/second","cljs.core.rand.cljs$core$IFn$_invoke$arity$0","lib-draw-graph.anneal/random-move","small-move-prob","small-move","mm","cljs.core/rand-int","lib-draw-graph.anneal/vary-rect","rect","dim","cljs.core/rand-nth","delta","G__36507","cljs.core/Keyword","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","cljs.core/quot","lib-draw-graph.anneal/neighbor-fn","cljs.core/keys","next","cljs.core.get.cljs$core$IFn$_invoke$arity$2","lib-draw-graph.anneal/passes-constraints?","varied","prev-item","item","others","cljs.core/vals","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","sep","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","p__36526","vec__36527","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","a","v","G__36531","js/Error","lib-draw-graph.geometry/bigger?","lib-draw-graph.geometry/inside?","p1__36517#","cljs.core/not-any?","lib-draw-graph.geometry/overlaps?","p1__36518#","G__36543","lib-draw-graph.anneal/cost-fn","boundary","cljs.core/empty?","lib-draw-graph.util/err","bounded-area","lib-draw-graph.geometry/area","c","penalty","lib-draw-graph.anneal/temp-fn","r","lib-draw-graph.anneal/p-fn","c0","c1","diff","G__36550","Math/exp"]]],"~:cache-keys",["~#cmap",[["~:macro","^T"],[1559826623000],["^1;","goog/math/math.js"],[1560546089000,"~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^J",[]],"~:deps-syms",["^U","~$goog.array","~$goog.asserts"]]],["^1;","goog/array/array.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U","^1N"]]],["^1;","goog/debug/error.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U"]]],["^1;","goog/dom/nodetype.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U"]]],["^1;","goog/object/object.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U"]]],"~:SHADOW-TIMESTAMP",[1560546091000,1559826623000],["^1;","goog/math/long.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U","^1N","~$goog.reflect"]]],["^1;","goog/string/internal.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U"]]],["^1;","goog/functions/functions.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U"]]],["^1;","goog/structs/map.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^1;","lib_draw_graph/anneal.cljc"],[1560887308000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U","^T","^Q","^R"]]],["^1;","goog/asserts/asserts.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1;","goog/uri/uri.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U","^1M","^1N","~$goog.string","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1;","goog/base.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",[]]],["^1;","goog/structs/structs.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U","^1M","~$goog.object"]]],["^1;","goog/string/string.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U","~$goog.string.internal"]]],["^1;","goog/reflect/reflect.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U"]]],["^1;","lib_draw_graph/geometry.cljc"],[1560887308000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U","^T"]]],["^1;","goog/string/stringbuffer.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U"]]],["^1;","goog/iter/iter.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U","^1M","^1N","~$goog.functions","~$goog.math"]]],["^1;","cljs/core.cljs"],[1559826623000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["~$goog.math.Long","~$goog.math.Integer","^1U","^1[","^1M","~$goog.Uri","~$goog.string.StringBuffer"]]],["^1;","goog/math/integer.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U"]]],["^1;","goog/uri/utils.js"],[1560546089000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U","^1M","^1N","^1U"]]],["^1;","lib_draw_graph/util.cljc"],[1560887308000,"^1I",["^ ","^1J",null,"^1K",["^J",[]],"^1L",["^U","^T"]]]]],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","lib_draw_graph/anneal.cljc","^7",3,"^8",3,"^9",3,"^:",24,"^;","Simulated annealing for cluster layout.","^<","Jude Payne"],"^=",["^ ","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G"],"^H",null,"^I",["^J",[]],"^K","^L","^O",null,"^P",["^ ","^Q","^Q","^R","^R","^S","^R","^T","^T","^U","^U"],"^V",["^J",["^W"]],"~:shadow/js-access-global",["^J",["Error"]],"^X",["^ ","^Y","^Q","^Z","^Q","^[","^Q","^10","^Q"],"~:defs",["^ ","~$annealing",["^ ","~:protocol-inline",null,"^5",["^ ","^6","lib_draw_graph/anneal.cljc","^7",18,"^8",7,"^9",18,"^:",16,"~:arglists",["^13",["~$quote",["^13",[["~$initial","~$max-iter","~$min-cost","~$constraints","~$neighbor-fn","~$cost-fn","~$p-fn","~$temp-fn","~$&",["^ ","~:keys",["~$dims","~$terminate-early?","~$x-retard","~$y-retard","~$max-move"],"~:or",["^ ","^2G",["~:x","~:y","~:w","~:h"],"^2H",false,"^2I",null,"^2J",null,"^2K","~$max-move-default"]]]]]]],"~:top-fn",["^ ","~:variadic?",true,"~:fixed-arity",8,"~:max-fixed-arity",8,"~:method-params",[["^13",["^2>","^2?","^2@","^2A","^2B","^2C","^2D","^2E",["^ ","^2F",["^2G","^2H","^2I","^2J","^2K"],"^2L",["^ ","^2G",["~:x","~:y","~:w","~:h"],"^2H",false,"^2I",null,"^2J",null,"^2K","^2M"]]]]],"^2<",["^13",[["^2>","^2?","^2@","^2A","^2B","^2C","^2D","^2E","~$&",["^ ","^2F",["^2G","^2H","^2I","^2J","^2K"],"^2L",["^ ","^2G",["~:x","~:y","~:w","~:h"],"^2H",false,"^2I",null,"^2J",null,"^2K","^2M"]]]]],"~:arglists-meta",["^13",[null]]]],"^K","~$lib-draw-graph.anneal/annealing","^6","lib_draw_graph/anneal.cljc","^:",16,"^2N",["^ ","^2O",true,"^2P",8,"^2Q",8,"^2R",[["^13",["^2>","^2?","^2@","^2A","^2B","^2C","^2D","^2E",["^ ","^2F",["^2G","^2H","^2I","^2J","^2K"],"^2L",["^ ","^2G",["~:x","~:y","~:w","~:h"],"^2H",false,"^2I",null,"^2J",null,"^2K","^2M"]]]]],"^2<",["^13",[["^2>","^2?","^2@","^2A","^2B","^2C","^2D","^2E","~$&",["^ ","^2F",["^2G","^2H","^2I","^2J","^2K"],"^2L",["^ ","^2G",["~:x","~:y","~:w","~:h"],"^2H",false,"^2I",null,"^2J",null,"^2K","^2M"]]]]],"^2S",["^13",[null]]],"^2R",[["^13",["^2>","^2?","^2@","^2A","^2B","^2C","^2D","^2E",["^ ","^2F",["^2G","^2H","^2I","^2J","^2K"],"^2L",["^ ","^2G",["~:x","~:y","~:w","~:h"],"^2H",false,"^2I",null,"^2J",null,"^2K","^2M"]]]]],"~:protocol-impl",null,"^2P",8,"^2S",["^13",[null]],"^8",1,"^2O",true,"~:methods",[["^ ","^2P",8,"^2O",true]],"^7",18,"~:ret-tag","~$any","^9",18,"^2Q",8,"~:fn-var",true,"^2<",["^13",[["^2>","^2?","^2@","^2A","^2B","^2C","^2D","^2E","~$&",["^ ","^2F",["^2G","^2H","^2I","^2J","^2K"],"^2L",["^ ","^2G",["~:x","~:y","~:w","~:h"],"^2H",false,"^2I",null,"^2J",null,"^2K","^2M"]]]]]],"^2D",["^ ","^2;",null,"^5",["^ ","^6","lib_draw_graph/anneal.cljc","^7",159,"^8",7,"^9",159,"^:",11,"^2<",["^13",["^2=",["^13",[["~$c0","~$c1","~$t"]]]]],"^;","the probability of a move function, using Boltzmann"],"^K","~$lib-draw-graph.anneal/p-fn","^6","lib_draw_graph/anneal.cljc","^:",11,"^2R",["^13",[["^2Z","^2[","~$t"]]],"^2U",null,"^2S",["^13",[null,null]],"^8",1,"^2O",false,"^7",159,"^2W",["^J",["^2X","~$number"]],"^9",159,"^2Q",3,"^2Y",true,"^2<",["^13",["^2=",["^13",[["^2Z","^2[","~$t"]]]]],"^;","the probability of a move function, using Boltzmann"],"^2M",["^ ","^5",["^ ","^6","lib_draw_graph/anneal.cljc","^7",13,"^8",14,"^9",13,"^:",30,"~:const",true],"^K","~$lib-draw-graph.anneal/max-move-default","^6","lib_draw_graph/anneal.cljc","^:",30,"~:const-expr",["^ ","^M","^32","~:val",14,"~:env",["^ ","~:context","~:expr"],"^12",14,"~:tag","^31"],"^8",1,"^32",true,"^7",13,"^9",13,"^39","^31"],"~$vary-rect",["^ ","^2;",null,"^5",["^ ","^6","lib_draw_graph/anneal.cljc","^7",71,"^8",8,"^9",71,"^:",17,"~:private",true,"^2<",["^13",["^2=",["^13",[["~$rect","^2G","^2I","^2J","^2K"]]]]],"^;","When a rectangle/ polygon is defined with a point, width and height\n  (as opposed to two points), when varying the x or y of the point, it\n  is necessary to adjust the width or height as well to be consistent\n  with a rectangle/ polygon specified as two x,y points."],"^3;",true,"^K","~$lib-draw-graph.anneal/vary-rect","^6","lib_draw_graph/anneal.cljc","^:",17,"^2R",["^13",[["^3<","^2G","^2I","^2J","^2K"]]],"^2U",null,"^2S",["^13",[null,null]],"^8",1,"^2O",false,"^7",71,"^9",71,"^2Q",5,"^2Y",true,"^2<",["^13",["^2=",["^13",[["^3<","^2G","^2I","^2J","^2K"]]]]],"^;","When a rectangle/ polygon is defined with a point, width and height\n  (as opposed to two points), when varying the x or y of the point, it\n  is necessary to adjust the width or height as well to be consistent\n  with a rectangle/ polygon specified as two x,y points."],"^2C",["^ ","^2;",null,"^5",["^ ","^6","lib_draw_graph/anneal.cljc","^7",134,"^8",7,"^9",134,"^:",14,"^2<",["^13",["^2=",["^13",[["^2A","~$state"],["^2A","^3>","~$next-state","~$k"]]]]],"^;","Calculates cost, which is total bounded area minus sum of current areas.\n  For the initial call to calculate the system's cost, requires only constraints and state.\n  Subsequent calls require the state, next-state and k, the key of the entry that has\n  changed between them.","^2N",["^ ","^2O",false,"^2P",4,"^2Q",4,"^2R",["^13",[["^2A","^3>"],["^2A","^3>","^3?","~$k"]]],"^2<",["^13",[["^2A","^3>"],["^2A","^3>","^3?","~$k"]]],"^2S",["^13",[null,null]]]],"^K","~$lib-draw-graph.anneal/cost-fn","^6","lib_draw_graph/anneal.cljc","^:",14,"^2N",["^ ","^2O",false,"^2P",4,"^2Q",4,"^2R",["^13",[["^2A","^3>"],["^2A","^3>","^3?","~$k"]]],"^2<",["^13",[["^2A","^3>"],["^2A","^3>","^3?","~$k"]]],"^2S",["^13",[null,null]]],"^2R",["^13",[["^2A","^3>"],["^2A","^3>","^3?","~$k"]]],"^2U",null,"^2P",4,"^2S",["^13",[null,null]],"^8",1,"^2O",false,"^2V",[["^ ","^2P",2,"^2O",false,"^39","^31"],["^ ","^2P",4,"^2O",false,"^39","^31"]],"^7",134,"^9",134,"^2Q",4,"^2Y",true,"^2<",["^13",[["^2A","^3>"],["^2A","^3>","^3?","~$k"]]],"^;","Calculates cost, which is total bounded area minus sum of current areas.\n  For the initial call to calculate the system's cost, requires only constraints and state.\n  Subsequent calls require the state, next-state and k, the key of the entry that has\n  changed between them."],"^2E",["^ ","^2;",null,"^5",["^ ","^6","lib_draw_graph/anneal.cljc","^7",153,"^8",7,"^9",153,"^:",14,"^2<",["^13",["^2=",["^13",[["~$r"]]]]],"^;","the temperature. r should be between 0 and 1"],"^K","~$lib-draw-graph.anneal/temp-fn","^6","lib_draw_graph/anneal.cljc","^:",14,"^2R",["^13",[["~$r"]]],"^2U",null,"^2S",["^13",[null,null]],"^8",1,"^2O",false,"^7",153,"^2W","^31","^9",153,"^2Q",1,"^2Y",true,"^2<",["^13",["^2=",["^13",[["~$r"]]]]],"^;","the temperature. r should be between 0 and 1"],"~$random-move",["^ ","^2;",null,"^5",["^ ","^6","lib_draw_graph/anneal.cljc","^7",59,"^8",7,"^9",59,"^:",18,"^2<",["^13",["^2=",["^13",[["^2K"]]]]]],"^K","~$lib-draw-graph.anneal/random-move","^6","lib_draw_graph/anneal.cljc","^:",18,"^2R",["^13",[["^2K"]]],"^2U",null,"^2S",["^13",[null,null]],"^8",1,"^2O",false,"^7",59,"^2W","^31","^9",59,"^2Q",1,"^2Y",true,"^2<",["^13",["^2=",["^13",[["^2K"]]]]]],"^2B",["^ ","^2;",null,"^5",["^ ","^6","lib_draw_graph/anneal.cljc","^7",104,"^8",7,"^9",104,"^:",18,"^2<",["^13",["^2=",["^13",[["^3>","^2G","^2I","^2J","^2K"]]]]],"^;","Varies a random item from state and returns the new state\n  after checking that the new state passes constraints."],"^K","~$lib-draw-graph.anneal/neighbor-fn","^6","lib_draw_graph/anneal.cljc","^:",18,"^2R",["^13",[["^3>","^2G","^2I","^2J","^2K"]]],"^2U",null,"^2S",["^13",[null,null]],"^8",1,"^2O",false,"^7",104,"^2W","~$cljs.core/IVector","^9",104,"^2Q",5,"^2Y",true,"^2<",["^13",["^2=",["^13",[["^3>","^2G","^2I","^2J","^2K"]]]]],"^;","Varies a random item from state and returns the new state\n  after checking that the new state passes constraints."],"~$PEN",["^ ","^5",["^ ","^6","lib_draw_graph/anneal.cljc","^7",14,"^8",14,"^9",14,"^:",17,"^32",true],"^K","~$lib-draw-graph.anneal/PEN","^6","lib_draw_graph/anneal.cljc","^:",17,"^34",["^ ","^M","^32","^35",1000000,"^36",["^ ","^37","^38"],"^12",1000000,"^39","^31"],"^8",1,"^32",true,"^7",14,"^9",14,"^39","^31"],"~$passes-constraints?",["^ ","^2;",null,"^5",["^ ","^6","lib_draw_graph/anneal.cljc","^7",113,"^8",8,"^9",113,"^:",27,"^3;",true,"^2<",["^13",["^2=",["^13",[["^2A","^3>","^3?","~$varied"]]]]],"^;","Checks that the new (proposed) state item satisfies constraints."],"^3;",true,"^K","~$lib-draw-graph.anneal/passes-constraints?","^6","lib_draw_graph/anneal.cljc","^:",27,"^2R",["^13",[["^2A","^3>","^3?","^3I"]]],"^2U",null,"^2S",["^13",[null,null]],"^8",1,"^2O",false,"^7",113,"^2W",["^J",[null,"^2X"]],"^9",113,"^2Q",4,"^2Y",true,"^2<",["^13",["^2=",["^13",[["^2A","^3>","^3?","^3I"]]]]],"^;","Checks that the new (proposed) state item satisfies constraints."]],"^11",["^ ","^T","^T"],"~:cljs.analyzer/constants",["^ ","^V",["^J",["~:y","~:max-move","~:y-retard","~:w","~:terminate-early?","~:boundary","~:h","~:dims","~:x","~:x-retard","~:collision"]],"~:order",["^3P","~:x","~:y","~:w","~:h","^3N","^3Q","^3M","^3L","^3R","^3O"]],"^17",["^ ","^W",["^J",[]]],"^18",["^ "],"^19",["^U","^T","^Q","^R"]],"^N","^L","~:ns-specs",["^ "],"~:ns-speced-vars",[],"~:compiler-options",["^1G",[["^3V","~:static-fns"],true,["^3V","~:elide-asserts"],true,["^3V","~:optimize-constants"],null,["^3V","^1>"],null,["^3V","~:external-config"],null,["^3V","~:tooling-config"],null,["^3V","~:emit-constants"],null,["^3V","~:load-tests"],false,["^3V","~:infer-externs"],"~:auto",["^3V","^1@"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:release",["^3V","~:fn-invoke-direct"],null,["^3V","~:source-map"],null]]]