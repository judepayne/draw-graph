["^ ","~:output",["^ ","~:js","goog.provide('cljs.test');\n/**\n * Generates a testing environment with a reporter.\n * (empty-env) - uses the :cljs.test/default reporter.\n * (empty-env :cljs.test/pprint) - pretty prints all data structures. \n * (empty-env reporter) - uses a reporter of your choosing.\n * \n * To create your own reporter see cljs.test/report\n */\ncljs.test.empty_env = (function cljs$test$empty_env(var_args){\nvar G__16371 = arguments.length;\nswitch (G__16371) {\ncase 0:\nreturn cljs.test.empty_env.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn cljs.test.empty_env.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\ncljs.test.empty_env.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn cljs.test.empty_env.cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(\"cljs.test\",\"default\",\"cljs.test/default\",-1581405322));\n});\n\ncljs.test.empty_env.cljs$core$IFn$_invoke$arity$1 = (function (reporter){\nvar G__16372 = new cljs.core.PersistentArrayMap(null, 5, [new cljs.core.Keyword(null,\"report-counters\",\"report-counters\",-1702609242),new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"test\",\"test\",577538877),(0),new cljs.core.Keyword(null,\"pass\",\"pass\",1574159993),(0),new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930),(0),new cljs.core.Keyword(null,\"error\",\"error\",-978969032),(0)], null),new cljs.core.Keyword(null,\"testing-vars\",\"testing-vars\",-2114769150),cljs.core.List.EMPTY,new cljs.core.Keyword(null,\"testing-contexts\",\"testing-contexts\",-1485646523),cljs.core.List.EMPTY,new cljs.core.Keyword(null,\"formatter\",\"formatter\",-483008823),cljs.core.pr_str,new cljs.core.Keyword(null,\"reporter\",\"reporter\",-805360621),reporter], null);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"cljs.test\",\"pprint\",\"cljs.test/pprint\",1627393641),reporter)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(G__16372,new cljs.core.Keyword(null,\"reporter\",\"reporter\",-805360621),new cljs.core.Keyword(\"cljs.test\",\"default\",\"cljs.test/default\",-1581405322),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"formatter\",\"formatter\",-483008823),cljs.pprint.pprint], 0));\n} else {\nreturn G__16372;\n}\n});\n\ncljs.test.empty_env.cljs$lang$maxFixedArity = 1;\n\ncljs.test._STAR_current_env_STAR_ = null;\ncljs.test.get_current_env = (function cljs$test$get_current_env(){\nvar or__4131__auto__ = cljs.test._STAR_current_env_STAR_;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.test.empty_env.cljs$core$IFn$_invoke$arity$0();\n}\n});\ncljs.test.update_current_env_BANG_ = (function cljs$test$update_current_env_BANG_(var_args){\nvar args__4736__auto__ = [];\nvar len__4730__auto___16512 = arguments.length;\nvar i__4731__auto___16513 = (0);\nwhile(true){\nif((i__4731__auto___16513 < len__4730__auto___16512)){\nargs__4736__auto__.push((arguments[i__4731__auto___16513]));\n\nvar G__16514 = (i__4731__auto___16513 + (1));\ni__4731__auto___16513 = G__16514;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4737__auto__ = ((((2) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((2)),(0),null)):null);\nreturn cljs.test.update_current_env_BANG_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4737__auto__);\n});\n\ncljs.test.update_current_env_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (ks,f,args){\nreturn cljs.test._STAR_current_env_STAR_ = cljs.core.apply.cljs$core$IFn$_invoke$arity$5(cljs.core.update_in,cljs.test.get_current_env(),ks,f,args);\n});\n\ncljs.test.update_current_env_BANG_.cljs$lang$maxFixedArity = (2);\n\n/** @this {Function} */\ncljs.test.update_current_env_BANG_.cljs$lang$applyTo = (function (seq16381){\nvar G__16382 = cljs.core.first(seq16381);\nvar seq16381__$1 = cljs.core.next(seq16381);\nvar G__16383 = cljs.core.first(seq16381__$1);\nvar seq16381__$2 = cljs.core.next(seq16381__$1);\nvar self__4717__auto__ = this;\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__16382,G__16383,seq16381__$2);\n});\n\ncljs.test.set_env_BANG_ = (function cljs$test$set_env_BANG_(new_env){\nreturn cljs.test._STAR_current_env_STAR_ = new_env;\n});\ncljs.test.clear_env_BANG_ = (function cljs$test$clear_env_BANG_(){\nreturn cljs.test._STAR_current_env_STAR_ = null;\n});\ncljs.test.get_and_clear_env_BANG_ = (function cljs$test$get_and_clear_env_BANG_(){\n\nvar env = cljs.test.get_current_env();\ncljs.test.clear_env_BANG_();\n\nreturn env;\n});\n/**\n * Returns a string representation of the current test.  Renders names\n *   in *testing-vars* as a list, then the source file and line of\n *   current assertion.\n */\ncljs.test.testing_vars_str = (function cljs$test$testing_vars_str(m){\nvar map__16406 = m;\nvar map__16406__$1 = (((((!((map__16406 == null))))?(((((map__16406.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__16406.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__16406):map__16406);\nvar file = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__16406__$1,new cljs.core.Keyword(null,\"file\",\"file\",-1269645878));\nvar line = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__16406__$1,new cljs.core.Keyword(null,\"line\",\"line\",212345235));\nvar column = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__16406__$1,new cljs.core.Keyword(null,\"column\",\"column\",2078222095));\nreturn [cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.reverse(cljs.core.map.cljs$core$IFn$_invoke$arity$2(((function (map__16406,map__16406__$1,file,line,column){\nreturn (function (p1__16405_SHARP_){\nreturn new cljs.core.Keyword(null,\"name\",\"name\",1843675177).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(p1__16405_SHARP_));\n});})(map__16406,map__16406__$1,file,line,column))\n,new cljs.core.Keyword(null,\"testing-vars\",\"testing-vars\",-2114769150).cljs$core$IFn$_invoke$arity$1(cljs.test.get_current_env())))),\" (\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(file),\":\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(line),(cljs.core.truth_(column)?[\":\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(column)].join(''):null),\")\"].join('');\n});\n/**\n * Returns a string representation of the current test context. Joins\n *   strings in *testing-contexts* with spaces.\n */\ncljs.test.testing_contexts_str = (function cljs$test$testing_contexts_str(){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.str,cljs.core.interpose.cljs$core$IFn$_invoke$arity$2(\" \",cljs.core.reverse(new cljs.core.Keyword(null,\"testing-contexts\",\"testing-contexts\",-1485646523).cljs$core$IFn$_invoke$arity$1(cljs.test.get_current_env()))));\n});\n/**\n * Increments the named counter in *report-counters*, a ref to a map.\n *   Does nothing if *report-counters* is nil.\n */\ncljs.test.inc_report_counter_BANG_ = (function cljs$test$inc_report_counter_BANG_(name){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"report-counters\",\"report-counters\",-1702609242).cljs$core$IFn$_invoke$arity$1(cljs.test.get_current_env()))){\nreturn cljs.test.update_current_env_BANG_(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"report-counters\",\"report-counters\",-1702609242),name], null),cljs.core.fnil.cljs$core$IFn$_invoke$arity$2(cljs.core.inc,(0)));\n} else {\nreturn null;\n}\n});\nif((typeof cljs !== 'undefined') && (typeof cljs.test !== 'undefined') && (typeof cljs.test.report !== 'undefined')){\n} else {\n/**\n * Generic reporting function, may be overridden to plug in\n * different report formats (e.g., TAP, JUnit).  Assertions such as\n * 'is' call 'report' to indicate results.  The argument given to\n * 'report' will be a map with a :type key.\n */\ncljs.test.report = (function (){var method_table__4613__auto__ = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY);\nvar prefer_table__4614__auto__ = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY);\nvar method_cache__4615__auto__ = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY);\nvar cached_hierarchy__4616__auto__ = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY);\nvar hierarchy__4617__auto__ = cljs.core.get.cljs$core$IFn$_invoke$arity$3(cljs.core.PersistentArrayMap.EMPTY,new cljs.core.Keyword(null,\"hierarchy\",\"hierarchy\",-1053470341),(function (){var fexpr__16413 = cljs.core.get_global_hierarchy;\nreturn (fexpr__16413.cljs$core$IFn$_invoke$arity$0 ? fexpr__16413.cljs$core$IFn$_invoke$arity$0() : fexpr__16413.call(null));\n})());\nreturn (new cljs.core.MultiFn(cljs.core.symbol.cljs$core$IFn$_invoke$arity$2(\"cljs.test\",\"report\"),((function (method_table__4613__auto__,prefer_table__4614__auto__,method_cache__4615__auto__,cached_hierarchy__4616__auto__,hierarchy__4617__auto__){\nreturn (function (m){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"reporter\",\"reporter\",-805360621).cljs$core$IFn$_invoke$arity$1(cljs.test.get_current_env()),new cljs.core.Keyword(null,\"type\",\"type\",1174270348).cljs$core$IFn$_invoke$arity$1(m)], null);\n});})(method_table__4613__auto__,prefer_table__4614__auto__,method_cache__4615__auto__,cached_hierarchy__4616__auto__,hierarchy__4617__auto__))\n,new cljs.core.Keyword(null,\"default\",\"default\",-1987822328),hierarchy__4617__auto__,method_table__4613__auto__,prefer_table__4614__auto__,method_cache__4615__auto__,cached_hierarchy__4616__auto__));\n})();\n}\ncljs.test.report.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.Keyword(null,\"default\",\"default\",-1987822328),(function (m){\nreturn null;\n}));\ncljs.test.report.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"cljs.test\",\"default\",\"cljs.test/default\",-1581405322),new cljs.core.Keyword(null,\"pass\",\"pass\",1574159993)], null),(function (m){\nreturn cljs.test.inc_report_counter_BANG_(new cljs.core.Keyword(null,\"pass\",\"pass\",1574159993));\n}));\ncljs.test.print_comparison = (function cljs$test$print_comparison(m){\nvar formatter_fn = (function (){var or__4131__auto__ = new cljs.core.Keyword(null,\"formatter\",\"formatter\",-483008823).cljs$core$IFn$_invoke$arity$1(cljs.test.get_current_env());\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn cljs.core.pr_str;\n}\n})();\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"expected:\",(function (){var G__16422 = new cljs.core.Keyword(null,\"expected\",\"expected\",1583670997).cljs$core$IFn$_invoke$arity$1(m);\nreturn (formatter_fn.cljs$core$IFn$_invoke$arity$1 ? formatter_fn.cljs$core$IFn$_invoke$arity$1(G__16422) : formatter_fn.call(null,G__16422));\n})()], 0));\n\nreturn cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"  actual:\",(function (){var G__16423 = new cljs.core.Keyword(null,\"actual\",\"actual\",107306363).cljs$core$IFn$_invoke$arity$1(m);\nreturn (formatter_fn.cljs$core$IFn$_invoke$arity$1 ? formatter_fn.cljs$core$IFn$_invoke$arity$1(G__16423) : formatter_fn.call(null,G__16423));\n})()], 0));\n});\ncljs.test.report.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"cljs.test\",\"default\",\"cljs.test/default\",-1581405322),new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930)], null),(function (m){\ncljs.test.inc_report_counter_BANG_(new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930));\n\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"\\nFAIL in\",cljs.test.testing_vars_str(m)], 0));\n\nif(cljs.core.seq(new cljs.core.Keyword(null,\"testing-contexts\",\"testing-contexts\",-1485646523).cljs$core$IFn$_invoke$arity$1(cljs.test.get_current_env()))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.test.testing_contexts_str()], 0));\n} else {\n}\n\nvar temp__5720__auto___16516 = new cljs.core.Keyword(null,\"message\",\"message\",-406056002).cljs$core$IFn$_invoke$arity$1(m);\nif(cljs.core.truth_(temp__5720__auto___16516)){\nvar message_16517 = temp__5720__auto___16516;\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([message_16517], 0));\n} else {\n}\n\nreturn cljs.test.print_comparison(m);\n}));\ncljs.test.report.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"cljs.test\",\"default\",\"cljs.test/default\",-1581405322),new cljs.core.Keyword(null,\"error\",\"error\",-978969032)], null),(function (m){\ncljs.test.inc_report_counter_BANG_(new cljs.core.Keyword(null,\"error\",\"error\",-978969032));\n\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"\\nERROR in\",cljs.test.testing_vars_str(m)], 0));\n\nif(cljs.core.seq(new cljs.core.Keyword(null,\"testing-contexts\",\"testing-contexts\",-1485646523).cljs$core$IFn$_invoke$arity$1(cljs.test.get_current_env()))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.test.testing_contexts_str()], 0));\n} else {\n}\n\nvar temp__5720__auto___16518 = new cljs.core.Keyword(null,\"message\",\"message\",-406056002).cljs$core$IFn$_invoke$arity$1(m);\nif(cljs.core.truth_(temp__5720__auto___16518)){\nvar message_16519 = temp__5720__auto___16518;\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([message_16519], 0));\n} else {\n}\n\nreturn cljs.test.print_comparison(m);\n}));\ncljs.test.report.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"cljs.test\",\"default\",\"cljs.test/default\",-1581405322),new cljs.core.Keyword(null,\"summary\",\"summary\",380847952)], null),(function (m){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"\\nRan\",new cljs.core.Keyword(null,\"test\",\"test\",577538877).cljs$core$IFn$_invoke$arity$1(m),\"tests containing\",((new cljs.core.Keyword(null,\"pass\",\"pass\",1574159993).cljs$core$IFn$_invoke$arity$1(m) + new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930).cljs$core$IFn$_invoke$arity$1(m)) + new cljs.core.Keyword(null,\"error\",\"error\",-978969032).cljs$core$IFn$_invoke$arity$1(m)),\"assertions.\"], 0));\n\nreturn cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930).cljs$core$IFn$_invoke$arity$1(m),\"failures,\",new cljs.core.Keyword(null,\"error\",\"error\",-978969032).cljs$core$IFn$_invoke$arity$1(m),\"errors.\"], 0));\n}));\ncljs.test.report.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"cljs.test\",\"default\",\"cljs.test/default\",-1581405322),new cljs.core.Keyword(null,\"begin-test-ns\",\"begin-test-ns\",-1701237033)], null),(function (m){\nreturn cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"\\nTesting\",cljs.core.name(new cljs.core.Keyword(null,\"ns\",\"ns\",441598760).cljs$core$IFn$_invoke$arity$1(m))], 0));\n}));\ncljs.test.report.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"cljs.test\",\"default\",\"cljs.test/default\",-1581405322),new cljs.core.Keyword(null,\"end-test-ns\",\"end-test-ns\",1620675645)], null),(function (m){\nreturn null;\n}));\ncljs.test.report.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"cljs.test\",\"default\",\"cljs.test/default\",-1581405322),new cljs.core.Keyword(null,\"begin-test-var\",\"begin-test-var\",-908571100)], null),(function (m){\nreturn null;\n}));\ncljs.test.report.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"cljs.test\",\"default\",\"cljs.test/default\",-1581405322),new cljs.core.Keyword(null,\"end-test-var\",\"end-test-var\",984198545)], null),(function (m){\nreturn null;\n}));\ncljs.test.report.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"cljs.test\",\"default\",\"cljs.test/default\",-1581405322),new cljs.core.Keyword(null,\"end-run-tests\",\"end-run-tests\",267300563)], null),(function (m){\nreturn null;\n}));\ncljs.test.report.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"cljs.test\",\"default\",\"cljs.test/default\",-1581405322),new cljs.core.Keyword(null,\"end-test-all-vars\",\"end-test-all-vars\",548827253)], null),(function (m){\nreturn null;\n}));\ncljs.test.report.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"cljs.test\",\"default\",\"cljs.test/default\",-1581405322),new cljs.core.Keyword(null,\"end-test-vars\",\"end-test-vars\",-1394419713)], null),(function (m){\nreturn null;\n}));\ncljs.test.js_line_and_column = (function cljs$test$js_line_and_column(stack_element){\n\nvar parts = stack_element.split(\":\");\nvar cnt = cljs.core.count(parts);\nif((cnt > (1))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [parseInt(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(parts,(cnt - (2))),(10)),parseInt(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(parts,(cnt - (1))),(10))], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [NaN,NaN], null);\n}\n});\ncljs.test.js_filename = (function cljs$test$js_filename(stack_element){\nvar output_dir = \"out\";\nvar output_dir__$1 = (function (){var G__16436 = output_dir;\nif((!(clojure.string.ends_with_QMARK_(output_dir,\"/\")))){\nreturn [G__16436,\"/\"].join('');\n} else {\nreturn G__16436;\n}\n})();\nreturn cljs.core.first(cljs.core.last(stack_element.split(output_dir__$1)).split(\":\"));\n});\ncljs.test.mapped_line_and_column = (function cljs$test$mapped_line_and_column(filename,line,column){\nvar default$ = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [filename,line,column], null);\nvar temp__5718__auto__ = new cljs.core.Keyword(null,\"source-map\",\"source-map\",1706252311).cljs$core$IFn$_invoke$arity$1(cljs.test.get_current_env());\nif(cljs.core.truth_(temp__5718__auto__)){\nvar source_map = temp__5718__auto__;\nvar temp__5718__auto____$1 = cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(source_map,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [filename,(line - (1))], null));\nif(cljs.core.truth_(temp__5718__auto____$1)){\nvar columns = temp__5718__auto____$1;\nreturn cljs.core.vec(cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.first((function (){var temp__5718__auto____$2 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(columns,(column - (1)));\nif(cljs.core.truth_(temp__5718__auto____$2)){\nvar mapping = temp__5718__auto____$2;\nreturn mapping;\n} else {\nreturn cljs.core.second(cljs.core.first(columns));\n}\n})()),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"source\",\"source\",-433931539),new cljs.core.Keyword(null,\"line\",\"line\",212345235),new cljs.core.Keyword(null,\"col\",\"col\",-1959363084)], null)));\n} else {\nreturn default$;\n}\n} else {\nreturn default$;\n}\n});\ncljs.test.file_and_line = (function cljs$test$file_and_line(exception,depth){\nvar temp__5718__auto__ = (function (){var and__4120__auto__ = typeof exception.stack === 'string';\nif(and__4120__auto__){\nvar G__16439 = exception.stack;\nvar G__16439__$1 = (((G__16439 == null))?null:clojure.string.split_lines(G__16439));\nvar G__16439__$2 = (((G__16439__$1 == null))?null:cljs.core.get.cljs$core$IFn$_invoke$arity$2(G__16439__$1,depth));\nif((G__16439__$2 == null)){\nreturn null;\n} else {\nreturn clojure.string.trim(G__16439__$2);\n}\n} else {\nreturn and__4120__auto__;\n}\n})();\nif(cljs.core.truth_(temp__5718__auto__)){\nvar stack_element = temp__5718__auto__;\nvar fname = cljs.test.js_filename(stack_element);\nvar vec__16440 = cljs.test.js_line_and_column(stack_element);\nvar line = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__16440,(0),null);\nvar column = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__16440,(1),null);\nvar vec__16443 = cljs.test.mapped_line_and_column(fname,line,column);\nvar fname__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__16443,(0),null);\nvar line__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__16443,(1),null);\nvar column__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__16443,(2),null);\nreturn new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"file\",\"file\",-1269645878),fname__$1,new cljs.core.Keyword(null,\"line\",\"line\",212345235),line__$1,new cljs.core.Keyword(null,\"column\",\"column\",2078222095),column__$1], null);\n} else {\nreturn new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"file\",\"file\",-1269645878),exception.fileName,new cljs.core.Keyword(null,\"line\",\"line\",212345235),exception.lineNumber], null);\n}\n});\ncljs.test.do_report = (function cljs$test$do_report(m){\nvar m__$1 = (function (){var G__16450 = new cljs.core.Keyword(null,\"type\",\"type\",1174270348).cljs$core$IFn$_invoke$arity$1(m);\nvar G__16450__$1 = (((G__16450 instanceof cljs.core.Keyword))?G__16450.fqn:null);\nswitch (G__16450__$1) {\ncase \"fail\":\nreturn cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.test.file_and_line((new Error()),(4)),m], 0));\n\nbreak;\ncase \"error\":\nreturn cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.test.file_and_line(new cljs.core.Keyword(null,\"actual\",\"actual\",107306363).cljs$core$IFn$_invoke$arity$1(m),(0)),m], 0));\n\nbreak;\ndefault:\nreturn m;\n\n}\n})();\nreturn (cljs.test.report.cljs$core$IFn$_invoke$arity$1 ? cljs.test.report.cljs$core$IFn$_invoke$arity$1(m__$1) : cljs.test.report.call(null,m__$1));\n});\n\n/**\n * Marker protocol denoting CPS function to begin asynchronous\n *   testing.\n * @interface\n */\ncljs.test.IAsyncTest = function(){};\n\n/**\n * Returns whether x implements IAsyncTest.\n */\ncljs.test.async_QMARK_ = (function cljs$test$async_QMARK_(x){\nif((!((x == null)))){\nif(((false) || ((cljs.core.PROTOCOL_SENTINEL === x.cljs$test$IAsyncTest$)))){\nreturn true;\n} else {\nif((!x.cljs$lang$protocol_mask$partition$)){\nreturn cljs.core.native_satisfies_QMARK_(cljs.test.IAsyncTest,x);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(cljs.test.IAsyncTest,x);\n}\n});\n/**\n * Invoke all functions in fns with no arguments. A fn can optionally\n *   return\n * \n *   an async test - is invoked with a continuation running left fns\n * \n *   a seq of fns tagged per block - are invoked immediately after fn\n */\ncljs.test.run_block = (function cljs$test$run_block(fns){\nwhile(true){\nvar temp__5720__auto__ = cljs.core.seq(fns);\nif(temp__5720__auto__){\nvar xs__6277__auto__ = temp__5720__auto__;\nvar f = cljs.core.first(xs__6277__auto__);\nvar obj = (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\nif(cljs.test.async_QMARK_(obj)){\nvar G__16464 = (function (){var d = (new cljs.core.Delay(((function (fns,obj,f,xs__6277__auto__,temp__5720__auto__){\nreturn (function (){\nvar G__16465 = cljs.core.rest(fns);\nreturn (cljs.test.run_block.cljs$core$IFn$_invoke$arity$1 ? cljs.test.run_block.cljs$core$IFn$_invoke$arity$1(G__16465) : cljs.test.run_block.call(null,G__16465));\n});})(fns,obj,f,xs__6277__auto__,temp__5720__auto__))\n,null));\nreturn ((function (fns,d,obj,f,xs__6277__auto__,temp__5720__auto__){\nreturn (function (){\nif(cljs.core.realized_QMARK_(d)){\nreturn cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"WARNING: Async test called done more than one time.\"], 0));\n} else {\nreturn cljs.core.deref(d);\n}\n});\n;})(fns,d,obj,f,xs__6277__auto__,temp__5720__auto__))\n})();\nreturn (obj.cljs$core$IFn$_invoke$arity$1 ? obj.cljs$core$IFn$_invoke$arity$1(G__16464) : obj.call(null,G__16464));\n} else {\nvar G__16521 = (function (){var G__16466 = cljs.core.rest(fns);\nif(cljs.core.truth_(new cljs.core.Keyword(\"cljs.test\",\"block?\",\"cljs.test/block?\",686379965).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(obj)))){\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2(obj,G__16466);\n} else {\nreturn G__16466;\n}\n})();\nfns = G__16521;\ncontinue;\n}\n} else {\nreturn null;\n}\nbreak;\n}\n});\n/**\n * Tag a seq of fns to be picked up by run-block as injected\n *   continuation.  See run-block.\n */\ncljs.test.block = (function cljs$test$block(fns){\nvar G__16467 = fns;\nif((G__16467 == null)){\nreturn null;\n} else {\nreturn cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$4(G__16467,cljs.core.assoc,new cljs.core.Keyword(\"cljs.test\",\"block?\",\"cljs.test/block?\",686379965),true);\n}\n});\ncljs.test.test_var_block_STAR_ = (function cljs$test$test_var_block_STAR_(v,t){\n\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(function (){\ncljs.test.update_current_env_BANG_.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"testing-vars\",\"testing-vars\",-2114769150)], null),cljs.core.conj,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([v], 0));\n\ncljs.test.update_current_env_BANG_(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"report-counters\",\"report-counters\",-1702609242),new cljs.core.Keyword(null,\"test\",\"test\",577538877)], null),cljs.core.inc);\n\ncljs.test.do_report(new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"begin-test-var\",\"begin-test-var\",-908571100),new cljs.core.Keyword(null,\"var\",\"var\",-769682797),v], null));\n\ntry{return (t.cljs$core$IFn$_invoke$arity$0 ? t.cljs$core$IFn$_invoke$arity$0() : t.call(null));\n}catch (e16469){var e = e16469;\nvar G__16470 = e;\nvar G__16470__$1 = (((G__16470 instanceof cljs.core.Keyword))?G__16470.fqn:null);\nswitch (G__16470__$1) {\ncase \"cljs.test/async-disabled\":\nthrow \"Async tests require fixtures to be specified as maps.  Testing aborted.\";\n\nbreak;\ndefault:\nreturn cljs.test.do_report(new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"error\",\"error\",-978969032),new cljs.core.Keyword(null,\"message\",\"message\",-406056002),\"Uncaught exception, not in assertion.\",new cljs.core.Keyword(null,\"expected\",\"expected\",1583670997),null,new cljs.core.Keyword(null,\"actual\",\"actual\",107306363),e], null));\n\n}\n}}),(function (){\ncljs.test.do_report(new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"end-test-var\",\"end-test-var\",984198545),new cljs.core.Keyword(null,\"var\",\"var\",-769682797),v], null));\n\nreturn cljs.test.update_current_env_BANG_(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"testing-vars\",\"testing-vars\",-2114769150)], null),cljs.core.rest);\n})], null);\n});\n/**\n * Like test-var, but returns a block for further composition and\n *   later execution.\n */\ncljs.test.test_var_block = (function cljs$test$test_var_block(v){\nvar temp__5718__auto__ = new cljs.core.Keyword(null,\"test\",\"test\",577538877).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(v));\nif(cljs.core.truth_(temp__5718__auto__)){\nvar t = temp__5718__auto__;\nreturn cljs.test.test_var_block_STAR_(v,t);\n} else {\nreturn null;\n}\n});\n/**\n * If v has a function in its :test metadata, calls that function,\n *   add v to :testing-vars property of env.\n */\ncljs.test.test_var = (function cljs$test$test_var(v){\nreturn cljs.test.run_block(cljs.test.test_var_block(v));\n});\n/**\n * The default, empty, fixture function.  Just calls its argument.\n * \n *   NOTE: Incompatible with map fixtures.\n */\ncljs.test.default_fixture = (function cljs$test$default_fixture(f){\nreturn (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\n});\n/**\n * Composes two fixture functions, creating a new fixture function\n *   that combines their behavior.\n * \n *   NOTE: Incompatible with map fixtures.\n */\ncljs.test.compose_fixtures = (function cljs$test$compose_fixtures(f1,f2){\nreturn (function (g){\nvar G__16479 = (function (){\nreturn (f2.cljs$core$IFn$_invoke$arity$1 ? f2.cljs$core$IFn$_invoke$arity$1(g) : f2.call(null,g));\n});\nreturn (f1.cljs$core$IFn$_invoke$arity$1 ? f1.cljs$core$IFn$_invoke$arity$1(G__16479) : f1.call(null,G__16479));\n});\n});\n/**\n * Composes a collection of fixtures, in order.  Always returns a valid\n *   fixture function, even if the collection is empty.\n * \n *   NOTE: Incompatible with map fixtures.\n */\ncljs.test.join_fixtures = (function cljs$test$join_fixtures(fixtures){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.test.compose_fixtures,cljs.test.default_fixture,fixtures);\n});\n/**\n * Wraps block in map-fixtures.\n */\ncljs.test.wrap_map_fixtures = (function cljs$test$wrap_map_fixtures(map_fixtures,block){\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic(cljs.core.keep.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"before\",\"before\",-1633692388),map_fixtures),block,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.reverse(cljs.core.keep.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"after\",\"after\",594996914),map_fixtures))], 0));\n});\ncljs.test.execution_strategy = (function cljs$test$execution_strategy(once,each){\nvar fixtures_type = (function cljs$test$execution_strategy_$_fixtures_type(coll){\nif(cljs.core.empty_QMARK_(coll)){\nreturn new cljs.core.Keyword(null,\"none\",\"none\",1333468478);\n} else {\nif(cljs.core.every_QMARK_(cljs.core.map_QMARK_,coll)){\nreturn new cljs.core.Keyword(null,\"map\",\"map\",1371690461);\n} else {\nif(cljs.core.every_QMARK_(cljs.core.fn_QMARK_,coll)){\nreturn new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204);\n} else {\nreturn null;\n}\n}\n}\n});\nvar fixtures_types = (function cljs$test$execution_strategy_$_fixtures_types(){\nreturn cljs.core.distinct.cljs$core$IFn$_invoke$arity$1(cljs.core.remove.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"none\",\"none\",1333468478),null], null), null),cljs.core.map.cljs$core$IFn$_invoke$arity$2(fixtures_type,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [once,each], null))));\n});\nvar vec__16480 = fixtures_types();\nvar type = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__16480,(0),null);\nvar types = vec__16480;\n\n\nvar G__16486 = type;\nvar G__16487 = new cljs.core.Keyword(null,\"async\",\"async\",1050769601);\nvar fexpr__16485 = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"map\",\"map\",1371690461),new cljs.core.Keyword(null,\"async\",\"async\",1050769601),new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204),new cljs.core.Keyword(null,\"sync\",\"sync\",-624148946),new cljs.core.Keyword(\"cljs.analyzer\",\"analyzed\",\"cljs.analyzer/analyzed\",-735094162),true], null);\nreturn (fexpr__16485.cljs$core$IFn$_invoke$arity$2 ? fexpr__16485.cljs$core$IFn$_invoke$arity$2(G__16486,G__16487) : fexpr__16485.call(null,G__16486,G__16487));\n});\ncljs.test.disable_async = (function cljs$test$disable_async(f){\nreturn (function (){\nvar obj = (f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null));\nif(cljs.test.async_QMARK_(obj)){\nthrow new cljs.core.Keyword(\"cljs.test\",\"async-disabled\",\"cljs.test/async-disabled\",-772095377);\n} else {\n}\n\nreturn obj;\n});\n});\n/**\n * Like test-vars, but returns a block for further composition and\n *   later execution.\n */\ncljs.test.test_vars_block = (function cljs$test$test_vars_block(vars){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p__16490){\nvar vec__16491 = p__16490;\nvar ns = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__16491,(0),null);\nvar vars__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__16491,(1),null);\nreturn ((function (vec__16491,ns,vars__$1){\nreturn (function (){\nreturn cljs.test.block((function (){var env = cljs.test.get_current_env();\nvar once_fixtures = cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(env,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"once-fixtures\",\"once-fixtures\",1253947167),ns], null));\nvar each_fixtures = cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(env,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"each-fixtures\",\"each-fixtures\",802243977),ns], null));\nvar G__16494 = cljs.test.execution_strategy(once_fixtures,each_fixtures);\nvar G__16494__$1 = (((G__16494 instanceof cljs.core.Keyword))?G__16494.fqn:null);\nswitch (G__16494__$1) {\ncase \"async\":\nreturn cljs.test.wrap_map_fixtures(once_fixtures,cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic(cljs.core.comp.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(cljs.test.wrap_map_fixtures,each_fixtures),cljs.test.test_var_block),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.filter.cljs$core$IFn$_invoke$arity$2(cljs.core.comp.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"test\",\"test\",577538877),cljs.core.meta),vars__$1)], 0)));\n\nbreak;\ncase \"sync\":\nvar each_fixture_fn = cljs.test.join_fixtures(each_fixtures);\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [((function (each_fixture_fn,G__16494,G__16494__$1,env,once_fixtures,each_fixtures,vec__16491,ns,vars__$1){\nreturn (function (){\nvar G__16496 = ((function (each_fixture_fn,G__16494,G__16494__$1,env,once_fixtures,each_fixtures,vec__16491,ns,vars__$1){\nreturn (function (){\nvar seq__16497 = cljs.core.seq(vars__$1);\nvar chunk__16498 = null;\nvar count__16499 = (0);\nvar i__16500 = (0);\nwhile(true){\nif((i__16500 < count__16499)){\nvar v = chunk__16498.cljs$core$IIndexed$_nth$arity$2(null,i__16500);\nvar temp__5720__auto___16525 = new cljs.core.Keyword(null,\"test\",\"test\",577538877).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(v));\nif(cljs.core.truth_(temp__5720__auto___16525)){\nvar t_16526 = temp__5720__auto___16525;\nvar G__16508_16527 = ((function (seq__16497,chunk__16498,count__16499,i__16500,t_16526,temp__5720__auto___16525,v,each_fixture_fn,G__16494,G__16494__$1,env,once_fixtures,each_fixtures,vec__16491,ns,vars__$1){\nreturn (function (){\nreturn cljs.test.run_block(cljs.test.test_var_block_STAR_(v,cljs.test.disable_async(t_16526)));\n});})(seq__16497,chunk__16498,count__16499,i__16500,t_16526,temp__5720__auto___16525,v,each_fixture_fn,G__16494,G__16494__$1,env,once_fixtures,each_fixtures,vec__16491,ns,vars__$1))\n;\n(each_fixture_fn.cljs$core$IFn$_invoke$arity$1 ? each_fixture_fn.cljs$core$IFn$_invoke$arity$1(G__16508_16527) : each_fixture_fn.call(null,G__16508_16527));\n} else {\n}\n\n\nvar G__16528 = seq__16497;\nvar G__16529 = chunk__16498;\nvar G__16530 = count__16499;\nvar G__16531 = (i__16500 + (1));\nseq__16497 = G__16528;\nchunk__16498 = G__16529;\ncount__16499 = G__16530;\ni__16500 = G__16531;\ncontinue;\n} else {\nvar temp__5720__auto__ = cljs.core.seq(seq__16497);\nif(temp__5720__auto__){\nvar seq__16497__$1 = temp__5720__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__16497__$1)){\nvar c__4550__auto__ = cljs.core.chunk_first(seq__16497__$1);\nvar G__16532 = cljs.core.chunk_rest(seq__16497__$1);\nvar G__16533 = c__4550__auto__;\nvar G__16534 = cljs.core.count(c__4550__auto__);\nvar G__16535 = (0);\nseq__16497 = G__16532;\nchunk__16498 = G__16533;\ncount__16499 = G__16534;\ni__16500 = G__16535;\ncontinue;\n} else {\nvar v = cljs.core.first(seq__16497__$1);\nvar temp__5720__auto___16536__$1 = new cljs.core.Keyword(null,\"test\",\"test\",577538877).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(v));\nif(cljs.core.truth_(temp__5720__auto___16536__$1)){\nvar t_16537 = temp__5720__auto___16536__$1;\nvar G__16509_16538 = ((function (seq__16497,chunk__16498,count__16499,i__16500,t_16537,temp__5720__auto___16536__$1,v,seq__16497__$1,temp__5720__auto__,each_fixture_fn,G__16494,G__16494__$1,env,once_fixtures,each_fixtures,vec__16491,ns,vars__$1){\nreturn (function (){\nreturn cljs.test.run_block(cljs.test.test_var_block_STAR_(v,cljs.test.disable_async(t_16537)));\n});})(seq__16497,chunk__16498,count__16499,i__16500,t_16537,temp__5720__auto___16536__$1,v,seq__16497__$1,temp__5720__auto__,each_fixture_fn,G__16494,G__16494__$1,env,once_fixtures,each_fixtures,vec__16491,ns,vars__$1))\n;\n(each_fixture_fn.cljs$core$IFn$_invoke$arity$1 ? each_fixture_fn.cljs$core$IFn$_invoke$arity$1(G__16509_16538) : each_fixture_fn.call(null,G__16509_16538));\n} else {\n}\n\n\nvar G__16539 = cljs.core.next(seq__16497__$1);\nvar G__16540 = null;\nvar G__16541 = (0);\nvar G__16542 = (0);\nseq__16497 = G__16539;\nchunk__16498 = G__16540;\ncount__16499 = G__16541;\ni__16500 = G__16542;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n});})(each_fixture_fn,G__16494,G__16494__$1,env,once_fixtures,each_fixtures,vec__16491,ns,vars__$1))\n;\nvar fexpr__16495 = cljs.test.join_fixtures(once_fixtures);\nreturn (fexpr__16495.cljs$core$IFn$_invoke$arity$1 ? fexpr__16495.cljs$core$IFn$_invoke$arity$1(G__16496) : fexpr__16495.call(null,G__16496));\n});})(each_fixture_fn,G__16494,G__16494__$1,env,once_fixtures,each_fixtures,vec__16491,ns,vars__$1))\n], null);\n\nbreak;\ndefault:\nthrow (new Error([\"No matching clause: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(G__16494__$1)].join('')));\n\n}\n})());\n});\n;})(vec__16491,ns,vars__$1))\n}),cljs.core.group_by(cljs.core.comp.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"ns\",\"ns\",441598760),cljs.core.meta),vars));\n});\n/**\n * Groups vars by their namespace and runs test-vars on them with\n *   appropriate fixtures assuming they are present in the current\n *   testing environment.\n */\ncljs.test.test_vars = (function cljs$test$test_vars(vars){\nreturn cljs.test.run_block(cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.test.test_vars_block(vars),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [(function (){\nvar G__16510 = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"end-test-vars\",\"end-test-vars\",-1394419713),new cljs.core.Keyword(null,\"vars\",\"vars\",-2046957217),vars], null);\nreturn (cljs.test.report.cljs$core$IFn$_invoke$arity$1 ? cljs.test.report.cljs$core$IFn$_invoke$arity$1(G__16510) : cljs.test.report.call(null,G__16510));\n})], null)));\n});\n/**\n * Returns true if the given test summary indicates all tests\n *   were successful, false otherwise.\n */\ncljs.test.successful_QMARK_ = (function cljs$test$successful_QMARK_(summary){\nreturn (((new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930).cljs$core$IFn$_invoke$arity$2(summary,(0)) === (0))) && ((new cljs.core.Keyword(null,\"error\",\"error\",-978969032).cljs$core$IFn$_invoke$arity$2(summary,(0)) === (0))));\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","cljs/test.cljs","~:line",243,"~:column",3,"~:end-line",243,"~:end-column",12,"~:author","Stuart Sierra, with contributions and suggestions by \n  Chas Emerick, Allen Rohner, Stuart Halloway, David Nolen, and\n  Leon Grapenthin","~:doc","A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the \"is\" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (= 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith \"abcde\" \"ab\"))\n\n   You can type an \"is\" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user> (is (= 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (= 5 (+ 2 2))\n         actual: (not (= 5 4))\n       false\n\n   The \"expected:\" line shows you the original expression, and the\n   \"actual:\" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not = to 5.  Finally, the\n   \"false\" on the last line is the value returned from the\n   expression.  The \"is\" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   \"(is (thrown? c ...))\" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0))) \n\n   \"(is (thrown-with-msg? c re ...))\" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #\"Divide by zero\"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   \"is\" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (= 5 (+ 2 2)) \"Crazy arithmetic\")\n\n   In addition, you can document groups of assertions with the\n   \"testing\" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to \"testing\" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec <http://rspec.info/>\n\n   (testing \"Arithmetic\"\n     (testing \"with positive integers\"\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4))))\n     (testing \"with negative integers\"\n       (is (= -4 (+ -2 -2)))\n       (is (= -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the \"testing\" macro may only be used\n   INSIDE a \"deftest\" form (see below).\n\n\n   DEFINING TESTS\n\n   (deftest addition\n     (is (= 4 (+ 2 2)))\n     (is (= 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (= 1 (- 4 3)))\n     (is (= 3 (- 7 4))))\n\n   This creates functions named \"addition\" and \"subtraction\", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel's \"Practical Common Lisp\"\n   <http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html>\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   \"(arithmetic addition)\", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n   DEFINING ASYNC TESTS\n\n   (deftest addition\n     (async done\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4)))\n       (done)))\n\n   Async tests are constructed with the async macro. The first argument to\n   the macro is the test completion callback. The body of the async macro may\n   be any series of expressions. The completion callback must be invoked when\n   all assertions have run. There is no support for asynchronous coordination -\n   core.async is recommended for this. Note the body of the async test must be\n   truly asynchronous to avoid stack overflow.\n\n   RUNNING TESTS\n\n   Run tests with the function \"(run-tests namespaces...)\":\n\n   (run-tests 'your.namespace 'some.other.namespace)\n\n   If you don't specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use \"(run-all-tests)\".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the \"arithmetic\" example above, you\n   probably do not want the \"addition\" and \"subtraction\" tests run\n   separately.  In that case, you must define a special function\n   named \"test-ns-hook\" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   \"run-tests\" also optionally takes a testing enviroment. A default\n   one is supplied for you by invoking \"empty-env\".  The test\n   environment contains everything needed to run tests including the\n   report results map. Fixtures must be present here if you want them\n   to run. Note that code that relies on \"test-ns\" will\n   automatically be supplied the appropriate defined fixtures.  For\n   example, this is done for you if you use \"run-tests\".\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can set the ClojureScript compiler build option\n   \":load-tests\" to false when loading or compiling code in\n   production.  This will prevent any tests from being created by\n   or \"deftest\".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is a map of one or two functions that run code before and\n   after tests.  It looks like this:\n\n   {:before (fn []\n              Perform setup, establish bindings, whatever.\n              )\n    :after (fn []\n             Tear-down / clean-up code here.\n             )}\n\n   Both are optional and can be left out.\n\n   Fixtures are attached to namespaces in one of two ways.  \"each\"\n   fixtures are run repeatedly, once for each test function created\n   with \"deftest\".  \"each\" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   \"each\" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just maps like the example above.\n   They can also be passed directly, like this:\n   (use-fixtures :each\n     {:before (fn [] setup...), :after (fn [] cleanup...)})\n\n   The other kind of fixture, a \"once\" fixture, is only run once,\n   around ALL the tests in the namespace.  \"once\" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach \"once\" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   WRAPPING FIXTURES\n\n   Instead of a map, a fixture can be specified like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   This style is incompatible with async tests. If an async test is\n   encountered, testing will be aborted. It can't be mixed with\n   fixtures specified as maps.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the \"is\" macro by defining new\n   methods for the \"assert-expr\" multimethod.  These methods are\n   called during expansion of the \"is\" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by specifying a\n   :reporter key in the test environment. It is normally set to\n   :cljs.test/default. Set this to the desired key and supply custom\n   implementations of the \"report\" multimethod.\n\n   The 'event' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to 'is'\n\n   The \"testing\" strings will be a list in the :testing-contexts\n   property of the test environment, and the vars being tested will be\n   a list in the :testing-vars property of the test environment.\n\n   For additional event types, see the examples in the code.\n"],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$create-react-class","~$module$node_modules$create_react_class$index","~$react-dom","~$module$node_modules$react_dom$index","~$clojure.spec.alpha","~$cljs.spec.alpha"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:macros",["^ ","~$are",["^ ","~:arglists",["~#list",[["~$argv","~$expr","~$&","~$args"]]],"^<","Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers.","^7",172,"^8",1,"^6","cljs/test.cljc","~:name","~$cljs.test/are","~:ns","~$cljs.test","~:macro",true],"~$test-all-vars",["^ ","^M",["^N",[[["~$quote","~$ns","~:as","~$form"]]]],"^<","Calls test-vars on every var with :test metadata interned in the\n  namespace, with fixtures.","^7",339,"^8",1,"^6","cljs/test.cljc","^R","~$cljs.test/test-all-vars","^T","^U","^V",true],"~$run-all-tests",["^ ","^M",["^N",[[],["~$re"],["^12","~$env"]]],"^<","Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested.","^7",302,"^8",1,"^6","cljs/test.cljc","^R","~$cljs.test/run-all-tests","^T","^U","^V",true],"~$testing",["^ ","^M",["^N",[["~$string","~$&","~$body"]]],"^<","Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest).","^7",196,"^8",1,"^6","cljs/test.cljc","^R","~$cljs.test/testing","^T","^U","^V",true],"~$async",["^ ","^M",["^N",[["~$done","~$&","^17"]]],"^<","Wraps body as a CPS function that can be returned from a test to\n  continue asynchronously.  Binds done to a function that must be\n  invoked once and from an async context after any assertions.\n\n  (deftest example-with-timeout\n    (async done\n      (js/setTimeout (fn []\n                       ;; make assertions in async context...\n                       (done) ;; ...then call done\n                       )\n                     0)))","^7",228,"^8",1,"^6","cljs/test.cljc","^R","~$cljs.test/async","^T","^U","^V",true],"~$is",["^ ","^M",["^N",[["^["],["^[","~$msg"]]],"^<","Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re.","^7",154,"^8",1,"^6","cljs/test.cljc","^R","~$cljs.test/is","^T","^U","^V",true],"~$deftest",["^ ","^M",["^N",[["~$name","~$&","^17"]]],"^<","Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When cljs.analyzer/*load-tests* is false, deftest is ignored.","^7",210,"^8",1,"^6","cljs/test.cljc","^R","~$cljs.test/deftest","^T","^U","^V",true],"~$run-tests-block",["^ ","^M",["^N",[["~$env-or-ns","~$&","~$namespaces"]]],"^<","Like test-vars, but returns a block for further composition and\n  later execution.","^7",253,"^8",1,"^6","cljs/test.cljc","^R","~$cljs.test/run-tests-block","^T","^U","^V",true],"~$test-ns-block",["^ ","^M",["^N",[["^13",["^X","^Y","^Z","^["]]]],"^<","Like test-ns, but returns a block for further composition and\n  later execution.  Does not clear the current env.","^7",348,"^8",1,"^6","cljs/test.cljc","^R","~$cljs.test/test-ns-block","^T","^U","^V",true],"~$try-expr",["^ ","^M",["^N",[["^1=","^["]]],"^<","Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this.","^7",140,"^8",1,"^6","cljs/test.cljc","^R","~$cljs.test/try-expr","^T","^U","^V",true],"~$use-fixtures",["^ ","^M",["^N",[["~$type","~$&","~$fns"]]],"^7",382,"^8",1,"^6","cljs/test.cljc","^R","~$cljs.test/use-fixtures","^T","^U","^V",true],"~$test-ns",["^ ","^M",["^N",[["^Y"],["^13",["^X","^Y","^Z","^["]]]],"^<","If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  ","^7",365,"^8",1,"^6","cljs/test.cljc","^R","~$cljs.test/test-ns","^T","^U","^V",true],"~$test-all-vars-block",["^ ","^M",["^N",[[["^X","^Y"]]]],"^7",316,"^8",1,"^6","cljs/test.cljc","^R","~$cljs.test/test-all-vars-block","^T","^U","^V",true],"~$run-tests",["^ ","^M",["^N",[[],["^1C"],["^1C","~$&","^1D"]]],"^<","Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given. Does not return a meaningful\n  value due to the possiblity of asynchronous execution. To detect test\n  completion add a :end-run-tests method case to the cljs.test/report\n  multimethod.","^7",288,"^8",1,"^6","cljs/test.cljc","^R","~$cljs.test/run-tests","^T","^U","^V",true]],"^R","^U","~:op","^T","~:imports",null,"~:requires",["^ ","~$clojure.string","^1W","^16","^1W","~$cljs.pprint","^1X","~$pprint","^1X","~$cljs.core","^1Z","~$goog","^1["],"~:seen",["^J",["~:require","~:require-macros"]],"~:uses",null,"^22",["^ ","~$clojure.template","^24","~$temp","^24","^U","^U","~$test","^U","^1Z","^1Z","^1X","^1X","^1Y","^1X"],"~:form",["^N",["^Y","^U",["^N",["^22",["^24","^Z","^25"],["^U","^Z","^26"]]],["^N",["^21",["^1W","^Z","^16"],["^1X","^Z","^1Y"]]]]],"~:flags",["^ ","^22",["^J",[]],"^21",["^J",[]]],"~:js-deps",["^ "],"~:deps",["^1[","^1Z","^1W","^1X"]],"^T","^U","~:resource-id",["~:shadow.build.classpath/resource","cljs/test.cljs"],"~:compiled-at",1560836574802,"~:resource-name","cljs/test.cljs","~:warnings",[],"~:source",";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns\n^{:author \"Stuart Sierra, with contributions and suggestions by \n  Chas Emerick, Allen Rohner, Stuart Halloway, David Nolen, and\n  Leon Grapenthin\",\n     :doc \"A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the \\\"is\\\" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (= 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith \\\"abcde\\\" \\\"ab\\\"))\n\n   You can type an \\\"is\\\" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user> (is (= 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (= 5 (+ 2 2))\n         actual: (not (= 5 4))\n       false\n\n   The \\\"expected:\\\" line shows you the original expression, and the\n   \\\"actual:\\\" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not = to 5.  Finally, the\n   \\\"false\\\" on the last line is the value returned from the\n   expression.  The \\\"is\\\" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   \\\"(is (thrown? c ...))\\\" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0))) \n\n   \\\"(is (thrown-with-msg? c re ...))\\\" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #\\\"Divide by zero\\\"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   \\\"is\\\" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (= 5 (+ 2 2)) \\\"Crazy arithmetic\\\")\n\n   In addition, you can document groups of assertions with the\n   \\\"testing\\\" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to \\\"testing\\\" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec <http://rspec.info/>\n\n   (testing \\\"Arithmetic\\\"\n     (testing \\\"with positive integers\\\"\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4))))\n     (testing \\\"with negative integers\\\"\n       (is (= -4 (+ -2 -2)))\n       (is (= -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the \\\"testing\\\" macro may only be used\n   INSIDE a \\\"deftest\\\" form (see below).\n\n\n   DEFINING TESTS\n\n   (deftest addition\n     (is (= 4 (+ 2 2)))\n     (is (= 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (= 1 (- 4 3)))\n     (is (= 3 (- 7 4))))\n\n   This creates functions named \\\"addition\\\" and \\\"subtraction\\\", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel's \\\"Practical Common Lisp\\\"\n   <http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html>\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   \\\"(arithmetic addition)\\\", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n   DEFINING ASYNC TESTS\n\n   (deftest addition\n     (async done\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4)))\n       (done)))\n\n   Async tests are constructed with the async macro. The first argument to\n   the macro is the test completion callback. The body of the async macro may\n   be any series of expressions. The completion callback must be invoked when\n   all assertions have run. There is no support for asynchronous coordination -\n   core.async is recommended for this. Note the body of the async test must be\n   truly asynchronous to avoid stack overflow.\n\n   RUNNING TESTS\n\n   Run tests with the function \\\"(run-tests namespaces...)\\\":\n\n   (run-tests 'your.namespace 'some.other.namespace)\n\n   If you don't specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use \\\"(run-all-tests)\\\".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the \\\"arithmetic\\\" example above, you\n   probably do not want the \\\"addition\\\" and \\\"subtraction\\\" tests run\n   separately.  In that case, you must define a special function\n   named \\\"test-ns-hook\\\" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   \\\"run-tests\\\" also optionally takes a testing enviroment. A default\n   one is supplied for you by invoking \\\"empty-env\\\".  The test\n   environment contains everything needed to run tests including the\n   report results map. Fixtures must be present here if you want them\n   to run. Note that code that relies on \\\"test-ns\\\" will\n   automatically be supplied the appropriate defined fixtures.  For\n   example, this is done for you if you use \\\"run-tests\\\".\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can set the ClojureScript compiler build option\n   \\\":load-tests\\\" to false when loading or compiling code in\n   production.  This will prevent any tests from being created by\n   or \\\"deftest\\\".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is a map of one or two functions that run code before and\n   after tests.  It looks like this:\n\n   {:before (fn []\n              Perform setup, establish bindings, whatever.\n              )\n    :after (fn []\n             Tear-down / clean-up code here.\n             )}\n\n   Both are optional and can be left out.\n\n   Fixtures are attached to namespaces in one of two ways.  \\\"each\\\"\n   fixtures are run repeatedly, once for each test function created\n   with \\\"deftest\\\".  \\\"each\\\" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   \\\"each\\\" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just maps like the example above.\n   They can also be passed directly, like this:\n   (use-fixtures :each\n     {:before (fn [] setup...), :after (fn [] cleanup...)})\n\n   The other kind of fixture, a \\\"once\\\" fixture, is only run once,\n   around ALL the tests in the namespace.  \\\"once\\\" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach \\\"once\\\" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   WRAPPING FIXTURES\n\n   Instead of a map, a fixture can be specified like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   This style is incompatible with async tests. If an async test is\n   encountered, testing will be aborted. It can't be mixed with\n   fixtures specified as maps.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the \\\"is\\\" macro by defining new\n   methods for the \\\"assert-expr\\\" multimethod.  These methods are\n   called during expansion of the \\\"is\\\" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by specifying a\n   :reporter key in the test environment. It is normally set to\n   :cljs.test/default. Set this to the desired key and supply custom\n   implementations of the \\\"report\\\" multimethod.\n\n   The 'event' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to 'is'\n\n   The \\\"testing\\\" strings will be a list in the :testing-contexts\n   property of the test environment, and the vars being tested will be\n   a list in the :testing-vars property of the test environment.\n\n   For additional event types, see the examples in the code.\n\"}\n  cljs.test\n  (:require-macros [clojure.template :as temp]\n                   [cljs.test :as test])\n  (:require [clojure.string :as string]\n            [cljs.pprint :as pprint]))\n\n;; =============================================================================\n;; Default Reporting\n\n(defn empty-env\n  \"Generates a testing environment with a reporter.\n   (empty-env) - uses the :cljs.test/default reporter.\n   (empty-env :cljs.test/pprint) - pretty prints all data structures. \n   (empty-env reporter) - uses a reporter of your choosing.\n\n   To create your own reporter see cljs.test/report\"\n  ([] (empty-env ::default))\n  ([reporter]\n   (cond-> {:report-counters {:test 0 :pass 0 :fail 0 :error 0}\n            :testing-vars ()\n            :testing-contexts ()\n            :formatter pr-str\n            :reporter reporter}\n     (= ::pprint reporter) (assoc :reporter ::default\n                             :formatter pprint/pprint))))\n\n(def ^:dynamic *current-env* nil)\n\n(defn get-current-env []\n  (or *current-env* (empty-env)))\n\n(defn update-current-env! [ks f & args]\n  (set! *current-env* (apply update-in (get-current-env) ks f args)))\n\n(defn set-env! [new-env]\n  (set! *current-env* new-env))\n\n(defn clear-env! []\n  (set! *current-env* nil))\n\n(defn get-and-clear-env! []\n  \"Like get-current-env, but cleans env before returning.\"\n  (let [env (cljs.test/get-current-env)]\n    (clear-env!)\n    env))\n\n(defn testing-vars-str\n  \"Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion.\"\n  [m]\n  (let [{:keys [file line column]} m]\n    (str\n      (reverse (map #(:name (meta %)) (:testing-vars (get-current-env))))\n      \" (\" file \":\" line (when column (str \":\" column)) \")\")))\n\n(defn testing-contexts-str\n  \"Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces.\"\n  []\n  (apply str (interpose \" \" (reverse (:testing-contexts (get-current-env))))))\n\n(defn inc-report-counter!\n  \"Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil.\"\n  [name]\n  (if (:report-counters (get-current-env))\n    (update-current-env! [:report-counters name] (fnil inc 0))))\n\n(defmulti\n  ^{:doc \"Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key.\"\n     :dynamic true}\n  report (fn [m] [(:reporter (get-current-env)) (:type m)]))\n\n(defmethod report :default [m])\n\n(defmethod report [::default :pass] [m]\n  (inc-report-counter! :pass))\n\n(defn- print-comparison [m]\n  (let [formatter-fn (or (:formatter (get-current-env)) pr-str)]\n    (println \"expected:\" (formatter-fn (:expected m)))\n    (println \"  actual:\" (formatter-fn (:actual m)))))\n\n(defmethod report [::default :fail] [m]\n  (inc-report-counter! :fail)\n  (println \"\\nFAIL in\" (testing-vars-str m))\n  (when (seq (:testing-contexts (get-current-env)))\n    (println (testing-contexts-str)))\n  (when-let [message (:message m)] (println message))\n  (print-comparison m))\n\n(defmethod report [::default :error] [m]\n  (inc-report-counter! :error)\n  (println \"\\nERROR in\" (testing-vars-str m))\n  (when (seq (:testing-contexts (get-current-env)))\n    (println (testing-contexts-str)))\n  (when-let [message (:message m)] (println message))\n  (print-comparison m))\n\n(defmethod report [::default :summary] [m]\n  (println \"\\nRan\" (:test m) \"tests containing\"\n    (+ (:pass m) (:fail m) (:error m)) \"assertions.\")\n  (println (:fail m) \"failures,\" (:error m) \"errors.\"))\n\n(defmethod report [::default :begin-test-ns] [m]\n  (println \"\\nTesting\" (name (:ns m))))\n\n;; Ignore these message types:\n(defmethod report [::default :end-test-ns] [m])\n(defmethod report [::default :begin-test-var] [m]\n  #_(println \":begin-test-var\" (testing-vars-str m)))\n(defmethod report [::default :end-test-var] [m])\n(defmethod report [::default :end-run-tests] [m])\n(defmethod report [::default :end-test-all-vars] [m])\n(defmethod report [::default :end-test-vars] [m])\n\n;; =============================================================================\n;; File, Line, and Column Helpers\n\n(defn js-line-and-column [stack-element]\n  \"Returns a 2-element vector containing the line and\n  column encoded at the end of a stack element string.\n  A line or column will be represented as NaN if not\n  parsesable.\"\n  (let [parts (.split stack-element \":\")\n        cnt   (count parts)]\n    (if (> cnt 1)\n      [(js/parseInt (nth parts (- cnt 2)) 10)\n       (js/parseInt (nth parts (dec cnt)) 10)]\n      [##NaN ##NaN])))\n\n(defn js-filename [stack-element]\n  (let [output-dir (cljs.test/cljs-output-dir)\n        output-dir (cond-> output-dir\n                     (not (string/ends-with? output-dir \"/\"))\n                     (str \"/\"))]\n    (-> (.split stack-element output-dir)\n      last\n      (.split \":\")\n      first)))\n\n(defn mapped-line-and-column [filename line column]\n  (let [default [filename line column]]\n    (if-let [source-map (:source-map (get-current-env))]\n      ;; source maps are 0 indexed for lines\n      (if-let [columns (get-in source-map [filename (dec line)])]\n        (vec\n          (map\n            ;; source maps are 0 indexed for columns\n            ;; multiple segments may exist at column\n            ;; just take first\n            (first\n              (if-let [mapping (get columns (dec column))]\n                mapping\n                (second (first columns))))\n            [:source :line :col]))\n        default)\n      default)))\n\n(defn file-and-line [exception depth]\n  ;; TODO: flesh out\n  (if-let [stack-element (and (string? (.-stack exception))\n                              (some-> (.-stack exception)\n                                      string/split-lines\n                                      (get depth)\n                                      string/trim))]\n    (let [fname (js-filename stack-element)\n          [line column] (js-line-and-column stack-element)\n          [fname line column] (mapped-line-and-column fname line column)]\n      {:file fname :line line :column column})\n    {:file (.-fileName exception)\n     :line (.-lineNumber exception)}))\n\n(defn do-report [m]\n  (let [m (case (:type m)\n            :fail (merge (file-and-line (js/Error.) 4) m)\n            :error (merge (file-and-line (:actual m) 0) m)\n            m)]\n    (report m)))\n\n;; =============================================================================\n;; Async\n\n(defprotocol IAsyncTest\n  \"Marker protocol denoting CPS function to begin asynchronous\n  testing.\")\n\n(defn async?\n  \"Returns whether x implements IAsyncTest.\"\n  [x]\n  (satisfies? IAsyncTest x))\n\n(defn run-block\n  \"Invoke all functions in fns with no arguments. A fn can optionally\n  return\n\n  an async test - is invoked with a continuation running left fns\n\n  a seq of fns tagged per block - are invoked immediately after fn\"\n  [fns]\n  (when-first [f fns]\n    (let [obj (f)]\n      (if (async? obj)\n        (obj (let [d (delay (run-block (rest fns)))]\n               (fn []\n                 (if (realized? d)\n                   (println \"WARNING: Async test called done more than one time.\")\n                   @d))))\n        (recur (cond->> (rest fns)\n                 (::block? (meta obj)) (concat obj)))))))\n\n(defn block\n  \"Tag a seq of fns to be picked up by run-block as injected\n  continuation.  See run-block.\"\n  [fns]\n  (some-> fns\n          (vary-meta assoc ::block? true)))\n\n;; =============================================================================\n;; Low-level functions\n\n(defn- test-var-block*\n  [v t]\n  {:pre [(instance? Var v)]}\n  [(fn []\n     (update-current-env! [:testing-vars] conj v)\n     (update-current-env! [:report-counters :test] inc)\n     (do-report {:type :begin-test-var :var v})\n     (try\n       (t)\n       (catch :default e\n         (case e\n           ::async-disabled (throw \"Async tests require fixtures to be specified as maps.  Testing aborted.\")\n           (do-report\n            {:type :error\n             :message \"Uncaught exception, not in assertion.\"\n             :expected nil\n             :actual e})))))\n   (fn []\n     (do-report {:type :end-test-var :var v})\n     (update-current-env! [:testing-vars] rest))])\n\n(defn test-var-block\n  \"Like test-var, but returns a block for further composition and\n  later execution.\"\n  [v]\n  (if-let [t (:test (meta v))]\n    (test-var-block* v t)))\n\n(defn test-var\n  \"If v has a function in its :test metadata, calls that function,\n  add v to :testing-vars property of env.\"\n  [v]\n  (run-block (test-var-block v)))\n\n(defn- default-fixture\n  \"The default, empty, fixture function.  Just calls its argument.\n\n  NOTE: Incompatible with map fixtures.\"\n  [f]\n  (f))\n\n(defn compose-fixtures\n  \"Composes two fixture functions, creating a new fixture function\n  that combines their behavior.\n\n  NOTE: Incompatible with map fixtures.\"\n  [f1 f2]\n  (fn [g] (f1 (fn [] (f2 g)))))\n\n(defn join-fixtures\n  \"Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.\n\n  NOTE: Incompatible with map fixtures.\"\n  [fixtures]\n  (reduce compose-fixtures default-fixture fixtures))\n\n(defn- wrap-map-fixtures\n  \"Wraps block in map-fixtures.\"\n  [map-fixtures block]\n  (concat (keep :before map-fixtures)\n          block\n          (reverse (keep :after map-fixtures))))\n\n(defn- execution-strategy [once each]\n  (letfn [(fixtures-type [coll]\n            (cond\n              (empty? coll) :none\n              (every? map? coll) :map\n              (every? fn? coll) :fn))\n          (fixtures-types []\n            (->> (map fixtures-type [once each])\n              (remove #{:none})\n              (distinct)))]\n    (let [[type :as types] (fixtures-types)]\n      (assert (not-any? nil? types)\n        \"Fixtures may not be of mixed types\")\n      (assert (> 2 (count types))\n        \"fixtures specified in :once and :each must be of the same type\")\n      ({:map :async :fn :sync} type :async))))\n\n(defn- disable-async [f]\n  (fn []\n    (let [obj (f)]\n      (when (async? obj)\n        (throw ::async-disabled))\n      obj)))\n\n(defn test-vars-block\n  \"Like test-vars, but returns a block for further composition and\n  later execution.\"\n  [vars]\n  (map\n   (fn [[ns vars]]\n     (fn []\n       (block\n        (let [env (get-current-env)\n              once-fixtures (get-in env [:once-fixtures ns])\n              each-fixtures (get-in env [:each-fixtures ns])]\n          (case (execution-strategy once-fixtures each-fixtures)\n            :async\n            (->> vars\n                 (filter (comp :test meta))\n                 (mapcat (comp (partial wrap-map-fixtures each-fixtures)\n                               test-var-block))\n                 (wrap-map-fixtures once-fixtures))\n            :sync\n            (let [each-fixture-fn (join-fixtures each-fixtures)]\n              [(fn []\n                 ((join-fixtures once-fixtures)\n                  (fn []\n                    (doseq [v vars]\n                      (when-let [t (:test (meta v))]\n                        ;; (alter-meta! v update :test disable-async)\n                        (each-fixture-fn\n                         (fn []\n                           ;; (test-var v)\n                           (run-block\n                            (test-var-block* v (disable-async t))))))))))]))))))\n   (group-by (comp :ns meta) vars)))\n\n(defn test-vars\n  \"Groups vars by their namespace and runs test-vars on them with\n  appropriate fixtures assuming they are present in the current\n  testing environment.\"\n  [vars]\n  (run-block (concat (test-vars-block vars)\n                     [(fn []\n                        (report {:type :end-test-vars :vars vars}))])))\n\n;; =============================================================================\n;; Running Tests, high level functions\n\n(defn successful?\n  \"Returns true if the given test summary indicates all tests\n  were successful, false otherwise.\"\n  [summary]\n  (and (zero? (:fail summary 0))\n       (zero? (:error summary 0))))\n","~:reader-features",["^J",["~:cljs"]],"~:cljc",false,"~:source-map-compact",["^ ","mappings","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","names",["var_args","G__16371","cljs.test/empty-env","js/Error","cljs.test.empty_env.cljs$core$IFn$_invoke$arity$1","reporter","G__16372","cljs.core/pr-str","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","cljs.pprint/pprint","cljs.test/*current-env*","cljs.test/get-current-env","or__4131__auto__","cljs.test.empty_env.cljs$core$IFn$_invoke$arity$0","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","cljs.test/update-current-env!","seq16381","G__16382","cljs.core/first","cljs.core/next","G__16383","self__4717__auto__","ks","f","args","cljs.core.apply.cljs$core$IFn$_invoke$arity$5","cljs.core/update-in","cljs.test/set-env!","new-env","cljs.test/clear-env!","cljs.test/get-and-clear-env!","env","cljs.test/testing-vars-str","m","map__16406","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","file","line","column","cljs.core/reverse","p1__16405#","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core/meta","cljs.test/testing-contexts-str","cljs.core/str","cljs.core.interpose.cljs$core$IFn$_invoke$arity$2","cljs.test/inc-report-counter!","name","cljs.core.fnil.cljs$core$IFn$_invoke$arity$2","cljs.core/inc","js/cljs","js/cljs.test","js/cljs.test.report","method-table__4613__auto__","cljs.core.atom.cljs$core$IFn$_invoke$arity$1","prefer-table__4614__auto__","method-cache__4615__auto__","cached-hierarchy__4616__auto__","hierarchy__4617__auto__","cljs.core.get.cljs$core$IFn$_invoke$arity$3","fexpr__16413","cljs.core/MultiFn","cljs.core.symbol.cljs$core$IFn$_invoke$arity$2","cljs.test/report","cljs.test/print-comparison","formatter-fn","cljs.core.println.cljs$core$IFn$_invoke$arity$variadic","G__16422","G__16423","cljs.core/seq","temp__5720__auto__","message","cljs.core/name","cljs.test/js-line-and-column","stack-element","parts","cnt","cljs.core/count","js/parseInt","cljs.core.nth.cljs$core$IFn$_invoke$arity$2","cljs.test/js-filename","output-dir","G__16436","clojure.string/ends-with?","cljs.core/last","cljs.test/mapped-line-and-column","filename","default","temp__5718__auto__","source-map","columns","cljs.core.get_in.cljs$core$IFn$_invoke$arity$2","cljs.core/vec","mapping","cljs.core/second","cljs.test/file-and-line","exception","depth","and__4120__auto__","G__16439","clojure.string/split-lines","clojure.string/trim","vec__16440","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","vec__16443","fname","cljs.test/do-report","G__16450","cljs.core/Keyword","cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic","cljs.test/IAsyncTest","cljs.test/async?","x","cljs.core/native-satisfies?","cljs.test/run-block","fns","xs__6277__auto__","obj","G__16464","d","cljs.core/Delay","G__16465","cljs.core/rest","cljs.core/deref","cljs.core/realized?","G__16466","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","cljs.test/block","G__16467","cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$4","cljs.core/assoc","cljs.test/test-var-block*","v","t","cljs.test.update_current_env_BANG_.cljs$core$IFn$_invoke$arity$variadic","cljs.core/conj","e16469","e","G__16470","cljs.test/test-var-block","cljs.test/test-var","cljs.test/default-fixture","cljs.test/compose-fixtures","f1","f2","g","G__16479","cljs.test/join-fixtures","fixtures","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","cljs.test/wrap-map-fixtures","map-fixtures","block","cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic","cljs.core.keep.cljs$core$IFn$_invoke$arity$2","cljs.test/execution-strategy","once","each","coll","cljs.core/empty?","cljs.core/every?","cljs.core/map?","cljs.core/fn?","fixtures-type","cljs.core.remove.cljs$core$IFn$_invoke$arity$2","cljs.core.distinct.cljs$core$IFn$_invoke$arity$1","vec__16480","type","types","fixtures-types","G__16486","G__16487","fexpr__16485","cljs.test/disable-async","cljs.test/test-vars-block","vars","p__16490","vec__16491","ns","once-fixtures","each-fixtures","G__16494","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","each-fixture-fn","G__16496","fexpr__16495","seq__16497","chunk__16498","count__16499","i__16500","cljs.core/chunked-seq?","c__4550__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","G__16508","G__16509","cljs.core/group-by","cljs.test/test-vars","G__16510","cljs.test/successful?","summary"]]],"~:cache-keys",["~#cmap",[["^V","^1Z"],[1559826623000],["^2<","goog/math/math.js"],[1560546089000,"~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^J",[]],"~:deps-syms",["^1[","~$goog.array","~$goog.asserts"]]],["^2<","goog/array/array.js"],[1560546089000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1[","^2N"]]],["^2<","goog/debug/error.js"],[1560546089000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1["]]],["^2<","goog/dom/nodetype.js"],[1560546089000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1["]]],["^2<","cljs/pprint.cljs"],[1559826623000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1[","^1Z","^1W","~$goog.string","~$goog.string.StringBuffer"]]],["^2<","goog/object/object.js"],[1560546089000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1["]]],"~:SHADOW-TIMESTAMP",[1560546091000,1559826623000],["^2<","goog/math/long.js"],[1560546089000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1[","^2N","~$goog.reflect"]]],["^2<","goog/string/internal.js"],[1560546089000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1["]]],["^2<","goog/functions/functions.js"],[1560546089000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1["]]],["^2<","goog/structs/map.js"],[1560546089000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1[","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^2<","goog/asserts/asserts.js"],[1560546089000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1[","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^V","^1X"],[1559826623000],["^2<","goog/uri/uri.js"],[1560546089000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1[","^2M","^2N","^2O","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^V","^U"],[1559826623000],["^2<","goog/base.js"],[1560546089000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",[]]],["^2<","goog/structs/structs.js"],[1560546089000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1[","^2M","~$goog.object"]]],["^2<","clojure/string.cljs"],[1559826623000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1[","^1Z","^2O","^2P"]]],["^2<","goog/string/string.js"],[1560546089000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1[","~$goog.string.internal"]]],["^2<","goog/reflect/reflect.js"],[1560546089000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1["]]],["^V","^24"],[1545934326000],["^2<","goog/string/stringbuffer.js"],[1560546089000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1["]]],["^2<","goog/iter/iter.js"],[1560546089000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1[","^2M","^2N","~$goog.functions","~$goog.math"]]],["^2<","cljs/core.cljs"],[1559826623000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["~$goog.math.Long","~$goog.math.Integer","^2O","^30","^2M","~$goog.Uri","^2P"]]],["^2<","goog/math/integer.js"],[1560546089000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1["]]],["^2<","goog/uri/utils.js"],[1560546089000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1[","^2M","^2N","^2O"]]],["^2<","cljs/test.cljs"],[1559826623000,"^2I",["^ ","^2J",null,"^2K",["^J",[]],"^2L",["^1[","^1Z","^1W","^1X"]]]]],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","cljs/test.cljs","^7",243,"^8",3,"^9",243,"^:",12,"^;","Stuart Sierra, with contributions and suggestions by \n  Chas Emerick, Allen Rohner, Stuart Halloway, David Nolen, and\n  Leon Grapenthin","^<","A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the \"is\" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (= 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith \"abcde\" \"ab\"))\n\n   You can type an \"is\" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user> (is (= 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (= 5 (+ 2 2))\n         actual: (not (= 5 4))\n       false\n\n   The \"expected:\" line shows you the original expression, and the\n   \"actual:\" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not = to 5.  Finally, the\n   \"false\" on the last line is the value returned from the\n   expression.  The \"is\" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   \"(is (thrown? c ...))\" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0))) \n\n   \"(is (thrown-with-msg? c re ...))\" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #\"Divide by zero\"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   \"is\" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (= 5 (+ 2 2)) \"Crazy arithmetic\")\n\n   In addition, you can document groups of assertions with the\n   \"testing\" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to \"testing\" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec <http://rspec.info/>\n\n   (testing \"Arithmetic\"\n     (testing \"with positive integers\"\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4))))\n     (testing \"with negative integers\"\n       (is (= -4 (+ -2 -2)))\n       (is (= -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the \"testing\" macro may only be used\n   INSIDE a \"deftest\" form (see below).\n\n\n   DEFINING TESTS\n\n   (deftest addition\n     (is (= 4 (+ 2 2)))\n     (is (= 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (= 1 (- 4 3)))\n     (is (= 3 (- 7 4))))\n\n   This creates functions named \"addition\" and \"subtraction\", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel's \"Practical Common Lisp\"\n   <http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html>\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   \"(arithmetic addition)\", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n   DEFINING ASYNC TESTS\n\n   (deftest addition\n     (async done\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4)))\n       (done)))\n\n   Async tests are constructed with the async macro. The first argument to\n   the macro is the test completion callback. The body of the async macro may\n   be any series of expressions. The completion callback must be invoked when\n   all assertions have run. There is no support for asynchronous coordination -\n   core.async is recommended for this. Note the body of the async test must be\n   truly asynchronous to avoid stack overflow.\n\n   RUNNING TESTS\n\n   Run tests with the function \"(run-tests namespaces...)\":\n\n   (run-tests 'your.namespace 'some.other.namespace)\n\n   If you don't specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use \"(run-all-tests)\".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the \"arithmetic\" example above, you\n   probably do not want the \"addition\" and \"subtraction\" tests run\n   separately.  In that case, you must define a special function\n   named \"test-ns-hook\" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   \"run-tests\" also optionally takes a testing enviroment. A default\n   one is supplied for you by invoking \"empty-env\".  The test\n   environment contains everything needed to run tests including the\n   report results map. Fixtures must be present here if you want them\n   to run. Note that code that relies on \"test-ns\" will\n   automatically be supplied the appropriate defined fixtures.  For\n   example, this is done for you if you use \"run-tests\".\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can set the ClojureScript compiler build option\n   \":load-tests\" to false when loading or compiling code in\n   production.  This will prevent any tests from being created by\n   or \"deftest\".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is a map of one or two functions that run code before and\n   after tests.  It looks like this:\n\n   {:before (fn []\n              Perform setup, establish bindings, whatever.\n              )\n    :after (fn []\n             Tear-down / clean-up code here.\n             )}\n\n   Both are optional and can be left out.\n\n   Fixtures are attached to namespaces in one of two ways.  \"each\"\n   fixtures are run repeatedly, once for each test function created\n   with \"deftest\".  \"each\" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   \"each\" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just maps like the example above.\n   They can also be passed directly, like this:\n   (use-fixtures :each\n     {:before (fn [] setup...), :after (fn [] cleanup...)})\n\n   The other kind of fixture, a \"once\" fixture, is only run once,\n   around ALL the tests in the namespace.  \"once\" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach \"once\" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   WRAPPING FIXTURES\n\n   Instead of a map, a fixture can be specified like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   This style is incompatible with async tests. If an async test is\n   encountered, testing will be aborted. It can't be mixed with\n   fixtures specified as maps.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the \"is\" macro by defining new\n   methods for the \"assert-expr\" multimethod.  These methods are\n   called during expansion of the \"is\" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by specifying a\n   :reporter key in the test environment. It is normally set to\n   :cljs.test/default. Set this to the desired key and supply custom\n   implementations of the \"report\" multimethod.\n\n   The 'event' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to 'is'\n\n   The \"testing\" strings will be a list in the :testing-contexts\n   property of the test environment, and the vars being tested will be\n   a list in the :testing-vars property of the test environment.\n\n   For additional event types, see the examples in the code.\n"],"^=",["^ ","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G"],"^H",null,"^I",["^J",[]],"^K",["^ ","^L",["^ ","^M",["^N",[["^O","^P","~$&","^Q"]]],"^<","Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers.","^7",172,"^8",1,"^6","cljs/test.cljc","^R","^S","^T","^U","^V",true],"^W",["^ ","^M",["^N",[[["^X","^Y","^Z","^["]]]],"^<","Calls test-vars on every var with :test metadata interned in the\n  namespace, with fixtures.","^7",339,"^8",1,"^6","cljs/test.cljc","^R","^10","^T","^U","^V",true],"^11",["^ ","^M",["^N",[[],["^12"],["^12","^13"]]],"^<","Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested.","^7",302,"^8",1,"^6","cljs/test.cljc","^R","^14","^T","^U","^V",true],"^15",["^ ","^M",["^N",[["^16","~$&","^17"]]],"^<","Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest).","^7",196,"^8",1,"^6","cljs/test.cljc","^R","^18","^T","^U","^V",true],"^19",["^ ","^M",["^N",[["^1:","~$&","^17"]]],"^<","Wraps body as a CPS function that can be returned from a test to\n  continue asynchronously.  Binds done to a function that must be\n  invoked once and from an async context after any assertions.\n\n  (deftest example-with-timeout\n    (async done\n      (js/setTimeout (fn []\n                       ;; make assertions in async context...\n                       (done) ;; ...then call done\n                       )\n                     0)))","^7",228,"^8",1,"^6","cljs/test.cljc","^R","^1;","^T","^U","^V",true],"^1<",["^ ","^M",["^N",[["^["],["^[","^1="]]],"^<","Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re.","^7",154,"^8",1,"^6","cljs/test.cljc","^R","^1>","^T","^U","^V",true],"^1?",["^ ","^M",["^N",[["^1@","~$&","^17"]]],"^<","Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When cljs.analyzer/*load-tests* is false, deftest is ignored.","^7",210,"^8",1,"^6","cljs/test.cljc","^R","^1A","^T","^U","^V",true],"^1B",["^ ","^M",["^N",[["^1C","~$&","^1D"]]],"^<","Like test-vars, but returns a block for further composition and\n  later execution.","^7",253,"^8",1,"^6","cljs/test.cljc","^R","^1E","^T","^U","^V",true],"^1F",["^ ","^M",["^N",[["^13",["^X","^Y","^Z","^["]]]],"^<","Like test-ns, but returns a block for further composition and\n  later execution.  Does not clear the current env.","^7",348,"^8",1,"^6","cljs/test.cljc","^R","^1G","^T","^U","^V",true],"^1H",["^ ","^M",["^N",[["^1=","^["]]],"^<","Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this.","^7",140,"^8",1,"^6","cljs/test.cljc","^R","^1I","^T","^U","^V",true],"^1J",["^ ","^M",["^N",[["^1K","~$&","^1L"]]],"^7",382,"^8",1,"^6","cljs/test.cljc","^R","^1M","^T","^U","^V",true],"^1N",["^ ","^M",["^N",[["^Y"],["^13",["^X","^Y","^Z","^["]]]],"^<","If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  ","^7",365,"^8",1,"^6","cljs/test.cljc","^R","^1O","^T","^U","^V",true],"^1P",["^ ","^M",["^N",[[["^X","^Y"]]]],"^7",316,"^8",1,"^6","cljs/test.cljc","^R","^1Q","^T","^U","^V",true],"^1R",["^ ","^M",["^N",[[],["^1C"],["^1C","~$&","^1D"]]],"^<","Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given. Does not return a meaningful\n  value due to the possiblity of asynchronous execution. To detect test\n  completion add a :end-run-tests method case to the cljs.test/report\n  multimethod.","^7",288,"^8",1,"^6","cljs/test.cljc","^R","^1S","^T","^U","^V",true]],"^R","^U","^1U",null,"^1V",["^ ","^1W","^1W","^16","^1W","^1X","^1X","^1Y","^1X","^1Z","^1Z","^1[","^1["],"^20",["^J",["^21","^22"]],"~:shadow/js-access-global",["^J",["Error","parseInt"]],"^23",null,"~:defs",["^ ","~$default-fixture",["^ ","~:protocol-inline",null,"^5",["^ ","^6","cljs/test.cljs","^7",502,"^8",8,"^9",502,"^:",23,"~:private",true,"^M",["^N",["^X",["^N",[["~$f"]]]]],"^<","The default, empty, fixture function.  Just calls its argument.\n\n  NOTE: Incompatible with map fixtures."],"^3<",true,"^R","~$cljs.test/default-fixture","^6","cljs/test.cljs","^:",23,"~:method-params",["^N",[["~$f"]]],"~:protocol-impl",null,"~:arglists-meta",["^N",[null,null]],"^8",1,"~:variadic?",false,"^7",502,"~:ret-tag","~$any","^9",502,"~:max-fixed-arity",1,"~:fn-var",true,"^M",["^N",["^X",["^N",[["~$f"]]]]],"^<","The default, empty, fixture function.  Just calls its argument.\n\n  NOTE: Incompatible with map fixtures."],"~$test-var",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",496,"^8",7,"^9",496,"^:",15,"^M",["^N",["^X",["^N",[["~$v"]]]]],"^<","If v has a function in its :test metadata, calls that function,\n  add v to :testing-vars property of env."],"^R","~$cljs.test/test-var","^6","cljs/test.cljs","^:",15,"^3>",["^N",[["~$v"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",496,"^3B",["^J",["^3C","~$clj-nil"]],"^9",496,"^3D",1,"^3E",true,"^M",["^N",["^X",["^N",[["~$v"]]]]],"^<","If v has a function in its :test metadata, calls that function,\n  add v to :testing-vars property of env."],"~$execution-strategy",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",532,"^8",8,"^9",532,"^:",26,"^3<",true,"^M",["^N",["^X",["^N",[["~$once","~$each"]]]]]],"^3<",true,"^R","~$cljs.test/execution-strategy","^6","cljs/test.cljs","^:",26,"^3>",["^N",[["^3J","^3K"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",532,"^9",532,"^3D",2,"^3E",true,"^M",["^N",["^X",["^N",[["^3J","^3K"]]]]]],"~$do-report",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",420,"^8",7,"^9",420,"^:",16,"^M",["^N",["^X",["^N",[["~$m"]]]]]],"^R","~$cljs.test/do-report","^6","cljs/test.cljs","^:",16,"^3>",["^N",[["~$m"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",420,"^3B","^3C","^9",420,"^3D",1,"^3E",true,"^M",["^N",["^X",["^N",[["~$m"]]]]]],"~$async?",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",434,"^8",7,"^9",434,"^:",13,"^M",["^N",["^X",["^N",[["~$x"]]]]],"^<","Returns whether x implements IAsyncTest."],"^R","~$cljs.test/async?","^6","cljs/test.cljs","^:",13,"^3>",["^N",[["~$x"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",434,"^3B","~$boolean","^9",434,"^3D",1,"^3E",true,"^M",["^N",["^X",["^N",[["~$x"]]]]],"^<","Returns whether x implements IAsyncTest."],"~$testing-contexts-str",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",299,"^8",7,"^9",299,"^:",27,"^M",["^N",["^X",["^N",[[]]]]],"^<","Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces."],"^R","~$cljs.test/testing-contexts-str","^6","cljs/test.cljs","^:",27,"^3>",["^N",[[]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",299,"^3B","^3C","^9",299,"^3D",0,"^3E",true,"^M",["^N",["^X",["^N",[[]]]]],"^<","Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces."],"~$join-fixtures",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",517,"^8",7,"^9",517,"^:",20,"^M",["^N",["^X",["^N",[["~$fixtures"]]]]],"^<","Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.\n\n  NOTE: Incompatible with map fixtures."],"^R","~$cljs.test/join-fixtures","^6","cljs/test.cljs","^:",20,"^3>",["^N",[["^3U"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",517,"^3B",["^J",[null,"^3C"]],"^9",517,"^3D",1,"^3E",true,"^M",["^N",["^X",["^N",[["^3U"]]]]],"^<","Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.\n\n  NOTE: Incompatible with map fixtures."],"~$inc-report-counter!",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",305,"^8",7,"^9",305,"^:",26,"^M",["^N",["^X",["^N",[["^1@"]]]]],"^<","Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil."],"^R","~$cljs.test/inc-report-counter!","^6","cljs/test.cljs","^:",26,"^3>",["^N",[["^1@"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",305,"^3B",["^J",["^3C","^3H"]],"^9",305,"^3D",1,"^3E",true,"^M",["^N",["^X",["^N",[["^1@"]]]]],"^<","Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil."],"~$get-current-env",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",271,"^8",7,"^9",271,"^:",22,"^M",["^N",["^X",["^N",[[]]]]]],"^R","~$cljs.test/get-current-env","^6","cljs/test.cljs","^:",22,"^3>",["^N",[[]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",271,"^3B",["^J",["^3C","^3H"]],"^9",271,"^3D",0,"^3E",true,"^M",["^N",["^X",["^N",[[]]]]]],"~$file-and-line",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",406,"^8",7,"^9",406,"^:",20,"^M",["^N",["^X",["^N",[["~$exception","~$depth"]]]]]],"^R","~$cljs.test/file-and-line","^6","cljs/test.cljs","^:",20,"^3>",["^N",[["^40","^41"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",406,"^3B","~$cljs.core/IMap","^9",406,"^3D",2,"^3E",true,"^M",["^N",["^X",["^N",[["^40","^41"]]]]]],"~$block",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",458,"^8",7,"^9",458,"^:",12,"^M",["^N",["^X",["^N",[["^1L"]]]]],"^<","Tag a seq of fns to be picked up by run-block as injected\n  continuation.  See run-block."],"^R","~$cljs.test/block","^6","cljs/test.cljs","^:",12,"^3>",["^N",[["^1L"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",458,"^3B",["^J",["~$clj","~$cljs.core/MetaFn","^3H"]],"^9",458,"^3D",1,"^3E",true,"^M",["^N",["^X",["^N",[["^1L"]]]]],"^<","Tag a seq of fns to be picked up by run-block as injected\n  continuation.  See run-block."],"~$report",["^ ","^5",["^ ","^6","cljs/test.cljs","^7",318,"^8",3,"^9",318,"^:",9,"^<","Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key.","~:dynamic",true],"^R","~$cljs.test/report","^6","cljs/test.cljs","^:",9,"^8",1,"^49",true,"^7",312,"^9",318,"~:tag","~$cljs.core/MultiFn","^<","Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key."],"~$compose-fixtures",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",509,"^8",7,"^9",509,"^:",23,"^M",["^N",["^X",["^N",[["~$f1","~$f2"]]]]],"^<","Composes two fixture functions, creating a new fixture function\n  that combines their behavior.\n\n  NOTE: Incompatible with map fixtures."],"^R","~$cljs.test/compose-fixtures","^6","cljs/test.cljs","^:",23,"^3>",["^N",[["^4>","^4?"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",509,"^3B","~$function","^9",509,"^3D",2,"^3E",true,"^M",["^N",["^X",["^N",[["^4>","^4?"]]]]],"^<","Composes two fixture functions, creating a new fixture function\n  that combines their behavior.\n\n  NOTE: Incompatible with map fixtures."],"~$disable-async",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",549,"^8",8,"^9",549,"^:",21,"^3<",true,"^M",["^N",["^X",["^N",[["~$f"]]]]]],"^3<",true,"^R","~$cljs.test/disable-async","^6","cljs/test.cljs","^:",21,"^3>",["^N",[["~$f"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",549,"^3B","^4A","^9",549,"^3D",1,"^3E",true,"^M",["^N",["^X",["^N",[["~$f"]]]]]],"~$test-var-block*",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",468,"^8",8,"^9",468,"^:",23,"^3<",true,"^M",["^N",["^X",["^N",[["~$v","~$t"]]]]]],"^3<",true,"^R","~$cljs.test/test-var-block*","^6","cljs/test.cljs","^:",23,"^3>",["^N",[["~$v","~$t"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",468,"^3B","~$cljs.core/IVector","^9",468,"^3D",2,"^3E",true,"^M",["^N",["^X",["^N",[["~$v","~$t"]]]]]],"~$js-line-and-column",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",366,"^8",7,"^9",366,"^:",25,"^M",["^N",["^X",["^N",[["~$stack-element"]]]]]],"^R","~$cljs.test/js-line-and-column","^6","cljs/test.cljs","^:",25,"^3>",["^N",[["^4H"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",366,"^3B","^4F","^9",366,"^3D",1,"^3E",true,"^M",["^N",["^X",["^N",[["^4H"]]]]]],"~$IAsyncTest",["^ ","^5",["^ ","~:protocol-symbol",true,"^6","cljs/test.cljs","^:",24,"^8",14,"^7",430,"~:protocol-info",["^ ","~:methods",["^ "]],"^9",430,"^<","Marker protocol denoting CPS function to begin asynchronous\n  testing.","~:jsdoc",["^N",["@interface"]]],"^4K",true,"^R","~$cljs.test/IAsyncTest","^6","cljs/test.cljs","^:",24,"^8",1,"^7",430,"^4L",["^ ","^4M",["^ "]],"~:info",null,"^9",430,"^4;","^3C","~:impls",["^J",[]],"^<","Marker protocol denoting CPS function to begin asynchronous\n  testing.","^4N",["^N",["@interface"]]],"~$print-comparison",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",325,"^8",8,"^9",325,"^:",24,"^3<",true,"^M",["^N",["^X",["^N",[["~$m"]]]]]],"^3<",true,"^R","~$cljs.test/print-comparison","^6","cljs/test.cljs","^:",24,"^3>",["^N",[["~$m"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",325,"^3B","^3H","^9",325,"^3D",1,"^3E",true,"^M",["^N",["^X",["^N",[["~$m"]]]]]],"~$test-vars-block",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",556,"^8",7,"^9",556,"^:",22,"^M",["^N",["^X",["^N",[["~$vars"]]]]],"^<","Like test-vars, but returns a block for further composition and\n  later execution."],"^R","~$cljs.test/test-vars-block","^6","cljs/test.cljs","^:",22,"^3>",["^N",[["^4U"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",556,"^3B","~$cljs.core/LazySeq","^9",556,"^3D",1,"^3E",true,"^M",["^N",["^X",["^N",[["^4U"]]]]],"^<","Like test-vars, but returns a block for further composition and\n  later execution."],"~$clear-env!",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",280,"^8",7,"^9",280,"^:",17,"^M",["^N",["^X",["^N",[[]]]]]],"^R","~$cljs.test/clear-env!","^6","cljs/test.cljs","^:",17,"^3>",["^N",[[]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",280,"^9",280,"^3D",0,"^3E",true,"^M",["^N",["^X",["^N",[[]]]]]],"~$set-env!",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",277,"^8",7,"^9",277,"^:",15,"^M",["^N",["^X",["^N",[["~$new-env"]]]]]],"^R","~$cljs.test/set-env!","^6","cljs/test.cljs","^:",15,"^3>",["^N",[["^4["]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",277,"^9",277,"^3D",1,"^3E",true,"^M",["^N",["^X",["^N",[["^4["]]]]]],"~$wrap-map-fixtures",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",525,"^8",8,"^9",525,"^:",25,"^3<",true,"^M",["^N",["^X",["^N",[["~$map-fixtures","^44"]]]]],"^<","Wraps block in map-fixtures."],"^3<",true,"^R","~$cljs.test/wrap-map-fixtures","^6","cljs/test.cljs","^:",25,"^3>",["^N",[["^52","^44"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",525,"^3B","^4W","^9",525,"^3D",2,"^3E",true,"^M",["^N",["^X",["^N",[["^52","^44"]]]]],"^<","Wraps block in map-fixtures."],"~$mapped-line-and-column",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",388,"^8",7,"^9",388,"^:",29,"^M",["^N",["^X",["^N",[["~$filename","~$line","~$column"]]]]]],"^R","~$cljs.test/mapped-line-and-column","^6","cljs/test.cljs","^:",29,"^3>",["^N",[["^55","^56","^57"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",388,"^3B",["^J",["^46","^4F","^3C","^47","^3H"]],"^9",388,"^3D",3,"^3E",true,"^M",["^N",["^X",["^N",[["^55","^56","^57"]]]]]],"~$test-vars",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",589,"^8",7,"^9",589,"^:",16,"^M",["^N",["^X",["^N",[["^4U"]]]]],"^<","Groups vars by their namespace and runs test-vars on them with\n  appropriate fixtures assuming they are present in the current\n  testing environment."],"^R","~$cljs.test/test-vars","^6","cljs/test.cljs","^:",16,"^3>",["^N",[["^4U"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",589,"^3B",["^J",["^3C","^3H"]],"^9",589,"^3D",1,"^3E",true,"^M",["^N",["^X",["^N",[["^4U"]]]]],"^<","Groups vars by their namespace and runs test-vars on them with\n  appropriate fixtures assuming they are present in the current\n  testing environment."],"~$get-and-clear-env!",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",283,"^8",7,"^9",283,"^:",25,"^M",["^N",["^X",["^N",[[]]]]]],"^R","~$cljs.test/get-and-clear-env!","^6","cljs/test.cljs","^:",25,"^3>",["^N",[[]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",283,"^3B",["^J",["^3C","^3H"]],"^9",283,"^3D",0,"^3E",true,"^M",["^N",["^X",["^N",[[]]]]]],"~$test-var-block",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",489,"^8",7,"^9",489,"^:",21,"^M",["^N",["^X",["^N",[["~$v"]]]]],"^<","Like test-var, but returns a block for further composition and\n  later execution."],"^R","~$cljs.test/test-var-block","^6","cljs/test.cljs","^:",21,"^3>",["^N",[["~$v"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",489,"^3B",["^J",["^4F","^3H"]],"^9",489,"^3D",1,"^3E",true,"^M",["^N",["^X",["^N",[["~$v"]]]]],"^<","Like test-var, but returns a block for further composition and\n  later execution."],"~$successful?",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",601,"^8",7,"^9",601,"^:",18,"^M",["^N",["^X",["^N",[["~$summary"]]]]],"^<","Returns true if the given test summary indicates all tests\n  were successful, false otherwise."],"^R","~$cljs.test/successful?","^6","cljs/test.cljs","^:",18,"^3>",["^N",[["^5@"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",601,"^3B","^3Q","^9",601,"^3D",1,"^3E",true,"^M",["^N",["^X",["^N",[["^5@"]]]]],"^<","Returns true if the given test summary indicates all tests\n  were successful, false otherwise."],"~$empty-env",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",252,"^8",7,"^9",252,"^:",16,"^M",["^N",["^X",["^N",[[],["~$reporter"]]]]],"^<","Generates a testing environment with a reporter.\n   (empty-env) - uses the :cljs.test/default reporter.\n   (empty-env :cljs.test/pprint) - pretty prints all data structures. \n   (empty-env reporter) - uses a reporter of your choosing.\n\n   To create your own reporter see cljs.test/report","~:top-fn",["^ ","^3A",false,"~:fixed-arity",1,"^3D",1,"^3>",["^N",[[],["^5C"]]],"^M",["^N",[[],["^5C"]]],"^3@",["^N",[null,null]]]],"^R","~$cljs.test/empty-env","^6","cljs/test.cljs","^:",16,"^5D",["^ ","^3A",false,"^5E",1,"^3D",1,"^3>",["^N",[[],["^5C"]]],"^M",["^N",[[],["^5C"]]],"^3@",["^N",[null,null]]],"^3>",["^N",[[],["^5C"]]],"^3?",null,"^5E",1,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^4M",[["^ ","^5E",0,"^3A",false,"^4;","^3C"],["^ ","^5E",1,"^3A",false,"^4;",["^J",["^46","^3C","^43"]]]],"^7",252,"^9",252,"^3D",1,"^3E",true,"^M",["^N",[[],["^5C"]]],"^<","Generates a testing environment with a reporter.\n   (empty-env) - uses the :cljs.test/default reporter.\n   (empty-env :cljs.test/pprint) - pretty prints all data structures. \n   (empty-env reporter) - uses a reporter of your choosing.\n\n   To create your own reporter see cljs.test/report"],"~$testing-vars-str",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",289,"^8",7,"^9",289,"^:",23,"^M",["^N",["^X",["^N",[["~$m"]]]]],"^<","Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion."],"^R","~$cljs.test/testing-vars-str","^6","cljs/test.cljs","^:",23,"^3>",["^N",[["~$m"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",289,"^3B","^16","^9",289,"^3D",1,"^3E",true,"^M",["^N",["^X",["^N",[["~$m"]]]]],"^<","Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion."],"~$*current-env*",["^ ","^5",["^ ","^6","cljs/test.cljs","^7",269,"^8",16,"^9",269,"^:",29,"^49",true],"^R","~$cljs.test/*current-env*","^6","cljs/test.cljs","^:",29,"^8",1,"^49",true,"^7",269,"^9",269,"^4;","^3H"],"~$run-block",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",439,"^8",7,"^9",439,"^:",16,"^M",["^N",["^X",["^N",[["^1L"]]]]],"^<","Invoke all functions in fns with no arguments. A fn can optionally\n  return\n\n  an async test - is invoked with a continuation running left fns\n\n  a seq of fns tagged per block - are invoked immediately after fn"],"^R","~$cljs.test/run-block","^6","cljs/test.cljs","^:",16,"^3>",["^N",[["^1L"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",439,"^3B",["^J",["^3C","^3H"]],"^9",439,"^3D",1,"^3E",true,"^M",["^N",["^X",["^N",[["^1L"]]]]],"^<","Invoke all functions in fns with no arguments. A fn can optionally\n  return\n\n  an async test - is invoked with a continuation running left fns\n\n  a seq of fns tagged per block - are invoked immediately after fn"],"~$update-current-env!",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",274,"^8",7,"^9",274,"^:",26,"^M",["^N",["^X",["^N",[["~$ks","~$f","~$&","^Q"]]]]],"^5D",["^ ","^3A",true,"^5E",2,"^3D",2,"^3>",[["^N",["^5N","~$f","^Q"]]],"^M",["^N",[["^5N","~$f","~$&","^Q"]]],"^3@",["^N",[null]]]],"^R","~$cljs.test/update-current-env!","^6","cljs/test.cljs","^:",26,"^5D",["^ ","^3A",true,"^5E",2,"^3D",2,"^3>",[["^N",["^5N","~$f","^Q"]]],"^M",["^N",[["^5N","~$f","~$&","^Q"]]],"^3@",["^N",[null]]],"^3>",[["^N",["^5N","~$f","^Q"]]],"^3?",null,"^5E",2,"^3@",["^N",[null]],"^8",1,"^3A",true,"^4M",[["^ ","^5E",2,"^3A",true]],"^7",274,"^3B","^3C","^9",274,"^3D",2,"^3E",true,"^M",["^N",[["^5N","~$f","~$&","^Q"]]]],"~$js-filename",["^ ","^3;",null,"^5",["^ ","^6","cljs/test.cljs","^7",378,"^8",7,"^9",378,"^:",18,"^M",["^N",["^X",["^N",[["^4H"]]]]]],"^R","~$cljs.test/js-filename","^6","cljs/test.cljs","^:",18,"^3>",["^N",[["^4H"]]],"^3?",null,"^3@",["^N",[null,null]],"^8",1,"^3A",false,"^7",378,"^3B",["^J",["^3C","^3H"]],"^9",378,"^3D",1,"^3E",true,"^M",["^N",["^X",["^N",[["^4H"]]]]]]],"^22",["^ ","^24","^24","^25","^24","^U","^U","^26","^U","^1Z","^1Z","^1X","^1X","^1Y","^1X"],"~:cljs.analyzer/constants",["^ ","^20",["^J",["~:async","~:testing-vars","~:fn","~:begin-test-var","~:testing-contexts","~:report-counters","~:default","^T","^R","~:each-fixtures","~:cljs.test/pprint","~:formatter","^6","~:type","^2@","~:sync","~:cljs.analyzer/analyzed","~:cljs.test/async-disabled","^8","~:summary","~:end-test-var","~:fail","~:after","~:reporter","^7","~:var","~:end-run-tests","~:col","~:end-test-all-vars","~:expected","~:cljs.test/default","~:source-map","~:begin-test-ns","~:error","~:pass","~:hierarchy","~:actual","~:before","~:end-test-ns","~:map","~:test","~:cljs.test/block?","~:none","~:message","~:vars","~:once-fixtures","~:end-test-vars"]],"~:order",["^6?","^5X","^5T","^5W","^60","^69","^6I","^6C","^67","^6B","^5[","^6","^7","^8","^R","^6D","^61","^5Y","^6>","^6E","^6L","^65","^6A","^T","^6G","^5V","^66","^6;","^6=","^6O","^6@","^2@","^6<","^6J","^6:","^6F","^68","^6K","^6H","^5U","^5S","^62","^63","^64","^6N","^5Z","^6M"]],"^28",["^ ","^22",["^J",[]],"^21",["^J",[]]],"^29",["^ "],"^2:",["^1[","^1Z","^1W","^1X"]],"^T","^U","~:ns-specs",["^ "],"~:ns-speced-vars",[],"~:compiler-options",["^2H",[["^6S","~:static-fns"],true,["^6S","~:elide-asserts"],true,["^6S","~:optimize-constants"],null,["^6S","^2?"],null,["^6S","~:external-config"],null,["^6S","~:tooling-config"],null,["^6S","~:emit-constants"],null,["^6S","~:load-tests"],false,["^6S","~:infer-externs"],"~:auto",["^6S","^2A"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:release",["^6S","~:fn-invoke-direct"],null,["^6S","^6@"],null]]]