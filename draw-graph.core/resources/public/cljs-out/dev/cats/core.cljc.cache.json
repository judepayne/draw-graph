["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ ","~$alet","~$cats.core","~$mlet","^6"],"~:excludes",["~#set",["~$when","~$unless","~$filter","~$sequence"]],"~:name","^6","~:imports",null,"~:requires",["^ ","~$p","~$cats.protocols","^A","^A","~$clojure.set","^B","~$ctx","~$cats.context","^D","^D"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$arity",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","~:line",629,"~:column",8,"~:end-line",629,"~:end-column",13,"~:private",true,"~:arglists",["~#list",["~$quote",["^R",[["~$var"]]]]]],"^P",true,"^>","~$cats.core/arity","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",13,"~:method-params",["^R",[["^T"]]],"~:protocol-impl",null,"~:arglists-meta",["^R",[null,null]],"^M",1,"~:variadic?",false,"^L",629,"~:ret-tag","~$number","^N",629,"~:max-fixed-arity",1,"~:fn-var",true,"^Q",["^R",["^S",["^R",[["^T"]]]]]],"~$pure",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",54,"^M",7,"^N",54,"^O",11,"^Q",["^R",["^S",["^R",[["~$v"],["^C","~$v"]]]]],"~:doc","Given any value `v`, return it wrapped in\n  the default/effect-free context.\n\n  This is a multi-arity function that with arity `pure/1`\n  uses the dynamic scope to resolve the current\n  context. With `pure/2`, you can force a specific context\n  value.\n\n  Example:\n\n      (with-context either/context\n        (pure 1))\n      ;; => #<Right [1]>\n\n      (pure either/context 1)\n      ;; => #<Right [1]>\n  ","~:top-fn",["^ ","^Y",false,"~:fixed-arity",2,"^10",2,"^V",["^R",[["~$v"],["^C","~$v"]]],"^Q",["^R",[["~$v"],["^C","~$v"]]],"^X",["^R",[null,null]]]],"^>","~$cats.core/pure","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",11,"^14",["^ ","^Y",false,"^15",2,"^10",2,"^V",["^R",[["~$v"],["^C","~$v"]]],"^Q",["^R",[["~$v"],["^C","~$v"]]],"^X",["^R",[null,null]]],"^V",["^R",[["~$v"],["^C","~$v"]]],"^W",null,"^15",2,"^X",["^R",[null,null]],"^M",1,"^Y",false,"~:methods",[["^ ","^15",1,"^Y",false,"~:tag","~$any"],["^ ","^15",2,"^Y",false,"^18","^19"]],"^L",54,"^N",54,"^10",2,"^11",true,"^Q",["^R",[["~$v"],["^C","~$v"]]],"^13","Given any value `v`, return it wrapped in\n  the default/effect-free context.\n\n  This is a multi-arity function that with arity `pure/1`\n  uses the dynamic scope to resolve the current\n  context. With `pure/2`, you can force a specific context\n  value.\n\n  Example:\n\n      (with-context either/context\n        (pure 1))\n      ;; => #<Right [1]>\n\n      (pure either/context 1)\n      ;; => #<Right [1]>\n  "],"~$arglists",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",619,"^M",8,"^N",619,"^O",16,"^P",true,"^Q",["^R",["^S",["^R",[["^T"]]]]]],"^P",true,"^>","~$cats.core/arglists","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",16,"^V",["^R",[["^T"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",619,"^Z",["^9",["^19","~$clj-nil"]],"^N",619,"^10",1,"^11",true,"^Q",["^R",["^S",["^R",[["^T"]]]]]],"~$foldl",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",939,"^M",7,"^N",939,"^O",12,"^Q",["^R",["^S",["^R",[["~$f","~$z","~$xs"]]]]],"^13","Perform a left-associative fold on the data structure."],"^>","~$cats.core/foldl","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",12,"^V",["^R",[["~$f","~$z","^1>"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",939,"^N",939,"^10",3,"^11",true,"^Q",["^R",["^S",["^R",[["~$f","~$z","^1>"]]]]],"^13","Perform a left-associative fold on the data structure."],"~$as-ap->",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^O",18,"^14",["^ ","^Y",true,"^15",2,"^10",2,"^V",["^R",[["^R",["~$expr","~$name","~$forms"]]]],"^Q",["^R",[["^1A","^1B","~$&","^1C"]]],"^X",["^R",[null]]],"^M",11,"^L",540,"~:macro",true,"^N",540,"^Q",["^R",["^S",["^R",[["^1A","^1B","~$&","^1C"]]]]],"^13","Thread like `as->`, within an applicative idiom.\n   See `cats.labs.sugar/ap->` for more in-depth discussion."],"^>","~$cats.core/as-ap->","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",18,"^14",["^ ","^Y",true,"^15",2,"^10",2,"^V",["^R",[["^R",["^1A","^1B","^1C"]]]],"^Q",["^R",[["^1A","^1B","~$&","^1C"]]],"^X",["^R",[null]]],"^V",["^R",[["^R",["^1A","^1B","^1C"]]]],"^W",null,"^15",2,"^X",["^R",[null]],"^M",1,"^Y",true,"^17",[["^ ","^15",2,"^Y",true,"^18",["^9",["~$seq","~$cljs.core/IList"]]]],"^L",540,"^1D",true,"^Z","^19","^N",540,"^10",2,"^11",false,"^Q",["^R",[["^1A","^1B","~$&","^1C"]]],"^13","Thread like `as->`, within an applicative idiom.\n   See `cats.labs.sugar/ap->` for more in-depth discussion."],"~$fapply",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",186,"^M",7,"^N",186,"^O",13,"^Q",["^R",["^S",["^R",[["~$af","~$&","~$avs"]]]]],"^13","Given a function wrapped in a monadic context `af`,\n  and a value wrapped in a monadic context `av`,\n  apply the unwrapped function to the unwrapped value\n  and return the result, wrapped in the same context as `av`.\n\n  This function is variadic, so it can be used like\n  a Haskell-style left-associative fapply.","^14",["^ ","^Y",true,"^15",1,"^10",1,"^V",[["^R",["^1I","^1J"]]],"^Q",["^R",[["^1I","~$&","^1J"]]],"^X",["^R",[null]]]],"^>","~$cats.core/fapply","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",13,"^14",["^ ","^Y",true,"^15",1,"^10",1,"^V",[["^R",["^1I","^1J"]]],"^Q",["^R",[["^1I","~$&","^1J"]]],"^X",["^R",[null]]],"^V",[["^R",["^1I","^1J"]]],"^W",null,"^15",1,"^X",["^R",[null]],"^M",1,"^Y",true,"^17",[["^ ","^15",1,"^Y",true,"^18",["^9",[null,"^19"]]]],"^L",186,"^Z","^19","^N",186,"^10",1,"^11",true,"^Q",["^R",[["^1I","~$&","^1J"]]],"^13","Given a function wrapped in a monadic context `af`,\n  and a value wrapped in a monadic context `av`,\n  apply the unwrapped function to the unwrapped value\n  and return the result, wrapped in the same context as `av`.\n\n  This function is variadic, so it can be used like\n  a Haskell-style left-associative fapply."],"~$<*>",["^ ","^>","~$cats.core/<*>","^K","resources/public/cljs-out/dev/cats/core.cljc","^L",876,"^M",1,"^N",876,"^O",9,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",876,"^M",6,"^N",876,"^O",9],"^13","A Haskell-style `fapply` alias."],"~$guard",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",110,"^M",7,"^N",110,"^O",12,"^Q",["^R",["^S",["^R",[["~$b"]]]]]],"^>","~$cats.core/guard","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",12,"^V",["^R",[["~$b"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",110,"^Z","^19","^N",110,"^10",1,"^11",true,"^Q",["^R",["^S",["^R",[["~$b"]]]]]],"~$->=",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^O",14,"^14",["^ ","^Y",true,"^15",1,"^10",1,"^V",["^R",[["^R",["^1A","^1C"]]]],"^Q",["^R",[["^1A","~$&","^1C"]]],"^X",["^R",[null]]],"^M",11,"^L",552,"^1D",true,"^N",552,"^Q",["^R",["^S",["^R",[["^1A","~$&","^1C"]]]]],"^13","Like `->`, but with monadic binding instead of pure application.\n   A mnemonic for the name is a pun on `>>=`, the monadic bind operator,\n   and clojure's regular arrow macros.\n\n   You can think of it as generalizing the `some->` thread macro\n   to all Monads instead of just Maybe.\n\n   Alternatively, if you think of the regular thread macro as\n   sugar for `let`:\n\n   (-> :a b (c (other args)) d)\n   =>\n   (let [res (b :a)\n         res (c res (other args))\n         res (d res)]\n     res)\n\n   Then `->=` is sugar for cats.core/mlet:\n\n   (->= m-a b (c (other args)) d)\n   (mlet [res m-a\n          res (c res (other args))\n          res (d res)]\n     (return res))\n\n   Note that extra args in this context are assumed pure, and will\n   be evaluated along with the function itself; this also matches\n   the behavior of `some->` wrt extra args.\n\n   Threading through pure functions is somewhat awkward, but can be done:\n\n   (->= m-a\n        monadic-fn\n        (-> pure-fn\n            other-pure-fn\n            m/return)\n        other-monadic-fn)"],"^>","~$cats.core/->=","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",14,"^14",["^ ","^Y",true,"^15",1,"^10",1,"^V",["^R",[["^R",["^1A","^1C"]]]],"^Q",["^R",[["^1A","~$&","^1C"]]],"^X",["^R",[null]]],"^V",["^R",[["^R",["^1A","^1C"]]]],"^W",null,"^15",1,"^X",["^R",[null]],"^M",1,"^Y",true,"^17",[["^ ","^15",1,"^Y",true,"^18",["^9",["^1F","^1G"]]]],"^L",552,"^1D",true,"^Z","^19","^N",552,"^10",1,"^11",false,"^Q",["^R",[["^1A","~$&","^1C"]]],"^13","Like `->`, but with monadic binding instead of pure application.\n   A mnemonic for the name is a pun on `>>=`, the monadic bind operator,\n   and clojure's regular arrow macros.\n\n   You can think of it as generalizing the `some->` thread macro\n   to all Monads instead of just Maybe.\n\n   Alternatively, if you think of the regular thread macro as\n   sugar for `let`:\n\n   (-> :a b (c (other args)) d)\n   =>\n   (let [res (b :a)\n         res (c res (other args))\n         res (d res)]\n     res)\n\n   Then `->=` is sugar for cats.core/mlet:\n\n   (->= m-a b (c (other args)) d)\n   (mlet [res m-a\n          res (c res (other args))\n          res (d res)]\n     (return res))\n\n   Note that extra args in this context are assumed pure, and will\n   be evaluated along with the function itself; this also matches\n   the behavior of `some->` wrt extra args.\n\n   Threading through pure functions is somewhat awkward, but can be done:\n\n   (->= m-a\n        monadic-fn\n        (-> pure-fn\n            other-pure-fn\n            m/return)\n        other-monadic-fn)"],"~$join",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",116,"^M",7,"^N",116,"^O",11,"^Q",["^R",["^S",["^R",[["~$mv"]]]]],"^13","Remove one level of monadic structure.\n  This is the same as `(bind mv identity)`."],"^>","~$cats.core/join","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",11,"^V",["^R",[["^1S"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",116,"^Z","^19","^N",116,"^10",1,"^11",true,"^Q",["^R",["^S",["^R",[["^1S"]]]]],"^13","Remove one level of monadic structure.\n  This is the same as `(bind mv identity)`."],"~$bimap",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",133,"^M",7,"^N",133,"^O",12,"^Q",["^R",["^S",["^R",[["~$f","~$g"],["~$f","~$g","~$bv"]]]]],"^13","Map over both arguments at the same time.\n\n  Given functions `f` and `g` and a value wrapped in a bifunctor `bv`,\n  apply `f` to a first argument or `g` to a second argument.\n\n      (bimap dec inc (either/right 1)\n      ;; => #<Right 2>\n\n      (bimap dec inc (either/left 1)\n      ;; => #<Left 0>","^14",["^ ","^Y",false,"^15",3,"^10",3,"^V",["^R",[["~$f","~$g"],["~$f","~$g","^1V"]]],"^Q",["^R",[["~$f","~$g"],["~$f","~$g","^1V"]]],"^X",["^R",[null,null]]]],"^>","~$cats.core/bimap","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",12,"^14",["^ ","^Y",false,"^15",3,"^10",3,"^V",["^R",[["~$f","~$g"],["~$f","~$g","^1V"]]],"^Q",["^R",[["~$f","~$g"],["~$f","~$g","^1V"]]],"^X",["^R",[null,null]]],"^V",["^R",[["~$f","~$g"],["~$f","~$g","^1V"]]],"^W",null,"^15",3,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^17",[["^ ","^15",2,"^Y",false,"^18","~$function"],["^ ","^15",3,"^Y",false]],"^L",133,"^N",133,"^10",3,"^11",true,"^Q",["^R",[["~$f","~$g"],["~$f","~$g","^1V"]]],"^13","Map over both arguments at the same time.\n\n  Given functions `f` and `g` and a value wrapped in a bifunctor `bv`,\n  apply `f` to a first argument or `g` to a second argument.\n\n      (bimap dec inc (either/right 1)\n      ;; => #<Right 2>\n\n      (bimap dec inc (either/left 1)\n      ;; => #<Left 0>"],"~$bind",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",81,"^M",7,"^N",81,"^O",11,"^Q",["^R",["^S",["^R",[["^1S","~$f"]]]]],"^13","Given a monadic value `mv` and a function `f`,\n  apply `f` to the unwrapped value of `mv`.\n\n      (bind (either/right 1) (fn [v]\n                               (return (inc v))))\n      ;; => #<Right [2]>\n\n  For convenience, you may prefer to use the `mlet` macro,\n  which provides a beautiful, `let`-like syntax for\n  composing operations with the `bind` function."],"^>","~$cats.core/bind","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",11,"^V",["^R",[["^1S","~$f"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",81,"^Z","^19","^N",81,"^10",2,"^11",true,"^Q",["^R",["^S",["^R",[["^1S","~$f"]]]]],"^13","Given a monadic value `mv` and a function `f`,\n  apply `f` to the unwrapped value of `mv`.\n\n      (bind (either/right 1) (fn [v]\n                               (return (inc v))))\n      ;; => #<Right [2]>\n\n  For convenience, you may prefer to use the `mlet` macro,\n  which provides a beautiful, `let`-like syntax for\n  composing operations with the `bind` function."],"~$deps",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",265,"^M",8,"^N",265,"^O",12,"^P",true,"^Q",["^R",["^S",["^R",[["^1A","~$syms"]]]]]],"^P",true,"^>","~$cats.core/deps","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",12,"^V",["^R",[["^1A","^20"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",265,"^Z",["^9",["^1G","^19","~$cljs.core/List"]],"^N",265,"^10",2,"^11",true,"^Q",["^R",["^S",["^R",[["^1A","^20"]]]]]],"~$topo-sort*",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",347,"^M",8,"^N",347,"^O",18,"^P",true,"^Q",["^R",["^S",["^R",[["^1[","~$seen","~$batches","~$current"]]]]]],"^P",true,"^>","~$cats.core/topo-sort*","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",18,"^V",["^R",[["^1[","^24","^25","^26"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",347,"^Z","~$clj","^N",347,"^10",4,"^11",true,"^Q",["^R",["^S",["^R",[["^1[","^24","^25","^26"]]]]]],"~$<$>",["^ ","^>","~$cats.core/<$>","^K","resources/public/cljs-out/dev/cats/core.cljc","^L",872,"^M",1,"^N",872,"^O",9,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",872,"^M",6,"^N",872,"^O",9],"^13","A Haskell-style `fmap` alias."],"~$<=<",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",915,"^M",7,"^N",915,"^O",10,"^Q",["^R",["^S",["^R",[["~$mg","~$mf","~$x"]]]]],"^13","Right-to-left composition of monads.\n  Same as `>=>` with its first two arguments flipped."],"^>","~$cats.core/<=<","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",10,"^V",["^R",[["^2<","^2=","~$x"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",915,"^N",915,"^10",3,"^11",true,"^Q",["^R",["^S",["^R",[["^2<","^2=","~$x"]]]]],"^13","Right-to-left composition of monads.\n  Same as `>=>` with its first two arguments flipped."],"~$alet*",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",377,"^M",8,"^N",377,"^O",13,"^P",true,"^Q",["^R",["^S",["^R",[["^25","~$env","~$body"]]]]]],"^P",true,"^>","~$cats.core/alet*","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",13,"^V",["^R",[["^25","^2@","^2A"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",377,"^Z",["^9",[null,"^19"]],"^N",377,"^10",3,"^11",true,"^Q",["^R",["^S",["^R",[["^25","^2@","^2A"]]]]]],"~$single-arity?",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",623,"^M",8,"^N",623,"^O",21,"^P",true,"^Q",["^R",["^S",["^R",[["^T"]]]]]],"^P",true,"^>","~$cats.core/single-arity?","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",21,"^V",["^R",[["^T"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",623,"^Z","~$boolean","^N",623,"^10",1,"^11",true,"^Q",["^R",["^S",["^R",[["^T"]]]]]],"^:",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",199,"^M",7,"^N",199,"^O",11,"^Q",["^R",["^S",["^R",[["~$b","^1S"],["^C","~$b","^1S"]]]]],"^13","Given an expression and a monadic value,\n  if the expression is logical true, return the monadic value.\n  Otherwise, return nil in a monadic context.","^14",["^ ","^Y",false,"^15",3,"^10",3,"^V",["^R",[["~$b","^1S"],["^C","~$b","^1S"]]],"^Q",["^R",[["~$b","^1S"],["^C","~$b","^1S"]]],"^X",["^R",[null,null]]]],"^>","~$cats.core/when","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",11,"^14",["^ ","^Y",false,"^15",3,"^10",3,"^V",["^R",[["~$b","^1S"],["^C","~$b","^1S"]]],"^Q",["^R",[["~$b","^1S"],["^C","~$b","^1S"]]],"^X",["^R",[null,null]]],"^V",["^R",[["~$b","^1S"],["^C","~$b","^1S"]]],"^W",null,"^15",3,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^17",[["^ ","^15",2,"^Y",false,"^18","^19"],["^ ","^15",3,"^Y",false,"^18",["^9",[null,"^19"]]]],"^L",199,"^N",199,"^10",3,"^11",true,"^Q",["^R",[["~$b","^1S"],["^C","~$b","^1S"]]],"^13","Given an expression and a monadic value,\n  if the expression is logical true, return the monadic value.\n  Otherwise, return nil in a monadic context."],"~$>>=",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",880,"^M",7,"^N",880,"^O",10,"^Q",["^R",["^S",["^R",[["^1S","~$f"],["^1S","~$f","~$&","~$fs"]]]]],"^13","Perform a Haskell-style left-associative bind.\n\n  Let's see it in action:\n\n      (>>= (just 1) (comp just inc) (comp just inc))\n      ;; => #<Just [3]>\n  ","^14",["^ ","^Y",true,"^15",2,"^10",2,"^V",["^R",[["^1S","~$f"]]],"^Q",["^R",[["^1S","~$f"],["^1S","~$f","~$&","^2H"]]],"^X",["^R",[null,null]]]],"^>","~$cats.core/>>=","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",10,"^14",["^ ","^Y",true,"^15",2,"^10",2,"^V",["^R",[["^1S","~$f"]]],"^Q",["^R",[["^1S","~$f"],["^1S","~$f","~$&","^2H"]]],"^X",["^R",[null,null]]],"^V",["^R",[["^1S","~$f"]]],"^W",null,"^15",2,"^X",["^R",[null,null]],"^M",1,"^Y",true,"^17",[["^ ","^15",2,"^Y",false,"^18","^19"],["^ ","^15",2,"^Y",true,"^18",["^9",[null,"^19"]]]],"^L",880,"^N",880,"^10",2,"^11",true,"^Q",["^R",[["^1S","~$f"],["^1S","~$f","~$&","^2H"]]],"^13","Perform a Haskell-style left-associative bind.\n\n  Let's see it in action:\n\n      (>>= (just 1) (comp just inc) (comp just inc))\n      ;; => #<Just [3]>\n  "],"~$ap->",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^O",15,"^14",["^ ","^Y",true,"^15",1,"^10",1,"^V",["^R",[["^R",["~$x","^1C"]]]],"^Q",["^R",[["~$x","~$&","^1C"]]],"^X",["^R",[null]]],"^M",11,"^L",504,"^1D",true,"^N",504,"^Q",["^R",["^S",["^R",[["~$x","~$&","^1C"]]]]],"^13","Thread like `->`, within an applicative idiom.\n\n  Compare:\n\n  (macroexpand-1 `(-> a b c (d e f)))\n  => (d (c (b a) e f)\n\n  with:\n\n  (macroexpand-1 `(ap-> a b c (d e f))\n  => (ap d (ap c (ap b a) e f))\n  "],"^>","~$cats.core/ap->","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",15,"^14",["^ ","^Y",true,"^15",1,"^10",1,"^V",["^R",[["^R",["~$x","^1C"]]]],"^Q",["^R",[["~$x","~$&","^1C"]]],"^X",["^R",[null]]],"^V",["^R",[["^R",["~$x","^1C"]]]],"^W",null,"^15",1,"^X",["^R",[null]],"^M",1,"^Y",true,"^17",[["^ ","^15",1,"^Y",true]],"^L",504,"^1D",true,"^Z","^19","^N",504,"^10",1,"^11",false,"^Q",["^R",[["~$x","~$&","^1C"]]],"^13","Thread like `->`, within an applicative idiom.\n\n  Compare:\n\n  (macroexpand-1 `(-> a b c (d e f)))\n  => (d (c (b a) e f)\n\n  with:\n\n  (macroexpand-1 `(ap-> a b c (d e f))\n  => (ap d (ap c (ap b a) e f))\n  "],"~$mzero",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",98,"^M",7,"^N",98,"^O",12,"^Q",["^R",["^S",["^R",[[],["^C"]]]]],"^14",["^ ","^Y",false,"^15",1,"^10",1,"^V",["^R",[[],["^C"]]],"^Q",["^R",[[],["^C"]]],"^X",["^R",[null,null]]]],"^>","~$cats.core/mzero","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",12,"^14",["^ ","^Y",false,"^15",1,"^10",1,"^V",["^R",[[],["^C"]]],"^Q",["^R",[[],["^C"]]],"^X",["^R",[null,null]]],"^V",["^R",[[],["^C"]]],"^W",null,"^15",1,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^17",[["^ ","^15",0,"^Y",false,"^18","^19"],["^ ","^15",1,"^Y",false,"^18","^19"]],"^L",98,"^N",98,"^10",1,"^11",true,"^Q",["^R",[[],["^C"]]]],"~$return",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",75,"^M",7,"^N",75,"^O",13,"^Q",["^R",["^S",["^R",[["~$v"],["^C","~$v"]]]]],"^13","This is a monad version of `pure` and works\n  identically to it.","^14",["^ ","^Y",false,"^15",2,"^10",2,"^V",["^R",[["~$v"],["^C","~$v"]]],"^Q",["^R",[["~$v"],["^C","~$v"]]],"^X",["^R",[null,null]]]],"^>","~$cats.core/return","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",13,"^14",["^ ","^Y",false,"^15",2,"^10",2,"^V",["^R",[["~$v"],["^C","~$v"]]],"^Q",["^R",[["~$v"],["^C","~$v"]]],"^X",["^R",[null,null]]],"^V",["^R",[["~$v"],["^C","~$v"]]],"^W",null,"^15",2,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^17",[["^ ","^15",1,"^Y",false,"^18","^19"],["^ ","^15",2,"^Y",false,"^18","^19"]],"^L",75,"^N",75,"^10",2,"^11",true,"^Q",["^R",[["~$v"],["^C","~$v"]]],"^13","This is a monad version of `pure` and works\n  identically to it."],"~$mappend",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",48,"^M",7,"^N",48,"^O",14,"^Q",["^R",["^S",["^R",[["~$&","~$svs"]]]]],"^14",["^ ","^Y",true,"^15",0,"^10",0,"^V",[["^R",["^2Q"]]],"^Q",["^R",[["~$&","^2Q"]]],"^X",["^R",[null]]]],"^>","~$cats.core/mappend","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",14,"^14",["^ ","^Y",true,"^15",0,"^10",0,"^V",[["^R",["^2Q"]]],"^Q",["^R",[["~$&","^2Q"]]],"^X",["^R",[null]]],"^V",[["^R",["^2Q"]]],"^W",null,"^15",0,"^X",["^R",[null]],"^M",1,"^Y",true,"^17",[["^ ","^15",0,"^Y",true,"^18",["^9",[null,"^19"]]]],"^L",48,"^Z","^19","^N",48,"^10",0,"^11",true,"^Q",["^R",[["~$&","^2Q"]]]],"~$mapseq",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",802,"^M",7,"^N",802,"^O",13,"^Q",["^R",["^S",["^R",[["^2=","~$coll"]]]]],"^13","Given a function `mf` that takes a value and puts it into a\n  monadic context, and a collection, map `mf` over the collection,\n  calling `sequence` on the results.\n\n      (require '[cats.context :as ctx]\n               '[cats.monad.maybe :as maybe]\n               '[cats.core :as m])\n\n      (m/mapseq maybe/just [2 3])\n      ;=> <Just [[2 3]]>\n\n      (m/mapseq (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing)))\n                [1 2])\n      ;; => #<Nothing>\n\n      (ctx/with-context maybe/context\n        (mapseq #(maybe/just (* % 2)) []))\n      ;; => #<Just [()]>\n  "],"^>","~$cats.core/mapseq","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",13,"^V",["^R",[["^2=","^2T"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",802,"^Z",["^9",[null,"^19"]],"^N",802,"^10",2,"^11",true,"^Q",["^R",["^S",["^R",[["^2=","^2T"]]]]],"^13","Given a function `mf` that takes a value and puts it into a\n  monadic context, and a collection, map `mf` over the collection,\n  calling `sequence` on the results.\n\n      (require '[cats.context :as ctx]\n               '[cats.monad.maybe :as maybe]\n               '[cats.core :as m])\n\n      (m/mapseq maybe/just [2 3])\n      ;=> <Just [[2 3]]>\n\n      (m/mapseq (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing)))\n                [1 2])\n      ;; => #<Nothing>\n\n      (ctx/with-context maybe/context\n        (mapseq #(maybe/just (* % 2)) []))\n      ;; => #<Just [()]>\n  "],"~$mplus",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",104,"^M",7,"^N",104,"^O",12,"^Q",["^R",["^S",["^R",[["~$&","~$mvs"]]]]],"^14",["^ ","^Y",true,"^15",0,"^10",0,"^V",[["^R",["^2W"]]],"^Q",["^R",[["~$&","^2W"]]],"^X",["^R",[null]]]],"^>","~$cats.core/mplus","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",12,"^14",["^ ","^Y",true,"^15",0,"^10",0,"^V",[["^R",["^2W"]]],"^Q",["^R",[["~$&","^2W"]]],"^X",["^R",[null]]],"^V",[["^R",["^2W"]]],"^W",null,"^15",0,"^X",["^R",[null]],"^M",1,"^Y",true,"^17",[["^ ","^15",0,"^Y",true,"^18",["^9",[null,"^19"]]]],"^L",104,"^Z","^19","^N",104,"^10",0,"^11",true,"^Q",["^R",[["~$&","^2W"]]]],"~$dedupe-symbols",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",325,"^M",8,"^N",325,"^O",22,"^P",true,"^Q",["^R",["^S",["^R",[["~$bindings","^2A"]]]]]],"^P",true,"^>","~$cats.core/dedupe-symbols","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",22,"^V",["^R",[["^2Z","^2A"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",325,"^Z","^19","^N",325,"^10",2,"^11",true,"^Q",["^R",["^S",["^R",[["^2Z","^2A"]]]]]],"~$as->=",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^O",16,"^14",["^ ","^Y",true,"^15",2,"^10",2,"^V",["^R",[["^R",["^1A","^1B","^1C"]]]],"^Q",["^R",[["^1A","^1B","~$&","^1C"]]],"^X",["^R",[null]]],"^M",11,"^L",607,"^1D",true,"^N",607,"^Q",["^R",["^S",["^R",[["^1A","^1B","~$&","^1C"]]]]],"^13","Like `as->`, but with monadic binding instead of pure application.\n   See `cats.labs.sugar/->=` for more in-depth discussion."],"^>","~$cats.core/as->=","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",16,"^14",["^ ","^Y",true,"^15",2,"^10",2,"^V",["^R",[["^R",["^1A","^1B","^1C"]]]],"^Q",["^R",[["^1A","^1B","~$&","^1C"]]],"^X",["^R",[null]]],"^V",["^R",[["^R",["^1A","^1B","^1C"]]]],"^W",null,"^15",2,"^X",["^R",[null]],"^M",1,"^Y",true,"^17",[["^ ","^15",2,"^Y",true,"^18",["^9",["^1F","^1G"]]]],"^L",607,"^1D",true,"^Z","^19","^N",607,"^10",2,"^11",false,"^Q",["^R",[["^1A","^1B","~$&","^1C"]]],"^13","Like `as->`, but with monadic binding instead of pure application.\n   See `cats.labs.sugar/->=` for more in-depth discussion."],"~$>>",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",893,"^M",7,"^N",893,"^O",9,"^Q",["^R",["^S",["^R",[["^1S","~$mv'"],["^1S","^33","~$&","^2W"]]]]],"^13","Perform a Haskell-style left-associative bind,\n  ignoring the values produced by the monadic computations.","^14",["^ ","^Y",true,"^15",2,"^10",2,"^V",["^R",[["^1S","^33"]]],"^Q",["^R",[["^1S","^33"],["^1S","^33","~$&","^2W"]]],"^X",["^R",[null,null]]]],"^>","~$cats.core/>>","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",9,"^14",["^ ","^Y",true,"^15",2,"^10",2,"^V",["^R",[["^1S","^33"]]],"^Q",["^R",[["^1S","^33"],["^1S","^33","~$&","^2W"]]],"^X",["^R",[null,null]]],"^V",["^R",[["^1S","^33"]]],"^W",null,"^15",2,"^X",["^R",[null,null]],"^M",1,"^Y",true,"^17",[["^ ","^15",2,"^Y",false,"^18","^19"],["^ ","^15",2,"^Y",true,"^18",["^9",[null,"^19"]]]],"^L",893,"^N",893,"^10",2,"^11",true,"^Q",["^R",[["^1S","^33"],["^1S","^33","~$&","^2W"]]],"^13","Perform a Haskell-style left-associative bind,\n  ignoring the values produced by the monadic computations."],"~$rename",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",282,"^M",8,"^N",282,"^O",14,"^P",true,"^Q",["^R",["^S",["^R",[["^1A","~$renames"]]]]]],"^P",true,"^>","~$cats.core/rename","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",14,"^V",["^R",[["^1A","^36"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",282,"^Z",["^9",[null,"^19","~$cljs.core/LazySeq"]],"^N",282,"^10",2,"^11",true,"^Q",["^R",["^S",["^R",[["^1A","^36"]]]]]],"~$->>=",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^O",15,"^14",["^ ","^Y",true,"^15",1,"^10",1,"^V",["^R",[["^R",["^1A","^1C"]]]],"^Q",["^R",[["^1A","~$&","^1C"]]],"^X",["^R",[null]]],"^M",11,"^L",597,"^1D",true,"^N",597,"^Q",["^R",["^S",["^R",[["^1A","~$&","^1C"]]]]],"^13","Like ->>, but with monadic binding instead of pure application.\n   See `cats.labs.sugar/->=` for more in-depth discussion."],"^>","~$cats.core/->>=","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",15,"^14",["^ ","^Y",true,"^15",1,"^10",1,"^V",["^R",[["^R",["^1A","^1C"]]]],"^Q",["^R",[["^1A","~$&","^1C"]]],"^X",["^R",[null]]],"^V",["^R",[["^R",["^1A","^1C"]]]],"^W",null,"^15",1,"^X",["^R",[null]],"^M",1,"^Y",true,"^17",[["^ ","^15",1,"^Y",true,"^18",["^9",["^1F","^1G"]]]],"^L",597,"^1D",true,"^Z","^19","^N",597,"^10",1,"^11",false,"^Q",["^R",[["^1A","~$&","^1C"]]],"^13","Like ->>, but with monadic binding instead of pure application.\n   See `cats.labs.sugar/->=` for more in-depth discussion."],"~$rename-sym",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",278,"^M",8,"^N",278,"^O",18,"^P",true,"^Q",["^R",["^S",["^R",[["^1A","^36"]]]]]],"^P",true,"^>","~$cats.core/rename-sym","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",18,"^V",["^R",[["^1A","^36"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",278,"^Z",["^9",[null,"^19"]],"^N",278,"^10",2,"^11",true,"^Q",["^R",["^S",["^R",[["^1A","^36"]]]]]],"^;",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",210,"^M",7,"^N",210,"^O",13,"^Q",["^R",["^S",["^R",[["~$b","^1S"],["^C","~$b","^1S"]]]]],"^13","Given an expression and a monadic value,\n  if the expression is not logical true, return the monadic value.\n  Otherwise, return nil in a monadic context.","^14",["^ ","^Y",false,"^15",3,"^10",3,"^V",["^R",[["~$b","^1S"],["^C","~$b","^1S"]]],"^Q",["^R",[["~$b","^1S"],["^C","~$b","^1S"]]],"^X",["^R",[null,null]]]],"^>","~$cats.core/unless","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",13,"^14",["^ ","^Y",false,"^15",3,"^10",3,"^V",["^R",[["~$b","^1S"],["^C","~$b","^1S"]]],"^Q",["^R",[["~$b","^1S"],["^C","~$b","^1S"]]],"^X",["^R",[null,null]]],"^V",["^R",[["~$b","^1S"],["^C","~$b","^1S"]]],"^W",null,"^15",3,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^17",[["^ ","^15",2,"^Y",false,"^18","^19"],["^ ","^15",3,"^Y",false,"^18",["^9",[null,"^19"]]]],"^L",210,"^N",210,"^10",3,"^11",true,"^Q",["^R",[["~$b","^1S"],["^C","~$b","^1S"]]],"^13","Given an expression and a monadic value,\n  if the expression is not logical true, return the monadic value.\n  Otherwise, return nil in a monadic context."],"~$ap->>",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^O",16,"^14",["^ ","^Y",true,"^15",1,"^10",1,"^V",["^R",[["^R",["~$x","^1C"]]]],"^Q",["^R",[["~$x","~$&","^1C"]]],"^X",["^R",[null]]],"^M",11,"^L",527,"^1D",true,"^N",527,"^Q",["^R",["^S",["^R",[["~$x","~$&","^1C"]]]]],"^13","Thread like `->>`, within an applicative idiom.\n   See `cats.labs.sugar/ap->` for more in-depth discussion."],"^>","~$cats.core/ap->>","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",16,"^14",["^ ","^Y",true,"^15",1,"^10",1,"^V",["^R",[["^R",["~$x","^1C"]]]],"^Q",["^R",[["~$x","~$&","^1C"]]],"^X",["^R",[null]]],"^V",["^R",[["^R",["~$x","^1C"]]]],"^W",null,"^15",1,"^X",["^R",[null]],"^M",1,"^Y",true,"^17",[["^ ","^15",1,"^Y",true]],"^L",527,"^1D",true,"^Z","^19","^N",527,"^10",1,"^11",false,"^Q",["^R",[["~$x","~$&","^1C"]]],"^13","Thread like `->>`, within an applicative idiom.\n   See `cats.labs.sugar/ap->` for more in-depth discussion."],"~$traverse",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",988,"^M",7,"^N",988,"^O",15,"^Q",["^R",["^S",["^R",[["~$f","~$tv"],["^C","~$f","^3A"]]]]],"^13","Map each element of a structure to an action, evaluate these\n  actions from left to right, and collect the results.\n\n      (defn inc-if-even\n        [n]\n        (if (even? n)\n          (maybe/just (inc n))\n          (maybe/nothing)))\n\n      (ctx/with-context maybe/context\n        (m/traverse inc-if-even [2 4]))\n      ;; => #<Just [3 4]>\n  ","^14",["^ ","^Y",false,"^15",3,"^10",3,"^V",["^R",[["~$f","^3A"],["^C","~$f","^3A"]]],"^Q",["^R",[["~$f","^3A"],["^C","~$f","^3A"]]],"^X",["^R",[null,null]]]],"^>","~$cats.core/traverse","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",15,"^14",["^ ","^Y",false,"^15",3,"^10",3,"^V",["^R",[["~$f","^3A"],["^C","~$f","^3A"]]],"^Q",["^R",[["~$f","^3A"],["^C","~$f","^3A"]]],"^X",["^R",[null,null]]],"^V",["^R",[["~$f","^3A"],["^C","~$f","^3A"]]],"^W",null,"^15",3,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^17",[["^ ","^15",2,"^Y",false,"^18","^19"],["^ ","^15",3,"^Y",false]],"^L",988,"^N",988,"^10",3,"^11",true,"^Q",["^R",[["~$f","^3A"],["^C","~$f","^3A"]]],"^13","Map each element of a structure to an action, evaluate these\n  actions from left to right, and collect the results.\n\n      (defn inc-if-even\n        [n]\n        (if (even? n)\n          (maybe/just (inc n))\n          (maybe/nothing)))\n\n      (ctx/with-context maybe/context\n        (m/traverse inc-if-even [2 4]))\n      ;; => #<Just [3 4]>\n  "],"~$forseq",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",828,"^M",7,"^N",828,"^O",13,"^Q",["^R",["^S",["^R",[["~$vs","^2="]]]]],"^13","Same as `mapseq` but with the arguments flipped.\n\n  Let's see a little example:\n\n      (m/forseq [2 3] maybe/just)\n      ;; => <Just [[2 3]]>\n\n  Yet an other example that fails:\n\n      (m/forseq [1 2]\n                (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing))))\n      ;; => <Nothing>\n  "],"^>","~$cats.core/forseq","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",13,"^V",["^R",[["^3D","^2="]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",828,"^Z",["^9",[null,"^19"]],"^N",828,"^10",2,"^11",true,"^Q",["^R",["^S",["^R",[["^3D","^2="]]]]],"^13","Same as `mapseq` but with the arguments flipped.\n\n  Let's see a little example:\n\n      (m/forseq [2 3] maybe/just)\n      ;; => <Just [[2 3]]>\n\n  Yet an other example that fails:\n\n      (m/forseq [1 2]\n                (fn [v]\n                  (if (odd? v)\n                    (maybe/just v)\n                    (maybe/nothing))))\n      ;; => <Nothing>\n  "],"~$=<<",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",901,"^M",7,"^N",901,"^O",10,"^Q",["^R",["^S",["^R",[["~$f","^1S"]]]]],"^13","Same as the two argument version of `>>=` but with the\n  arguments flipped."],"^>","~$cats.core/=<<","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",10,"^V",["^R",[["~$f","^1S"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",901,"^Z","^19","^N",901,"^10",2,"^11",true,"^Q",["^R",["^S",["^R",[["~$f","^1S"]]]]],"^13","Same as the two argument version of `>>=` but with the\n  arguments flipped."],"~$foldr",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",932,"^M",7,"^N",932,"^O",12,"^Q",["^R",["^S",["^R",[["~$f","~$z","^1>"]]]]],"^13","Perform a right-associative fold on the data structure."],"^>","~$cats.core/foldr","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",12,"^V",["^R",[["~$f","~$z","^1>"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",932,"^N",932,"^10",3,"^11",true,"^Q",["^R",["^S",["^R",[["~$f","~$z","^1>"]]]]],"^13","Perform a right-associative fold on the data structure."],"~$>=>",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",907,"^M",7,"^N",907,"^O",10,"^Q",["^R",["^S",["^R",[["^2=","^2<","~$x"]]]]],"^13","Left-to-right composition of monads."],"^>","~$cats.core/>=>","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",10,"^V",["^R",[["^2=","^2<","~$x"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",907,"^N",907,"^10",3,"^11",true,"^Q",["^R",["^S",["^R",[["^2=","^2<","~$x"]]]]],"^13","Left-to-right composition of monads."],"~$dependency-map",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",332,"^M",8,"^N",332,"^O",22,"^P",true,"^Q",["^R",["^S",["^R",[["~$sym->ap"]]]]]],"^P",true,"^>","~$cats.core/dependency-map","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",22,"^V",["^R",[["^3M"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",332,"^Z",["^9",[null,"^28","^19"]],"^N",332,"^10",1,"^11",true,"^Q",["^R",["^S",["^R",[["^3M"]]]]]],"~$<>",["^ ","^>","~$cats.core/<>","^K","resources/public/cljs-out/dev/cats/core.cljc","^L",930,"^M",1,"^N",930,"^O",8,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",930,"^M",6,"^N",930,"^O",8]],"~$right-map",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",169,"^M",7,"^N",169,"^O",16,"^Q",["^R",["^S",["^R",[["~$g"],["~$g","^1V"]]]]],"^13","Map covariantly over the second argument.\n\n  Given a function `g` and a value wrapped in a bifunctor `bv`,\n  apply `g` to the second argument, if present, otherwise leave `bv` unchanged.\n\n      (right-map inc (either/right 1)\n      ;; => #<Right 2>\n\n      (right-map inc (either/left 1)\n      ;; => #<Left 1>","^14",["^ ","^Y",false,"^15",2,"^10",2,"^V",["^R",[["~$g"],["~$g","^1V"]]],"^Q",["^R",[["~$g"],["~$g","^1V"]]],"^X",["^R",[null,null]]]],"^>","~$cats.core/right-map","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",16,"^14",["^ ","^Y",false,"^15",2,"^10",2,"^V",["^R",[["~$g"],["~$g","^1V"]]],"^Q",["^R",[["~$g"],["~$g","^1V"]]],"^X",["^R",[null,null]]],"^V",["^R",[["~$g"],["~$g","^1V"]]],"^W",null,"^15",2,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^17",[["^ ","^15",1,"^Y",false,"^18","^1X"],["^ ","^15",2,"^Y",false,"^18","^19"]],"^L",169,"^N",169,"^10",2,"^11",true,"^Q",["^R",[["~$g"],["~$g","^1V"]]],"^13","Map covariantly over the second argument.\n\n  Given a function `g` and a value wrapped in a bifunctor `bv`,\n  apply `g` to the second argument, if present, otherwise leave `bv` unchanged.\n\n      (right-map inc (either/right 1)\n      ;; => #<Right 2>\n\n      (right-map inc (either/left 1)\n      ;; => #<Left 1>"],"~$topo-sort",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",364,"^M",8,"^N",364,"^O",17,"^P",true,"^Q",["^R",["^S",["^R",[["^1["]]]]]],"^P",true,"^>","~$cats.core/topo-sort","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",17,"^V",["^R",[["^1["]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",364,"^Z","^28","^N",364,"^10",1,"^11",true,"^Q",["^R",["^S",["^R",[["^1["]]]]]],"^<",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",848,"^M",7,"^N",848,"^O",13,"^Q",["^R",["^S",["^R",[["~$p","^1S"]]]]],"^13","Apply a predicate to a value in a `MonadZero` instance,\n  returning the identity element when the predicate does not hold.\n\n  Otherwise, return the instance unchanged.\n\n      (require '[cats.monad.maybe :as maybe])\n      (require '[cats.core :as m])\n\n      (m/filter (partial < 2) (maybe/just 3))\n      ;=> <Just [3]>\n\n      (m/filter (partial < 4) (maybe/just 3))\n      ;=> <Nothing>\n  "],"^>","~$cats.core/filter","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",13,"^V",["^R",[["~$p","^1S"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",848,"^Z","^19","^N",848,"^10",2,"^11",true,"^Q",["^R",["^S",["^R",[["~$p","^1S"]]]]],"^13","Apply a predicate to a value in a `MonadZero` instance,\n  returning the identity element when the predicate does not hold.\n\n  Otherwise, return the instance unchanged.\n\n      (require '[cats.monad.maybe :as maybe])\n      (require '[cats.core :as m])\n\n      (m/filter (partial < 2) (maybe/just 3))\n      ;=> <Just [3]>\n\n      (m/filter (partial < 4) (maybe/just 3))\n      ;=> <Nothing>\n  "],"~$left-map",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",152,"^M",7,"^N",152,"^O",15,"^Q",["^R",["^S",["^R",[["~$f"],["~$f","^1V"]]]]],"^13","Map covariantly over the first argument.\n\n  Given a function `f` and a value wrapped in a bifunctor `bv`,\n  apply `f` to the first argument, if present, otherwise leave `bv` unchanged.\n\n      (left-map dec (either/right 1)\n      ;; => #<Right 1>\n\n      (left-map dec (either/left 1)\n      ;; => #<Left 0>","^14",["^ ","^Y",false,"^15",2,"^10",2,"^V",["^R",[["~$f"],["~$f","^1V"]]],"^Q",["^R",[["~$f"],["~$f","^1V"]]],"^X",["^R",[null,null]]]],"^>","~$cats.core/left-map","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",15,"^14",["^ ","^Y",false,"^15",2,"^10",2,"^V",["^R",[["~$f"],["~$f","^1V"]]],"^Q",["^R",[["~$f"],["~$f","^1V"]]],"^X",["^R",[null,null]]],"^V",["^R",[["~$f"],["~$f","^1V"]]],"^W",null,"^15",2,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^17",[["^ ","^15",1,"^Y",false,"^18","^1X"],["^ ","^15",2,"^Y",false,"^18","^19"]],"^L",152,"^N",152,"^10",2,"^11",true,"^Q",["^R",[["~$f"],["~$f","^1V"]]],"^13","Map covariantly over the first argument.\n\n  Given a function `f` and a value wrapped in a bifunctor `bv`,\n  apply `f` to the first argument, if present, otherwise leave `bv` unchanged.\n\n      (left-map dec (either/right 1)\n      ;; => #<Right 1>\n\n      (left-map dec (either/left 1)\n      ;; => #<Left 0>"],"~$dedupe-symbols*",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",292,"^M",8,"^N",292,"^O",23,"^P",true,"^Q",["^R",["^S",["^R",[["^3M","^2A"]]]]]],"^P",true,"^>","~$cats.core/dedupe-symbols*","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",23,"^V",["^R",[["^3M","^2A"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",292,"^N",292,"^10",2,"^11",true,"^Q",["^R",["^S",["^R",[["^3M","^2A"]]]]]],"~$fmap",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",122,"^M",7,"^N",122,"^O",11,"^Q",["^R",["^S",["^R",[["~$f"],["~$f","~$fv"]]]]],"^13","Apply a function `f` to the value wrapped in functor `fv`,\n  preserving the context type.","^14",["^ ","^Y",false,"^15",2,"^10",2,"^V",["^R",[["~$f"],["~$f","^3["]]],"^Q",["^R",[["~$f"],["~$f","^3["]]],"^X",["^R",[null,null]]]],"^>","~$cats.core/fmap","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",11,"^14",["^ ","^Y",false,"^15",2,"^10",2,"^V",["^R",[["~$f"],["~$f","^3["]]],"^Q",["^R",[["~$f"],["~$f","^3["]]],"^X",["^R",[null,null]]],"^V",["^R",[["~$f"],["~$f","^3["]]],"^W",null,"^15",2,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^17",[["^ ","^15",1,"^Y",false,"^18","^1X"],["^ ","^15",2,"^Y",false]],"^L",122,"^N",122,"^10",2,"^11",true,"^Q",["^R",[["~$f"],["~$f","^3["]]],"^13","Apply a function `f` to the value wrapped in functor `fv`,\n  preserving the context type."],"~$mempty",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",44,"^M",7,"^N",44,"^O",13,"^Q",["^R",["^S",["^R",[[],["^C"]]]]],"^14",["^ ","^Y",false,"^15",1,"^10",1,"^V",["^R",[[],["^C"]]],"^Q",["^R",[[],["^C"]]],"^X",["^R",[null,null]]]],"^>","~$cats.core/mempty","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",13,"^14",["^ ","^Y",false,"^15",1,"^10",1,"^V",["^R",[[],["^C"]]],"^Q",["^R",[[],["^C"]]],"^X",["^R",[null,null]]],"^V",["^R",[[],["^C"]]],"^W",null,"^15",1,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^17",[["^ ","^15",0,"^Y",false,"^18","^19"],["^ ","^15",1,"^Y",false,"^18","^19"]],"^L",44,"^N",44,"^10",1,"^11",true,"^Q",["^R",[[],["^C"]]]],"~$remove-deps",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",341,"^M",8,"^N",341,"^O",19,"^P",true,"^Q",["^R",["^S",["^R",[["^1[","~$symset"]]]]]],"^P",true,"^>","~$cats.core/remove-deps","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",19,"^V",["^R",[["^1[","^44"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",341,"^Z",["^9",[null,"^28","^19"]],"^N",341,"^10",2,"^11",true,"^Q",["^R",["^S",["^R",[["^1[","^44"]]]]]],"~$extract",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",924,"^M",7,"^N",924,"^O",14,"^Q",["^R",["^S",["^R",[["~$v"]]]]],"^13","Generic function to unwrap/extract\n  the inner value of a container."],"^>","~$cats.core/extract","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",14,"^V",["^R",[["~$v"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",924,"^Z","^19","^N",924,"^10",1,"^11",true,"^Q",["^R",["^S",["^R",[["~$v"]]]]],"^13","Generic function to unwrap/extract\n  the inner value of a container."],"^=",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",772,"^M",7,"^N",772,"^O",15,"^Q",["^R",["^S",["^R",[["^2W"]]]]],"^13","Given a collection of monadic values, collect\n  their values in a seq returned in the monadic context.\n\n      (require '[cats.context :as ctx]\n               '[cats.monad.maybe :as maybe]\n               '[cats.core :as m])\n\n      (m/sequence [(maybe/just 2) (maybe/just 3)])\n      ;; => #<Just [[2, 3]]>\n\n      (m/sequence [(maybe/nothing) (maybe/just 3)])\n      ;; => #<Nothing>\n\n      (ctx/with-context maybe/context\n        (m/sequence []))\n      ;; => #<Just [()]>\n  "],"^>","~$cats.core/sequence","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",15,"^V",["^R",[["^2W"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",772,"^Z",["^9",[null,"^19"]],"^N",772,"^10",1,"^11",true,"^Q",["^R",["^S",["^R",[["^2W"]]]]],"^13","Given a collection of monadic values, collect\n  their values in a seq returned in the monadic context.\n\n      (require '[cats.context :as ctx]\n               '[cats.monad.maybe :as maybe]\n               '[cats.core :as m])\n\n      (m/sequence [(maybe/just 2) (maybe/just 3)])\n      ;; => #<Just [[2, 3]]>\n\n      (m/sequence [(maybe/nothing) (maybe/just 3)])\n      ;; => #<Nothing>\n\n      (ctx/with-context maybe/context\n        (m/sequence []))\n      ;; => #<Just [()]>\n  "],"~$ap",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^O",13,"^14",["^ ","^Y",true,"^15",1,"^10",1,"^V",["^R",[["^R",["~$f","~$args"]]]],"^Q",["^R",[["~$f","~$&","^4:"]]],"^X",["^R",[null]]],"^M",11,"^L",471,"^1D",true,"^N",471,"^Q",["^R",["^S",["^R",[["~$f","~$&","^4:"]]]]],"^13","Apply a pure function to applicative arguments, e.g.\n\n   (ap + (just 1) (just 2) (just 3))\n   ;; => #<Just [6]>\n   (ap str [\"hi\" \"lo\"] [\"bye\" \"woah\" \"hey\"])\n   ;; => [\"hibye\" \"hiwoah\" \"hihey\"\n          \"lobye\" \"lowoah\" \"lohey\"]\n\n   `ap` is essentially sugar for `(apply fapply (pure f) args)`,\n   but for the common case where you have a pure, uncurried,\n   possibly variadic function.\n\n   `ap` actually desugars in `alet` form:\n\n   (macroexpand-1 `(ap + (just 1) (just2)))\n   ;; => (alet [a1 (just 1) a2 (just 2)] (+ a1 a2))\n\n   That way, variadic functions Just Work, without needing to specify\n   an arity separately.\n\n   If you're familiar with Haskell, this is closest to writing\n   \"in Applicative style\": you can straightforwardly convert\n   pure function application to effectful application by with\n   some light syntax (<$> and <*> in case of Haskell, and `ap` here).\n\n   See the original Applicative paper for more inspiration:\n   http://staff.city.ac.uk/~ross/papers/Applicative.pdf"],"^>","~$cats.core/ap","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",13,"^14",["^ ","^Y",true,"^15",1,"^10",1,"^V",["^R",[["^R",["~$f","^4:"]]]],"^Q",["^R",[["~$f","~$&","^4:"]]],"^X",["^R",[null]]],"^V",["^R",[["^R",["~$f","^4:"]]]],"^W",null,"^15",1,"^X",["^R",[null]],"^M",1,"^Y",true,"^17",[["^ ","^15",1,"^Y",true,"^18",["^9",["^1F","^1G"]]]],"^L",471,"^1D",true,"^Z","^19","^N",471,"^10",1,"^11",false,"^Q",["^R",[["~$f","~$&","^4:"]]],"^13","Apply a pure function to applicative arguments, e.g.\n\n   (ap + (just 1) (just 2) (just 3))\n   ;; => #<Just [6]>\n   (ap str [\"hi\" \"lo\"] [\"bye\" \"woah\" \"hey\"])\n   ;; => [\"hibye\" \"hiwoah\" \"hihey\"\n          \"lobye\" \"lowoah\" \"lohey\"]\n\n   `ap` is essentially sugar for `(apply fapply (pure f) args)`,\n   but for the common case where you have a pure, uncurried,\n   possibly variadic function.\n\n   `ap` actually desugars in `alet` form:\n\n   (macroexpand-1 `(ap + (just 1) (just2)))\n   ;; => (alet [a1 (just 1) a2 (just 2)] (+ a1 a2))\n\n   That way, variadic functions Just Work, without needing to specify\n   an arity separately.\n\n   If you're familiar with Haskell, this is closest to writing\n   \"in Applicative style\": you can straightforwardly convert\n   pure function application to effectful application by with\n   some light syntax (<$> and <*> in case of Haskell, and `ap` here).\n\n   See the original Applicative paper for more inspiration:\n   http://staff.city.ac.uk/~ross/papers/Applicative.pdf"],"~$foldm",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",946,"^M",7,"^N",946,"^O",12,"^Q",["^R",["^S",["^R",[["~$f","~$z","^1>"],["^C","~$f","~$z","^1>"]]]]],"^13","Given an optional monadic context, a function that takes two non-monadic\n  arguments and returns a value inside the given monadic context, an initial\n  value, and a collection of values, perform a left-associative fold.\n\n      (require '[cats.context :as ctx]\n               '[cats.core :as m]\n               '[cats.monad.maybe :as maybe])\n\n      (defn m-div [x y]\n        (if (zero? y)\n          (maybe/nothing)\n          (maybe/just (/ x y))))\n\n      (m/foldm m-div 1 [1 2 3])\n      (m/foldm maybe/context m-div 1 [1 2 3])\n      ;; => #<Just 1/6>\n\n      (m/foldm maybe/context m-div 1 [1 0 3])\n      ;; => #<Nothing>\n\n      (foldm m-div 1 [])\n      ;; => Exception\n\n      (m/foldm maybe/context m-div 1 [])\n      (ctx/with-context maybe/context\n        (foldm m-div 1 []))\n      ;; => #<Just 1>\n  ","^14",["^ ","^Y",false,"^15",4,"^10",4,"^V",["^R",[["~$f","~$z","^1>"],["^C","~$f","~$z","^1>"]]],"^Q",["^R",[["~$f","~$z","^1>"],["^C","~$f","~$z","^1>"]]],"^X",["^R",[null,null]]]],"^>","~$cats.core/foldm","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",12,"^14",["^ ","^Y",false,"^15",4,"^10",4,"^V",["^R",[["~$f","~$z","^1>"],["^C","~$f","~$z","^1>"]]],"^Q",["^R",[["~$f","~$z","^1>"],["^C","~$f","~$z","^1>"]]],"^X",["^R",[null,null]]],"^V",["^R",[["~$f","~$z","^1>"],["^C","~$f","~$z","^1>"]]],"^W",null,"^15",4,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^17",[["^ ","^15",3,"^Y",false,"^18","^19"],["^ ","^15",4,"^Y",false,"^18","^19"]],"^L",946,"^N",946,"^10",4,"^11",true,"^Q",["^R",[["~$f","~$z","^1>"],["^C","~$f","~$z","^1>"]]],"^13","Given an optional monadic context, a function that takes two non-monadic\n  arguments and returns a value inside the given monadic context, an initial\n  value, and a collection of values, perform a left-associative fold.\n\n      (require '[cats.context :as ctx]\n               '[cats.core :as m]\n               '[cats.monad.maybe :as maybe])\n\n      (defn m-div [x y]\n        (if (zero? y)\n          (maybe/nothing)\n          (maybe/just (/ x y))))\n\n      (m/foldm m-div 1 [1 2 3])\n      (m/foldm maybe/context m-div 1 [1 2 3])\n      ;; => #<Just 1/6>\n\n      (m/foldm maybe/context m-div 1 [1 0 3])\n      ;; => #<Nothing>\n\n      (foldm m-div 1 [])\n      ;; => Exception\n\n      (m/foldm maybe/context m-div 1 [])\n      (ctx/with-context maybe/context\n        (foldm m-div 1 []))\n      ;; => #<Just 1>\n  "],"~$bindings->batches",["^ ","^I",null,"^J",["^ ","^K","/Users/jude/Dropbox/Projects/aws/draw-graph/draw-graph.core/resources/public/cljs-out/dev/cats/core.cljc","^L",369,"^M",8,"^N",369,"^O",25,"^P",true,"^Q",["^R",["^S",["^R",[["^2Z"]]]]]],"^P",true,"^>","~$cats.core/bindings->batches","^K","resources/public/cljs-out/dev/cats/core.cljc","^O",25,"^V",["^R",[["^2Z"]]],"^W",null,"^X",["^R",[null,null]],"^M",1,"^Y",false,"^L",369,"^Z","^28","^N",369,"^10",1,"^11",true,"^Q",["^R",["^S",["^R",[["^2Z"]]]]]]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","^6","^6","^C","^D","^D","^D"],"~:cljs.analyzer/constants",["^ ","~:seen",["^9",["~$&","^1","~:else","~$cljs.core/->","^40","~$do","^4;","~:syms","~$cats.core/mlet","~$cljs.core/let","~$cats.core/alet","^1K","~:aps","^4C","^1T","~$cljs.core/fn","~$cljs.core/->>","^Q","~:body","^2O"]],"~:order",["^4D","^4N","^4G","^4K","^4C","^1","^40","^4L","^1K","^4F","^1T","^4J","^4;","^4I","^4E","^4H","^2O","^4M","^Q","~$&"]],"^13","Category Theory abstractions for Clojure"]